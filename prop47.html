<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Proposition 47</title>
  <meta name="description"
    content="Two interactive proofs of the Pythagorean theorem.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
    }
    .clickable {
      cursor: pointer;
    }
    .moveable {
      cursor: move;
    }
    svg {
      background-color: #ffffff;
      stroke-width: 0.02;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .svgtxt {
      font: bold 0.2px sans-serif;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;">
    <a href="index.html">Proposition 47</a></h1>
  <p>You can drag triangles and parallelograms around in this figure to
    understand Euclid's proof of the Pythagorean theorem, Proposition 47 of
    Book I of his <em>Elements</em>.  The triangle ABC is a right triangle.
    Euclid continues the triangle altitude from C, dividing the square on the
    hypotenuse AB into rectangles (colored blue and gold) having areas equal
    to the squares on the corresponding sides: Thus, the area of the square on
    the hypotenuse is the sum of the areas of the squares on the other two
    sides.  Each individual sliding or turning move you make clearly preserves
    area, but there are just enough steps that the conclusion is not at all
    obvious.</p>
  <div class="halfwide" style="float: right;">
  <svg id="prop47" xmlns="http://www.w3.org/2000/svg"
      viewBox="-2.05 -2.45 4.1 4.5" onload="prop47_interactions(evt)">
    <!-- illustration of Euclid's Proposition 47 with 3-4-5 triangle
         also illustrates Proposition 35 -->
    <!-- <rect x="-2.05" y="-2.45" width="4.1" height="4.5"
      style="fill: #ffffff; stroke: none;"/> -->
    <!-- blue(#83c2ff) gold(#ffe559) lightblue(#ddeeff) lightgold(#fff5bf)
         based on html colors dodgerblue(#1e90ff) and gold(#ffd700)
           by linear rgb color mixer with white(#ffffff)
         CIECAM02 JCH dodgerblue(48.2, 72.0, 275.) gold(83.4, 71.9, 95.3)
      visibility: none | hidden   (ignored by inkscape) object always in layout
      display: none | block | inline   (inline leaves margin?)
         F     E
      G     C     D
         A  H  B
            L
         J  I  K
      A: -1 0  B: 1 0  C: c -s  H: c 0
      D: s+1 c-1  E: c+s c-s-1  F: c-s -c-s-1  G: -s-1 -c-1
      J: -1 2  I: c 2  K: 1 2  L: c 2-s
        initially:
      A: -1.0 0.0  B: 1.0 0.0  C: 0.6 -0.8  H: 0.6 0.0
      D: 1.8 -0.4  E: 1.4 -1.2  F: -0.2 -2.4  G: -1.8 -1.6
      J: -1.0 2.0  I: 0.6 2.0  K: 1.0 2.0  L: 0.6 1.2
      Low to high in stack, suffix +/- dark/light b/g/w blue/gold/white:
      init0: BDEC-g BHIK-g ACFG-b AJIH-b   AHC+w BCH+w
        - click on colored region to begin, or near C to change (c, s)
      left1: BDEC-g BHIK-g ABFG+w AJIC+b   AHC+w => JIK+w
      left2: BDEC-g BHIK-g ABFG+w AJIH+w   AJLC+b => ABCG+b
      left3: BDEC-g BHIK-g ABFG+b AJIH+w   GCF+w => ABC+w
      right1: BDEA+w BCIK+g ACFG-b AJIH-b   BCH+w => KLI+w
      right2: BDEA+w BHIK+w ACFG-b AJIH-b   BCLK+g => BDCA+g
      right3: BDEA+w BHIK+w ACFG-b AJIH-b   CDE+w => ABC+w
        - slide white triangle over +dark area or rotate dark parallelogram
        - from initial state of left1/right1 or final state of left3/right3
          click on either square or rectangle; if +dark one, reset to init0;
          otherwise begin again with new region immediately
      -->
    <polygon class="clickable" id="polyur" fill="#fff5bf" stroke="#000000"
      points="1.0,0.0, 1.8,-0.4, 1.4,-1.2, 0.6,-0.8"/>  <!-- BDEC -->
    <polygon class="clickable" id="polylr" fill="#fff5bf" stroke="#000000"
      points="0.6,2.0, 1.0,2.0, 1.0,0.0, 0.6,0.0"/>  <!-- IKBH -->
    <polygon class="clickable" id="polyul" fill="#ddeeff" stroke="#000000"
      points="-0.2,-2.4, -1.8,-1.6, -1.0,0.0, 0.6,-0.8"/>  <!-- FGAC -->
    <polygon class="clickable" id="polyll" fill="#ddeeff" stroke="#000000"
      points="-1.0,0.0, -1.0,2.0, 0.6,2.0, 0.6,0.0"/>  <!-- AJIH -->
    <polygon class="" id="polymov" fill="#ffffff" stroke="#000000"
      transform="translate(0.0,0.0)"
      points="0.6,-0.8, -1.0,0.0, 1.0,0.0"/>  <!-- CAB -->
    <line id="altitude" stroke="#000000" display="block"
      x1="0.6" y1="-0.8" x2="0.6" y2="0.0"/>  <!-- CH -->
    <!-- circle to capture clicks on point C -->
    <circle class="moveable" id="pointc"
      display="block" style="fill:transparent; stroke:transparent;"
      cx="0.6" cy="-0.8" r="0.17"/>
    <text class="svgtxt" x="-1.05" y="0.18" style="text-anchor:end;">A</text>
    <text class="svgtxt" x="1.05" y="0.18">B</text>
    <text id="clabel" class="svgtxt" x="0.672" y="-0.896"
      style="text-anchor:middle;">C</text>
  </svg></div>
  <ol>
    <li>The proof must work for any right triangle, so you may first drag
      point C to select the angles you want.</li>
    <li>Click on any of the four colored regions to begin.  Your region will
      darken and its corresponding region, which we want to prove equal, will
      bleach to white.</li>
    <li>Slide the central white triangle outward over your darkened region,
      converting it into a parallelogram of equal area.</li>
    <li>Rotate this parallelogram ninety degrees.
      Because its sides initially coincide with the edges of the squares on
      the hypotenuse and one side, the ninety degree rotation leaves the
      sides coincident with the adjacent edges of their squares.</li>
    <li>Slide the white triangle inward over the parallelogram.  You have
      transformed your initial darkened region into its matching region
      without changing its area, thus proving the matching areas equal.</li>
    <li>Click on the darkened region to return to the initial state.</li>
  </ol>
</div>
<div class="textcolumn" style="clear: right; margin-top: 0.3em;">
  <div style="width: 40%; float: right;">
  <svg xmlns="http://www.w3.org/2000/svg" style="stroke-width: 0.0176"
      viewBox="-1.2 -1.1 2.4 1.4">
    <polygon fill="#ffffff" stroke="#000000"
      points="0.6,-0.8, -1.0,0.0, 1.0,0.0"/>  <!-- CAB -->
    <line stroke="#000000" display="block"
      x1="0.6" y1="-0.8" x2="0.6" y2="0.0"/>  <!-- CH -->
    <text class="svgtxt" x="-1.0" y="0.2" style="text-anchor:middle;">A</text>
    <text class="svgtxt" x="1.0" y="0.2" style="text-anchor:middle;">B</text>
    <text class="svgtxt" x="0.6" y="-0.85" style="text-anchor:middle;">
      C</text>
    <text class="svgtxt" x="0.6" y="0.2" style="text-anchor:middle;">H</text>
  </svg></div>
  <p>Euclid's argument is elegant because he shows us how to partition
    the square on the hypotenuse into parts which separately equal the
    squares on the sides.  Furthermore, the altitude from point H on
    the the hypotenuse AB to the right angle C connects algebra and
    geometry in important ways.  For example, the height HC is the
    geometric mean between HA and HB.  Even more important in wave
    physics is the reciprocal Pythagorean theorem: The sum of the
    squares of the reciprocals of the sides AC and BC equals the
    square of the reciprocal of the height HC.</p>
</div>
<div class="textcolumn" style="clear: right; margin-top: 0.3em;">
  <p>Elegance and foreshadowing aside, Euclid's proof does go beyond the bare
    statement of the proposition.  We don't really need to partition the square
    on the hypotenuse.  Here is a well-known proof which sheds that baggage,
    not distinguishing between the areas of the squares on the sides at all.</p>
  <div class="halfwide" style="float: right;">
  <svg xmlns="http://www.w3.org/2000/svg" style="stroke-width: 0.0078"
      viewBox="-0.8 -0.8 1.6 1.6" onload="alt47_interactions(evt)">
    <rect id="rect0" fill="#83c2ff" stroke="#000000" x="-0.7" y="-0.7"
      width="1.4" height="1.4"/>
    <polygon class="moveable" id="tri0" fill="#ffffff" stroke="#000000"
      transform="translate(0.0,0.0)" points="0.1,-0.1, 0.1,0.7, 0.7,0.7"/>
    <polygon class="moveable" id="tri1" fill="#ffffff" stroke="#000000"
      transform="translate(0.0,0.0)" points="0.1,-0.1, 0.7,0.7, 0.7,-0.1"/>
    <polygon class="" id="tri2" fill="#ffffff" stroke="#000000"
      transform="translate(0.0,0.0)" points="0.1,-0.1, 0.1,-0.7, -0.7,-0.1"/>
    <polygon id="tri3" fill="#ffffff" stroke="#000000"
      points="-0.7,-0.1, 0.1,-0.7, -0.7,-0.7"/>
    <polygon class="moveable" id="ghost" fill="#ffffff" stroke="#8c7600"
      display="block" opacity="0.0" fill-rule="nonzero"
      transform="rotate(0.0,0.4,-0.4)"
      points="0.1,-0.7, -0.7,-0.1, 0.1,-0.1, 0.1,-0.7, -0.7,-0.7, -0.7,-0.1"/>
    <circle class="moveable" id="circ0"
      display="block" style="fill:transparent; stroke:transparent;"
      cx="0.1" cy="-0.1" r="0.1"/>
  </svg></div>
  <ol>
    <li>Again, you may first drag the intersection point where the two blue
      squares touch to select the shape of the four right triangles.</li>
    <li>In the initial configuration, you may also drag the upper left
      white rectangle downward to rotate it by ninety degrees, checking that
      the diagonals of the white rectangles are ninety degrees apart.</li>
    <li>Split the lower right white rectangle, sliding one of its triangles
      left and the other up as far as possible.</li>
    <li>Split the upper left white rectangle by sliding its central triangle
      down and right as far as possible, creating a tilted blue square in
      the center.</li>
  </ol>
  <p>The shape of the blue area has changed from two squares whose sides
    are the sides of the right triangles into a single square whose side
    is the hypotenuse of the right triangles, proving the proposition.
    The adjacent sides of the tilted square in the final configuration
    are perpendicular because the two white rectangles in the initial
    configuration, including their diagonals, are identical after a ninety
    degree rotation.</p>
</div>
<div class="textcolumn" style="clear: right; margin-top: 0.3em;">
  <p>The fact that translating (sliding) or rotating any shape does not
    change its area is really a fundamental principle of physics.
    The axioms of geometry come from our experience of the world around us.
    As Newton puts in in the preface to <em>Principia</em>:</p>
  <blockquote>
    To describe right lines and circles are problems, but not geometrical
    problems.  The solution of these problems is required from mechanics,
    and by geometry the use of them, when so solved is shown; and it is the
    glory of geometry that from those few principles, brought from without, it
    is able to produce so many things.  Therefore geometry is founded in
    mechanical practice, and is nothing but that part of universal mechanics
    which accurately proposes and demonstrates the art of measuring.
  </blockquote>
</div>

<script>function prop47_interactions(evt) {
  var prop47 = evt.target;
  var poly_ids = ["polyur", "polylr", "polyul", "polyll", "polymov"]
  var polys = poly_ids.map(
   function(id) {return document.getElementById(id)});
  var fills = polys.map(
   function(p) {return p.getAttributeNodeNS(null, "fill")});
  var points = polys.map(
   function(p) {return p.getAttributeNodeNS(null, "points")});
  var classes = polys.map(
   function(p) {return p.getAttributeNodeNS(null, "class")});
  var movxfrm = polys[4].getAttributeNodeNS(null, "transform");
  var altitude = document.getElementById("altitude");
  var altitude_disp = altitude.getAttributeNodeNS(null, "display");
  var altitude_x1 = altitude.getAttributeNodeNS(null, "x1");
  var altitude_y1 = altitude.getAttributeNodeNS(null, "y1");
  var altitude_x2 = altitude.getAttributeNodeNS(null, "x2");
  var pointc = document.getElementById("pointc");
  var pointc_x = pointc.getAttributeNodeNS(null, "cx");
  var pointc_y = pointc.getAttributeNodeNS(null, "cy");
  var pointc_disp = pointc.getAttributeNodeNS(null, "display");
  var clabel = document.getElementById("clabel");
  var clabel_x = clabel.getAttributeNodeNS(null, "x");
  var clabel_y = clabel.getAttributeNodeNS(null, "y");

  function svgcoords(e) {  // return svg#prop47 event coordinates
    var CTM = prop47.getScreenCTM();
    if (e.touches) {
      e = e.touches[0];
    }
    return {
      x: (e.clientX - CTM.e) / CTM.a,
      y: (e.clientY - CTM.f) / CTM.d
    };
  }

  var rad2deg = 180. / Math.PI;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  // BDE[CA] 1 0, s+1 c-1, c+s c-s-1, [c -s, -1 0]
  // IKB[HC] c 2, 1 2, 1 0, [c 0, c -s]
  // FGA[CB] c-s -c-s-1, -s-1 -c-1, -1 0, [c -s, 1 0]
  // AJI[HC] -1 0, -1 2, c 2, [c 0, c -s]
  // CAB c -s, -1 0, 1 0  CAH c -s, -1 0, c 0  CHB c -s, c 0, 1 0
  // AJLC -1 0, -1 2, c 2-s, c -s  BCLK 1 0, c -s, c 2-s, 1 2
  var bde, ikb, fga, aji, cab, astr, bstr, cstr, hstr, ajlc, bclk;
  var cparam, sparam, aslope, bslope;
  astr = "-1.0,0.0";
  bstr = "1.0,0.0";

  function point_set(c, s) {
    if (c === undefined) {
      c = pointc_x.value;  s = -(+pointc_y.value);
    }
    c = cparam = +c;  s = sparam = +s;  // make sure c and s are numbers
    aslope = -sparam / (cparam + 1.);
    bslope = sparam / (cparam - 1.);
    altitude_x1.value = altitude_x2.value = pointc_x.value = c;
    altitude_y1.value = pointc_y.value = -s;
    cstr = c + "," + (-s);
    hstr = c + ",0.0";
    bde = "1.0 0.0, "+(s+1.)+","+(c-1.)+", "+(c+s)+","+(c-s-1.)+", ";
    ikb = c+",2.0, 1.0,2.0, 1.0,0.0, ";
    fga = (c-s)+","+(-c-s-1.)+", "+(-s-1.)+","+(-c-1.)+"  -1.0,0.0, ";
    aji = "-1.0,0.0, -1.0,2.0, "+c+",2.0, ";
    ajlc = "-1.0,0.0, -1.0,2.0, "+c+","+(2.-s)+", "+cstr;
    bclk = "1.0,0.0, "+cstr+", "+c+","+(2.-s)+", 1.0,2.0";
    clabel_x.value = 1.12 * c;
    clabel_y.value = -1.12 * s;
  }

  function initialize(c, s) {
    point_set(c, s);
    fills[0].value = fills[1].value = "#fff5bf";
    fills[2].value = fills[3].value = "#ddeeff";
    fills[4].value = "#ffffff";
    points[0].value = bde + cstr;
    points[1].value = ikb + hstr;
    points[2].value = fga + cstr;
    points[3].value = aji + hstr;
    points[4].value = cstr + "  " + astr + "  " + bstr;
    movxfrm.value = "translate(0.0,0.0)";
    altitude_disp.value = pointc_disp.value = "block";
    classes[0].value = classes[1].value = "clickable";
    classes[2].value = classes[3].value = "clickable";
    classes[4].value = "";
  }
  initialize();

  var selected, offset, delta;
  var drag_ready = true;
  var state = -1;
  var pending = false;
  prop47.addEventListener("mousedown", startDrag);
  prop47.addEventListener("mousemove", doDrag);
  prop47.addEventListener("mouseup", endDrag);
  prop47.addEventListener("mouseleave", endDrag);
  prop47.addEventListener("touchstart", startDrag);
  prop47.addEventListener("touchmove", doDrag);
  prop47.addEventListener("touchend", endDrag);
  prop47.addEventListener("touchcancel", endDrag);

  function startDrag(evt) {
    evt.stopPropagation();
    evt.preventDefault();  // make usable for touch events
    var targ = evt.target;
    var index = polys.indexOf(targ);
    selected = null;

    if (state < 0) {
      if (targ === pointc) {
        selected = targ;
        offset = svgcoords(evt);
        offset.x -= +pointc_x.value;
        offset.y -= +pointc_y.value;
      } else {
        if (index < 2) {
          selected = targ;
          drag_ready = pending = false;
          state = index;
          delta = 0.0;
          fills[index].value = "#ffe559";
          fills[1-index].value = "#ffffff";
          if (index === 0) {
            points[0].value = bde + "-1.0,0.0";
            classes[1].value = classes[2].value = classes[3].value = "";
          } else {
            points[1].value = ikb + cstr;
            points[4].value = cstr + ", " + hstr + ", " + bstr;
            classes[0].value = classes[2].value = classes[3].value = "";
          }
          classes[4].value = "moveable";
          altitude_disp.value = pointc_disp.value = "none";
        } else if (state < 4 && index < 4) {
          selected = targ;
          drag_ready = pending = false;
          state = index;
          delta = 0.0;
          fills[index].value = "#83c2ff";
          fills[5-index].value = "#ffffff";
          if (index === 2) {
            points[2].value = fga + "1.0,0.0";
            classes[0].value = classes[1].value = classes[3].value = "";
          } else {
            points[3].value = aji + cstr;
            points[4].value = cstr + ", " + astr + ", " + hstr;
            classes[0].value = classes[1].value = classes[2].value = "";
          }
          classes[4].value = "moveable";
          altitude_disp.value = pointc_disp.value = "none";
        } else {
          state = -1;
        }
      }

    } else if (state < 4) {
      if (state === index) {
        if (delta === 0.0) {
          initialize();
          state = -1;
        } else if (pending) {
          offset = svgcoords(evt);
          offset.x -= (state < 2)? 1.0 : -1.0;
          var r = offset.x*offset.x + offset.y*offset.y;
          if (r < 0.1) {
            return;
          }
          r = sqrt(r);
          offset.x /= r;
          offset.y /= r;
          pending = false;
          if (state < 2) {
            points[4].value = bclk;
            fills[4].value = "#ffe559";
            fills[state].value = "#ffffff";
            if (state === 0) {
              movxfrm.value = "rotate(90.0,1.0,0.0)";
              delta = 90.0;
              r = offset.x;
              offset.x = offset.y;
              offset.y = -r;
            } else {
              points[0].value = bde + "-1.0,0.0";
              points[1].value = ikb + hstr;
              movxfrm.value = "rotate(0.0,1.0,0.0)";
              delta = 0.0;
            }
            state = 4;
          } else {
            points[4].value = ajlc;
            fills[4].value = "#83c2ff";
            fills[state].value = "#ffffff";
            if (state === 2) {
              movxfrm.value = "rotate(-90.0,-1.0,0.0)";
              delta = 90.0;
              r = offset.x;
              offset.x = -offset.y;
              offset.y = r;
            } else {
              points[2].value = fga + "1.0,0.0";
              points[3].value = aji + hstr;
              movxfrm.value = "rotate(0.0,-1.0,0.0)";
              delta = 0.0;
            }
            state = 5;
          }
          selected = polymov;
        }
      } else if (index === 4) {
        selected = targ;
        offset = svgcoords(evt);
        if (state === 0) {
          offset.x -= delta;
        } else if (state === 2) {
          offset.x += delta;
        } else {
          offset.y -= delta;
        }
      }

    } else if (index === 4) {
      offset = svgcoords(evt);
      offset.x -= (state === 4)? 1.0 : -1.0;
      var r = offset.x*offset.x + offset.y*offset.y;
      if (r < 0.1) {
        return;
      }
      r = sqrt(r);
      offset.x /= r;
      offset.y /= r;
      /* (xx,yy) = current direction of what is (0,1) when delta=0 */
      var yy = cos(delta / rad2deg);
      var xx = sin(((state===4)? -delta : delta) / rad2deg);
      /* convert offset direction to what it would be at delta=0 */
      var offset_x = offset.x;
      offset.x = offset_x*yy - offset.y*xx;
      offset.y = offset_x*xx + offset.y*yy;
      selected = targ;

    } else if (state === 4) {
      if (index === 0 && delta === 90.0) {
        selected = targ;
        offset = svgcoords(evt);
        fills[0].value = "#ffe559"
        fills[4].value = "#ffffff";
        points[4].value = cstr + ", " + astr + ", " + bstr;
        delta = sparam;
        movxfrm.value = "translate(" + delta + "," + (aslope*delta) + ")";
        offset.x -= delta;
        state = 0;
        pending = true;
      } else if (index === 1 && delta === 0.0) {
        selected = targ;
        offset = svgcoords(evt);
        fills[1].value = "#ffe559"
        fills[4].value = "#ffffff";
        points[0].value = bde + cstr;
        points[1].value = ikb + cstr;
        points[4].value = cstr + ", " + hstr + ", " + bstr;
        delta = 2.0;
        movxfrm.value = "translate(0.0," + delta + ")";
        offset.y -= delta;
        state = 1;
        pending = true;
      }

    } else if (state == 5) {
      if (index === 2 && delta === 90.0) {
        selected = targ;
        offset = svgcoords(evt);
        fills[2].value = "#83c2ff";
        fills[4].value = "#ffffff";
        points[4].value = cstr + ", " + astr + ", " + bstr;
        delta = sparam;
        movxfrm.value = "translate("+(-delta)+","+(bslope*delta)+")";
        offset.x += delta;
        state = 2;
        pending = true;
      } else if (index === 3 && delta === 0.0) {
        selected = targ;
        offset = svgcoords(evt);
        fills[3].value = "#83c2ff";
        fills[4].value = "#ffffff";
        points[2].value = fga + cstr;
        points[3].value = aji + cstr;
        points[4].value = cstr + ", " + astr + ", " + hstr;
        delta = 2.0;
        movxfrm.value = "translate(0.0," + delta + ")";
        offset.y -= delta;
        state = 3;
        pending = true;
      }
    }
  }

  /* We work around a strange bug in firefox 72 on Windows 10, in which
   * the polymov is misdrawn if the translate() or rotate() transform is
   * set to exactly 0.0 during doDrag.  This may only happen on some
   * machines.  The workaround is to add 0.00001 to delta.
   */
  function doDrag(evt) {
    evt.stopPropagation();
    evt.preventDefault();  // make usable for touch events
    if (selected && drag_ready) {
      var coord = svgcoords(evt);
      if (state === -1) {
        var dx = coord.x - offset.x;
        var dy = coord.y - offset.y;
        var dr = sqrt(dx*dx + dy*dy);
        if (dy > -0.3 || dr < 0.3) {
          dx = 0.6;  dy = -0.8;
        } else {
          dx /= dr;  dy /= dr;
        }
        initialize(dx, -dy);

      } else if (state < 4) {
        if (state === 0) {
          delta = clip0(coord.x - offset.x, sparam);
          pending = (delta >= sparam);
          movxfrm.value = "translate("+(delta+0.00001)+","+(aslope*delta)+")";
        } else if (state === 2) {
          delta = clip0(offset.x - coord.x, sparam);
          pending = (delta === sparam);
          movxfrm.value = "translate("+(-delta-0.00001)+","+(bslope*delta)+")";
        } else {
          delta = clip0(coord.y - offset.y, 2.0);
          pending = (delta >= 2.0);
          movxfrm.value = "translate(0.00001," + delta + ")";
        }
        if (pending) {
          classes[state].value = "moveable";
        } else {
          classes[state].value = (delta === 0.0)? "clickable" : "";
        }

      } else {
        coord.x -= (state === 4)? 1.0 : -1.0;
        var r = sqrt(coord.x*coord.x + coord.y*coord.y);
        if (r === 0.0) {
          coord.x = 0.0;
          coord.y = 1.0;
        } else {
          coord.x /= r;
          coord.y /= r;
        }
        var coord_x = coord.x;
        coord.x = offset.y*coord_x - offset.x*coord.y;
        coord.y = offset.x*coord_x + offset.y*coord.y;
        delta = atan2(((state === 4)? -coord.x : coord.x), coord.y);
        delta = clip0(delta * rad2deg, 90.);
        if (state === 4) {
          movxfrm.value = "rotate(" + (delta+0.00001) + ",1.0,0.0)";
        } else {
          movxfrm.value = "rotate(" + (-delta-0.00001) + ",-1.0,0.0)";
        }
        classes[0].value = classes[1].value = "";
        classes[2].value = classes[3].value = "";
        if (delta === 0.0) {
          classes[(state === 4)? 1 : 3].value = "moveable";
        } else if (delta === 90.0) {
          classes[(state === 4)? 0 : 2].value = "moveable";
        }
      }
    }
  }

  function clip0(x, xmax) {
    if (x < 0.0) {
      x = 0.0;
    } else if (x > xmax) {
      x = xmax;
    }
    return x;
  }

  function endDrag(evt) {
    evt.stopPropagation();
    evt.preventDefault();  // make usable for touch events
    selected = null;
    drag_ready = true;
  }
}
function alt47_interactions(evt) {
  var alt47 = evt.target;
  var ids = ["tri0", "tri1", "tri2", "circ0", "ghost"];
  var movers = ids.map(
   function(id) {return document.getElementById(id)});
  var tris = movers.slice(0, 3);
  var classes = tris.map(
   function(p) {return p.getAttributeNodeNS(null, "class")});
  var xforms = tris.map(
   function(p) {return p.getAttributeNodeNS(null, "transform")});
  var points = tris.map(
   function(p) {return p.getAttributeNodeNS(null, "points")});
  var cxatt = movers[3].getAttributeNodeNS(null, "cx");
  var cyatt = movers[3].getAttributeNodeNS(null, "cy");
  var circ0_disp = movers[3].getAttributeNodeNS(null, "display");
  var tri3pts = document.getElementById(
      "tri3").getAttributeNodeNS(null, "points");
  var ghostpts = movers[4].getAttributeNodeNS(null, "points");
  var ghostx = movers[4].getAttributeNodeNS(null, "transform");
  var ghosto = movers[4].getAttributeNodeNS(null, "opacity");
  var ghostd = movers[4].getAttributeNodeNS(null, "display");
  var ghostc = 0.4
  var rad2deg = 180. / Math.PI;
  var atan2 = Math.atan2;

  function svgcoords(e) {  // return svg#prop47 event coordinates
    var CTM = alt47.getScreenCTM();
    if (e.touches) {
      e = e.touches[0];
    }
    return {
      x: (e.clientX - CTM.e) / CTM.a,
      y: (e.clientY - CTM.f) / CTM.d
    };
  }

  var selected = null;
  var param = 0.1;  // a = 0.7+param, b = 0.7-param
  var deltas = [0.0, 0.0, 0.0];  // [dx, dy, dy] offsets of triangles 0 1 2
  var adjust = 0.0;  // adjustment required to allow for inexact mouse down
  alt47.addEventListener("mousedown", startDrag);
  alt47.addEventListener("mousemove", doDrag);
  alt47.addEventListener("mouseup", endDrag);
  alt47.addEventListener("mouseleave", endDrag);
  alt47.addEventListener("touchstart", startDrag);
  alt47.addEventListener("touchmove", doDrag);
  alt47.addEventListener("touchend", endDrag);
  alt47.addEventListener("touchcancel", endDrag);

  function is_moveable(index) {
    if (index > 2) {
      return !(deltas[0] || deltas[1]);
    } else if (index === 2) {
      return !((deltas[0] > -0.7-param) || (deltas[1] > param-0.7));
    } else if (index >= 0) {
      return !deltas[2];
    } else {
      return false;
    }
  }

  function startDrag(evt) {
    evt.stopPropagation();
    evt.preventDefault();  // make usable for touch events
    selected = null;
    var targ = evt.target;
    var index = movers.indexOf(targ);
    if (!is_moveable(index)) {
      return;
    }
    selected = index;
    var s = svgcoords(evt);
    if (selected === 4) {
      adjust = atan2(-ghostc - s.y, ghostc - s.x);
      ghosto.value = "0.5";
      return;
    }
    s = selected? s.y : s.x;
    if (selected === 3) {
      adjust = -param - s;
    } else if (selected === 0) {
      adjust = param + deltas[0] - s;
    } else if (selected === 1) {
      adjust = -param + deltas[1] - s;
    } else {
      adjust = -0.7 + deltas[2] - s;
    }
  }

  function doDrag(evt) {
    evt.stopPropagation();
    evt.preventDefault();  // make usable for touch events
    if (selected === null) {
      return;
    }
    var s = svgcoords(evt);
    if (selected === 4) {
      var dy = -ghostc - s.y;
      var dx = ghostc - s.x;
      if ((!dx) && (!dy)) {
        dx = 1.0;
      }
      s = rad2deg * (atan2(dy, dx) - adjust);
      ghostx.value = "rotate(" + s + "," + ghostc + "," + (-ghostc) + ")";
      return;
    }
    s = selected? s.y : s.x;
    if (selected === 3) {
      s += adjust;
      param = -s;
      if (param > 0.6) {
        param = 0.1;  // reset
      } else if (param < 0.0) {
        param = 0.0;
      }
      var x, y;
      cxatt.value = x = "" + param;
      cyatt.value = y = "" + (-param);
      var xy = x + "," + y + ", ";
      points[0].value = xy + x + ",0.7, 0.7,0.7";
      points[1].value = xy + "0.7,0.7, 0.7," + y;
      points[2].value = xy + x + ",-0.7, -0.7," + y;
      tri3pts.value = "-0.7," + y + ", " + x + ",-0.7, -0.7,-0.7";
      ghostpts.value = (x + ",-0.7, -0.7," + y + ", " + xy + x
                        + ",-0.7, -0.7,-0.7, -0.7," + y);
      ghostc = 0.5*(param + 0.7);
      ghostx.value = "rotate(0.0," + ghostc + "," + (-ghostc) + ")";
      return;
    }
    if (selected === 0) {
      s += adjust;
      s -= param;
      if (s >= 0.0) {
        s = 0.0;
        if (deltas[0] && !deltas[1]) {
          circ0_disp.value = ghostd.value = "block";
        }
      } else if (s <= -0.7-param) {
        s = -0.7-param;
        if (deltas[0] > -0.7-param && deltas[1] <= param-0.7) {
          classes[2].value = "moveable";
        }
      } else if (deltas[0] <= -0.7-param && deltas[1] <= param-0.7) {
        classes[2].value = "";
      } else if (!(deltas[0] || deltas[1])) {
        circ0_disp.value = ghostd.value = "none";
      }
      deltas[0] = s;
      xforms[0].value = "translate(" + (s-0.00001) + ",0.0)"
    } else if (selected === 1) {
      s += adjust;
      s += param;
      if (s >= 0.0) {
        s = 0.0;
        if (deltas[1] && !deltas[0]) {
          circ0_disp.value = ghostd.value = "block";
        }
      } else if (s <= param-0.7) {
        s = param-0.7;
        if (deltas[1] > param-0.7 && deltas[0] <= -0.7-param) {
          classes[2].value = "moveable";
        }
      } else if (deltas[0] <= -0.7-param && deltas[1] <= param-0.7) {
        classes[2].value = "";
      } else if (!(deltas[0] || deltas[1])) {
        circ0_disp.value = ghostd.value = "none";
      }
      deltas[1] = s;
      xforms[1].value = "translate(0.0," + (s-0.00001) + ")"
    } else if (selected === 2) {
      s += adjust;
      s += 0.7;
      if (s <= 0.0) {
        s = 0.0;
        if (deltas[2]) {
          classes[0].value = classes[1].value = "moveable";
        }
      } else if (s >= 0.7+param) {
        s = 0.7+param;
      } else if (!deltas[2]) {
        classes[0].value = classes[1].value = "";
      }
      deltas[2] = s;
      var t = s * (0.7 - param)/(0.7 + param);
      xforms[2].value = "translate(" + t + "," + (s+0.00001) + ")"
    }
  }

  function endDrag(evt) {
    evt.stopPropagation();
    evt.preventDefault();  // make usable for touch events
    if (selected === 4) {
      ghosto.value = "0.0";
      ghostx.value = "rotate(0.0," + ghostc + "," + (-ghostc) + ")";
    }
    selected = null;
    adjust = 0.0;
  }
}
</script>

</body>
</html>
