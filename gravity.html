<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>The Geometry of Planetary Orbits</title>
  <meta name="description"
    content="A derivation of Kepler's laws from Newton's inverse square law
             using as little algebra as possible.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>MathJax = {tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
          id="MathJax-script">
  </script>
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
      float: right;
    }
    .clickable {
      cursor: pointer;
    }
    .backlit {
      background-color: #d8d8d8;
    }
    svg {
      background-color: #ffffff;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .belowsvg {
      font: italic bold large serif;
      padding-top: 0px;
      margin-top: 0px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .svgtxt {
        font: bold 0.8px sans-serif;
        pointer-events: none;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;">
    <a href="index.html">The Geometry of Planetary Orbits</a></h1>


  <h2>Introduction</h2>
  <p>In 1687 Isaac Newton published "Philosophiae Naturalis Principia
    Mathematica," arguably the most influential science book ever
    written.  In addition to providing the framework still used for
    all of mechanics, the Principia introduces Newton's theory of
    universal gravitation, which posits an attractive force between
    all masses varying inversely as the square of their distance.  A
    centerpiece of Principia is Newton's demonstration that Kepler's
    three laws of planetary motion are mathematically equivalent to
    his radically simpler inverse square central force law.  This is
    an exceptionally difficult math problem, even for students who can
    bring all the developments of calculus in the intervening 350
    years to bear on it.  But every math problem has many solutions,
    and along one narrow path through the logic of this problem, each
    individual step makes no demands beyond the most elementary plane
    geometry and algebra.  Here we go.</p>
  <p>Kepler's three laws are: First, each planet orbits the sun in an
    ellipse with the sun at one focus.  Second, the planet moves
    around its ellipse so that the radius drawn from the sun to the
    planet sweeps out equal areas in equal times.  Third, the ratio of
    the cube of the semi-major axis of the orbital ellipse to the
    square of the time for a complete orbit is the same for every
    planet.  We aim to show that if a planet begins from any point in
    the solar system and moving with any velocity, and thereafter is
    attracted to the sun by a force varying inversely as the square of
    its distance from the sun, it will orbit forever according to
    Kepler's laws.  (We assume our planet is subject to no other
    forces.)</p>
  <p>Our elementary path leads through three waypoints, which you may
    visit in any order: The first is to master the geometry of the
    focus points and tangent lines of an ellipse, in order to
    comprehend what Kepler is talking about.  The second preliminary
    topic is circular motion, introducing the concept of velocity
    space.  We must extend this study to the velocity space analog of
    circular motion, which is motion at a constant speed.  The third
    preliminary is to demonstrate that all central force laws, whether
    an inverse square law or any other, cause motions obeying Kepler's
    equal area law.  Note that our third preliminary step actually
    achieves a part of our final goal.  With these three preliminaries
    fresh in our minds, the fact that an inverse square law orbit will
    be a Keplerian ellipse follows fairly easily.  Kepler's third law,
    involving cubes and squares, requires several final algebraic
    steps to complete the demonstration.</p>


  <h2>Ellipse Focus and Tangent Geometry</h2>

  <p>Kepler's first law says that a planet P moves around the sun S in
    an ellipse with the sun at one focus; this figure explains what
    that means.  A circle is the set of all points a given distance
    from a center.  An ellipse is the set of all points P with a given
    sum of distances from two focus points S and O.  You can imagine
    connecting pins at S and O by a string of length SP+PO, which you
    stretch taught by a pencil at P.  By keeping the string taught,
    you can move the pencil along the ellipse.  Instead of a single
    center, an ellipse has two focus points, S and O.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -10.5 21 21" onload="fig1_interactions(evt)"
       stroke-width="0.1">
    <path id="sp1" fill="none" stroke="black" d="M 0.0,0.0 L 0.0,-3.2" />
    <path id="opq1" fill="none" stroke="#0080ff"
          d="M -6.0,0.0 L 0.0,-3.2 L 0.0,-10.0" />
    <path id="oq1" fill="none" stroke="#c0c0c0" d="M -6.0,0.0 L 0.0,-10.0" />
    <path id="pm1" fill="none" stroke="#c0c0c0"
          d="M -4.3933,-5.8360 L 2.8051,-1.5170" />
    <circle fill="none" stroke="#c0c0c0" cx="0" cy="0" r="10.0" />
    <ellipse id="ell1" fill="none" stroke="black" stroke-width="0.13"
             cx="-3.0" cy="0" rx="5.0" ry="4.0" />
    <circle id="focs1" fill="black" cx="0" cy="0" r="0.2" />
    <circle id="pntp1" fill="black" cx="0" cy="-3.2" r="0.2" />
    <circle id="pntm1" fill="black" cx="-3" cy="-5" r="0.2" />
    <path id="snq1" fill="none" stroke="transparent"
          d="M 0.0,0.0 L -3.0,-5.0 L 0.0,-10.0 M -6.0,0.0 L -3.0 -5.0" />
    <circle id="pntn1" class="clickable" fill="transparent" stroke="transparent"
            stroke-width="0.3" cx="-3" cy="-5" r="0.2" />
    <circle id="foco1" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="-6.0" cy="0" r="0.2" />
    <circle id="pntq1" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="0" cy="-10.0" r="0.2" />
    <text class="svgtxt" id="txs1" x="-0.3" y="0.9">S</text>
    <text class="svgtxt" id="txo1" x="-6.3" y="0.9">O</text>
    <text class="svgtxt" id="txp1" x="0.29" y="-3.188">P</text>
    <text class="svgtxt" id="txq1" x="0.2" y="-9.2">Q</text>
    <text class="svgtxt" id="txm1" x="-3.4" y="-5.4">M</text>
    <text class="svgtxt" id="txn1" fill="transparent" x="-3.5" y="-5.4">N</text>
  </svg>
  </div>
  <p>If we extend the sun-planet line SP to point Q such that the blue
    segments OP and PQ in the figure are equal, something interesting
    happens: Since SP+OP is the same for any point P on the ellipse,
    SP+PQ is also fixed, independent of P.  Therefore, the point Q
    traces a circle with center S as P moves around the ellipse; the
    radius of this circle is the length of the string SP+PO.</p>
  <p>Next, consider the midpoint M of the segment OQ.  Since by our
    construction of Q, P is also equidistant from O and Q, the line PM
    is the perpendicular bisector of OQ, the set of all points
    equidistant from O and Q.  The line PM appears to be tangent to
    the ellipse at P, that is PM just touches the ellipse at P without
    crossing inside.  To prove this tangency, note that the sum of the
    distances from S and O is less than SP+PO inside the ellipse, and
    greater than SP+PO outside the ellipse.  For every point N on PM,
    the sum SN+NO is equal to the sum SN+NQ, which is always greater
    than SP+PQ for any N except P, because SPQ is a straight line -
    the shortest distance between S and Q.</p>
  <p>The figure is interactive.  You can drag the point O to see how the
    shape of the ellipse depends on the distance from O to S (at fixed
    string length SQ).  Notice that when O coincides with S, the ellipse
    becomes a circle.  You can drag the point Q to watch what happens as
    P moves around the ellipse.  Finally, you can drag the point M along
    PM to create a point N, to help you visualize the proof that SN+NQ
    is always greater than SPQ, so that line PM is entirely outside the
    ellipse, touching it only at point P.</p>


  <h2>Circular and Constant Speed Motion</h2>

  <p>Consider an object moving at a constant speed around a circle, as
    depicted in the next figure.  We introduce the concept of vectors
    - quantities with both magnitude and direction which we represent
    as arrows in diagrams.  The most basic vector is position measured
    from a given point.  The black vector on the left side of the
    figure goes from the center of the circle to the orbiting object;
    its magnitude $r$ is the radius of the circular orbit.  You can
    press and hold the button at the bottom of the figure to animate
    this motion.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -6.0 21 11" onload="fig2_interactions(evt)"
       stroke-width="0.1">
    <defs>
      <marker id="arrowk" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="black" stroke="black" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowg" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#c0c0c0" stroke="#c0c0c0" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowb" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#0080ff" stroke="#0080ff" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowo" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#ff8000" stroke="#ff8000" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
    </defs>
    <path fill="none" stroke="#f0f0f0" stroke-width="0.3"
          d="M 0.0,-4.85 L 0.0,3.7" />
    <circle fill="none" stroke="#c0c0c0" cx="-5.0" cy="0" r="4.4" />
    <circle fill="none" stroke="#a0d0ff" cx="5.0" cy="0" r="4.4" />
    <path id="posr2" fill="none" stroke="black" marker-end="url(#arrowk)"
          d="M -5.0,0.0 L -5.0,-4.4" />
    <path id="posv2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -5.0,-4.4 l -1.7,0.0" />
    <path id="posw2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -3.5,0.0 a 1.5,1.5 0 0,0 -1.5,-1.5" />
    <circle fill="black" cx="-5.0" cy="0.0" r="0.2" />
    <circle id="dotr2" fill="black" cx="-5.0" cy="-4.4" r="0.2" />
    <path id="velv2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,0.0 L 0.6,0.0" />
    <path id="velg2" fill="none" stroke="#ff8000" marker-end="url(#arrowo)"
          d="M 0.6,0.0 l 0.0,1.7" />
    <path id="velw2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5" />
    <circle fill="#0080ff" cx="5.0" cy="0.0" r="0.2" />
    <circle id="dotv2" fill="#0080ff" cx="0.6" cy="0.0" r="0.2" />
    <circle id="press2" class="clickable" fill="#b0b0b0" stroke="#606060"
            stroke-width="0.2" cx="0.0" cy="4.5" r="0.4" />
    <text class="svgtxt" x="-6.6" y="-5.0">position</text>
    <text class="svgtxt" fill="#0080ff" x="3.5" y="-5.0">velocity</text>
    <text class="svgtxt" id="pos2r" fill="black" x="-4.8" y="-3.2">r</text>
    <text class="svgtxt" id="pos2v" fill="#0080ff" x="-6.4" y="-3.5">
      v&#x03c4;</text>
    <text class="svgtxt" id="pos2w" fill="#0080ff" x="-4.0" y="-1.2">
      &#x03c9;</text>
    <text class="svgtxt" id="vel2v" fill="#0080ff" x="1.2" y="-0.3">v</text>
    <text class="svgtxt" id="vel2g" fill="#ff8000" x="1.0" y="1.4">
      g&#x03c4;</text>
    <text class="svgtxt" id="vel2w" fill="#0080ff" x="3.2" y="-1.1">
      &#x03c9;</text>
  </svg>
  </div>
  <p>At any instant of time, the object is moving tangent to the
    circle, at right angles to the radius vector $r$, indicated by the
    blue vector $v\tau$.  Strictly speaking, any vector we draw in the
    position plane is a displacement vector, with its tail at the
    starting point of the displacement and its head at the final
    point.  Hence, we label the blue vector by the product $v\tau$,
    the product of the speed $v$ and some short time interval $\tau$,
    so that $v\tau$ is the displacement the object would have made if
    it had continued in a straight line at constant speed for that
    short time.</p>
  <p>We can treat the velocity, which is the rate of displacement, as
    a vector in its own right, as opposed to a displacement dependent
    on an arbitrary short time interval $\tau$.  Therefore, we
    introduce a second plane, the velocity plane indicated on the
    right side of the figure.  In this plane, we draw the tail of the
    velocity vector at a fixed point representing zero velocity rather
    than as a displacement from the moving point at the tip of the
    object.  Furthermore, the length of vectors in the velocity plane
    represents the speed an object is moving (rather than its
    position).  Notice that tip of the velocity vector orbits a circle
    in the velocity plane, staying exactly ninety degrees ahead of the
    orbit in the position plane.</p>
  <p>To a large degree, Newtonian mechanics takes place in this
    velocity plane, not in the ordinary position plane.  This is
    because $F=ma$, Newton's second law, associates force with
    acceleration, which is the rate of change of velocity.  Just as
    velocity times a short time interval $v\tau$ is a displacement
    vector in position space, acceleration times time $g\tau$ is a
    displacement in the velocity plane - the change in velocity in
    some short time $\tau$, drawn orange in the figure.  Because the
    acceleration vector stays ninety degrees ahead of the velocity
    vector, which stays ninety degrees ahead of the position vector,
    the acceleration always points directly toward the center of the
    orbital circle.  Here the acceleration will be due to a
    gravitational attraction of the orbiting object toward the center
    of the circle in the position plane, hence we use the symbol $g$
    for acceleration (rather than $a$).</p>
  <p>Let $T$ be the time it takes to complete one orbit.  Since the
    perimeter of the circle is $2\pi r,$ the speed $v$ is $2\pi r/T.$
    Similarly, the perimeter of the velocity orbit in the velocity
    plane is $2\pi v,$ so the acceleration $g$ is $2\pi v/T.$ Now the
    angle between any fixed direction and the radius or velocity
    vector changes at a constant rate, which we call $\omega.$ If we
    use radian units to measure angle, then $\omega = 2\pi/T,$ because
    there are $2\pi$ radians in one complete circle.  Thus, our
    formulas relating orbital radius, speed, and acceleration are
    simply $v=\omega r$ and $g=\omega v.$ In fact, the reason people
    use radians to measure angle instead of degrees is to make these
    important formulas as simple as possible: In radians, velocity is
    just radius times the rate of change of direction (heading angle),
    and acceleration is velocity times the rate of change of
    direction, at least for uniform circular motion.</p>
  <p>Since planets do not move in circular orbits, we need to broaden
    our study to more complicated kinds of motion.  The true shape of
    planetary orbits had been sought by ancient Greek and medieval
    Islamic astronomers before culminating in Kepler's eillipses, but
    it turns out that the position plane is the wrong place to look
    for orbital shapes.  The genius of Newton was to recognize that
    when you look at planetary motion in the velocity plane, it is
    circular after all.  Therefore, we continue this preliminary
    exercise by studying motion with a constant speed, that is, motion
    constrained to a circle in velocity space, rather than constrained
    to a circle in position space.</p>
  <p>As a first step away from uniform circular motion, we turn to an
    object moving at constant speed but with a time varying sideways
    acceleration $g.$ The following figure demonstrates this general
    case of constant speed motion.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -6.0 21 11" onload="fig3_interactions(evt)"
       stroke-width="0.1">
    <path fill="none" stroke="#f0f0f0" stroke-width="0.3"
          d="M 0.0,-4.85 L 0.0,3.7" />
    <path id="posr3" fill="none" stroke="#c0c0c0" d="M -2.5,0.0 L -3.0,0.0" />
    <circle fill="none" stroke="#a0d0ff" cx="5.0" cy="0" r="4.0" />
    <path id="posv3" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -3.0,0.0 l -1.2,0.0" />
    <circle id="dotr3" fill="black" cx="-3.0" cy="0.0" r="0.2" />
    <path id="velc3" fill="none" stroke="#c0c0c0" display="none"
          marker-end="url(#arrowg)" d="M 5.0,0.0 L 1.0,0.0" />
    <path id="velu3" fill="none" stroke="#c0c0c0" display="none"
          marker-end="url(#arrowg)" d="M 5.0,0.0 L 5.0,0.0" />
    <path id="velv3" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,0.0 L 1.0,0.0" />
    <path id="velg3" fill="none" stroke="#ff8000"
          marker-end="url(#arrowo)" d="M 1.0,0.0 l 0.0,0.0001" />
    <path id="velw3" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5" />
    <circle fill="#c0c0c0" cx="5.0" cy="0.0" r="0.2" />
    <circle id="dotc3" class="clickable" fill="#0080ff" stroke="transparent"
            stroke-width="0.3" cx="5.0" cy="0.0" r="0.2" />
    <circle id="dotv3" fill="#0080ff" cx="1.0" cy="0.0" r="0.2" />
    <path fill="none" stroke="#ff8000"
          d="M -4,4.95 L 4,4.95 M -4,4.95 l 0,-0.2 m 2,0.2 l 0,-0.2 m 2,0.3
             l 0,-0.4 m 2,0.3 l 0,-0.2 m 2,0.2 l 0,-0.2"/>
    <path id="press3" class="clickable" fill="#b0b0b0" stroke="#606060"
          stroke-width="0.2" transform="translate(0.0,0)"
          d="M -0.4,4.5 l 0.4,0.4 l 0.4,-0.4 a 0.4,0.4 0 0,0 -0.8,0.0" />
    <text class="svgtxt" x="-6.6" y="-5.0">position</text>
    <text class="svgtxt" fill="#0080ff" x="3.5" y="-5.0">velocity</text>
    <text class="svgtxt" id="vel3v" fill="#0080ff" x="1.6" y="-0.3">v</text>
    <text class="svgtxt" id="vel3g" fill="#ff8000" x="1.4" y="1.4">
      g&#x03c4;</text>
    <text class="svgtxt" id="vel3w" fill="#0080ff" x="3.2" y="-1.1">
      &#x03c9;</text>
  </svg>
  </div>
  <p>Press the button at the bottom to watch the point move at
    constant speed.  Slide the button left or right to deflect its
    course to the left or right - more positive or more negative rate
    of change of direction $\omega.$ Think of the slider as the tiller
    of a boat or the steering wheel of a car.  (In the figure, the
    point will jump to the opposite side if you drive off the visible
    part of the position plane.)  The sideways acceleration $g$ varies
    in proportion to $\omega,$ with $g=\omega v$ as for uniform
    circular motion.  The orange acceleration vector always remains
    perpendicular to the blue velocity vector, which is why the speed
    of the point remains constant while you steer it around.  Hold the
    button at a fixed position and watch the point move in a circle -
    the uniform circular motion we studied before.  Unlike that
    uniform case, a varying angular speed $\omega$ only refers to the
    angular rate of change of the velocity vector, because there is no
    longer a center in the position plane.</p>
  <p>Our second step is to study motion constrained to a velocity
    space circle centered on a non-zero velocity.  In the previous
    figure, you can drag the point at the center of the velocity plane
    away from the center of the circle to any other point you please.
    That new point becomes the origin where velocity is zero.  The
    displaced blue arrow remains the velocity of the point in position
    space, which is now the sum of the two gray velocity vectors.  The
    first is the now non-zero center velocity, running from the origin
    (tail of the blue arrow) to the center of the velocity space
    circle.  The second is a radius vector, with its tail at the
    center and its head at the head of the blue arrow.  The length $v$
    of the gray radius vector remains fixed, and both the length and
    direction of the center vector remain fixed, as the point moves.
    Again, you can animate the motion and control the magnitude of the
    acceleration by holding and sliding the button at the bottom.  The
    center velocity acts like a steady current, making the point
    harder to steer.</p>
  <p>The orange acceleration vector must remain normal to the gray
    radius vector - not to the blue velocity vector - in order to keep
    the blue vector on its circular path.  The magnitude of the
    acceleration is still $g=\omega v$, but now $v$ is the radius of
    the velocity circle, the second gray vector.  The speed of the
    point in position space, which is the length of the blue vector,
    changes depending on which way it is moving relative to the center
    velocity.</p>
  <p>
  </p>




  <hr/>
  <p>The derivation of Kepler's third law leads into a discussion of
    the equation of time.  We usually think of Newton's laws as
    producing a trajectory through space as a function of time.
    However, in the case of planetary orbits, the mathematics works
    backwards: Given a point on its elliptical orbit, we can calculate
    when the planet will reach that position, rather than vice-versa.
    In practice, we can only invert this relationship by an iterative
    approach to find where the planet will be at a given time.</p>





<p>Even more dramatically, from the inverse square law Newton deduces
    that the every day gravity we experience on the surface of the
    earth is the same force that holds the moon in orbit around the
    earth, and hence the planets in orbit around the sun.  Before
    Principia, no one even suspected that the gravity we feel on earth
    is the same force that bends the planets into their paths around
    the sun.</p>


  <h2>Adding and multiplying with graph paper</h2>
  <p>Graph paper provides a coordinate system for the points in a
    plane.  Our unit on the plane is a square instead of a segment;
    one corner goes at an arbitrary origin point, then we tile the
    remainder of the plane into a grid of our unit squares.  Two
    coordinate numbers are associated with each point of the plane,
    the row and column numbers of the point in our grid.  Generally we
    write the coordinates as the pair $(x, y)$, the horizontal number
    followed by the vertical number.  However, here we write $x + iy$,
    although we have not yet defined either the $+$ sign or the symbol
    $i$ that multiplies $y$.  This notation will turn out to be
    consistent with our upcoming definitions of "addition" and
    "multiplication"; until then you may regard $x + iy$ as simply an
    eccentric way to write $(x, y)$.</p>
  <p>By analogy with our definitions in one dimension, we will define
    two dimensional "addition" as changing the origin with a fixed
    unit square, and "multiplication" as changing the unit square with
    a fixed origin.</p>
  <p>To explore this idea, we need two overlapping sheets of graph
    paper which initially overlay each other.  We choose the lower left
    corner of our unit square to be the origin, drawn with a circular
    marker here.  We also need to specify which edge of our unit square
    corresponds to the $x$ axis (our first coordinate); here drawn with
    a square marker.</p>
  <p>To add two points in the plane, we drag the origin of the orange
    sheet to first addend on the blue sheet, then drag the gray diamond
    marker to the second addend on the orange sheet.  Read the sum as the
    position of the gray diamond on the blue sheet.  We've drawn arrows
    corresponding to the first and second addends (blue and orange) and
    to their sum (gray).  Note that you are to read the gray coordinates
    on the blue plane, not on the orange plane.</p>
  <p>Please convince yourself that this definition of "addition"
    of planar coordinate pairs amounts to simply adding each of the
    two components separately:
    $$(a+ib) + (x+iy) = (a+x) + i(b+y).$$
  </p>
</div><div class="textcolumn" style="clear: right; margin-top: 0.3em;">
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg" style="padding-left: 0.5em"
       viewBox="-4.1 -4.1 8.2 8.2" onload="mul2d_interactions(evt)"
       stroke-width="0.03">
    <path fill="none" stroke="#0080ff" opacity="0.33"
      d="M -5,-6 v 12
      m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12
      m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12
      M -6,-5 h 12
      m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12
      m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12"/>
    <path id="mul2t" fill="none" stroke="#ff8000" opacity="0.33"
      stroke-width="0.03" transform="scale(1.00,1.00)"
      d="M -32,-33 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         M -33,-32 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66"/>
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon id="mul2gg" fill="none" stroke="#808080" stroke-width="0.05"
             points="0.0,0.0, 1.8,0.0, 1.8,-0.8, 0.0,-0.8" />
    <polygon id="mul2gb" fill="none" stroke="#0080ff" stroke-width="0.05"
             points="0.0,0.0, 0.0,0.0, 0.0,0.0, 0.0,0.0" />
    <polygon id="mul2go" fill="none" stroke="#ff8000" stroke-width="0.05"
             points="0.0,0.0, 1.8,0.0, 1.8,-0.8, 0.0,-0.8" />
    <polygon id="mul2ul" stroke="#ff8000" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1"/>
    <circle fill="#ff8000" stroke="#ff8000" cx="0" cy="0" r="0.125" />
    <polygon id="mul2ur" fill="#ff8000" stroke="#ff8000"
             transform="matrix(1.0, 0.0, 0.0, 1.0, 1.0, 0.0)"
             points="-0.125,-0.125, 0.125,-0.125, 0.125,0.125, -0.125,0.125" />
    <line id="mul2vb" fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          marker-end="url(#arrow-blue)" x1="0" y1="0" x2="1.0" y2="0.0"/>
    <line id="mul2vec" fill="#808080" stroke="#808080" stroke-width="0.05"
          marker-end="url(#arrow-gray)" x1="0" y1="0" x2="1.8" y2="-0.8"/>
    <polygon id="mul2urx" fill="#ff8000" stroke="#ff8000" opacity="0.0"
             transform="matrix(1.0, 0.0, 0.0, 1.0, 1.0, 0.0)"
             points="-0.125,-0.125, 0.125,-0.125, 0.125,0.125, -0.125,0.125" />
    <polygon id="mul2s" fill="black" stroke="black" opacity="0.5"
      transform="translate(1.8,-0.8)"
      points="-0.1768,0, 0,-0.1768, 0.1768,0, 0,0.1768" />
  </svg>
  <p class="belowsvg">
    (<span id="mul2x" class="" style="color: #0080ff;">1.00 + i0.00</span>)
    &times;
    (<span id="mul2y" class="" style="color: #ff8000;">1.80 + i0.80</span>) =
    <span id="mul2z" class="" style="color: #808080;">1.8000 + i0.8000</span>
  </p>
  </div>
  <p>Multiplication is far more interesting.  We can scale our unit
    square by dragging its lower right corner, the one we marked with
    a square at the point $1+i0$, to the first multiplicand on the
    blue sheet.  Then drag the gray diamond marker to the second
    multiplicand on the orange sheet.  Read the product as the
    position of the gray diamond on the blue sheet.  We've drawn
    arrows as for addition, but this time the orange arrow always
    coincides with the gray arrow, so you only see the gray arrow.
    The orange and gray guideline rectangles from the arrow tip back
    to their respective coordinate axes are more useful for reading
    the orange and blue coordinates, respectively.</p>
</div>
<script>
  var tracking = null;

  function add_trackers(svg, targets, start, track, stop) {
    // svg = svg element
    // targets = array of elements in svg to listen for mouse down events
    // start(index, coords) --> tracking (or null to abort)
    //   index = index into targets
    //   coords = event coordinates in svg coordinate system
    // track(tracking, coords) --> tracking (or null to abort)
    //   tracking = returned by start
    //   coords = event coordinates in svg coordinate system
    // stop(tracking)
    //   tracking = returned by start

    function svgcoords(evt) {  // return event coordinates
      var CTM = svg.getScreenCTM();
      if (evt.touches) {
        evt = evt.touches[0];
      }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    function wrapstart(evt) {
      if (tracking !== null) {
        wrapstop(evt);
      }
      var t = evt.target;
      var index = targets.indexOf(t);
      if (index < 0) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = start(index, svgcoords(evt));
    }

    function wraptrack(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = track(tracking, svgcoords(evt));
    }

    function wrapstop(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      stop(tracking);
      tracking = null;
    }

    svg.addEventListener("mousedown", wrapstart);
    svg.addEventListener("mousemove", wraptrack);
    svg.addEventListener("mouseup", wrapstop);
    svg.addEventListener("mouseleave", wrapstop);
    svg.addEventListener("touchstart", wrapstart);
    svg.addEventListener("touchmove", wraptrack);
    svg.addEventListener("touchend", wrapstop);
    svg.addEventListener("touchcancel", wrapstop);
  }

  function get_element(id) {
    return document.getElementById(id);
  }

  var abs = Math.abs;
  var sqrt = Math.sqrt;

  function fig1_interactions(evt) {
    var fig1 = evt.target;
    var f1handle = ["foco1", "pntq1", "pntn1"].map(get_element);
    var pntcx = f1handle.map(function(e)
                             {return e.getAttributeNodeNS(null, "cx");});
    var pntcy = f1handle.map(function(e)
                             {return e.getAttributeNodeNS(null, "cy");});
    var ellipse = get_element("ell1");
    var ellcx = ellipse.getAttributeNodeNS(null, "cx");
    var ellry = ellipse.getAttributeNodeNS(null, "ry");
    var circs = ["foco1", "pntp1", "pntq1", "pntm1", "pntn1"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var paths = ["sp1", "opq1", "oq1", "pm1", "snq1"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var texts = ["txs1", "txo1", "txp1", "txq1", "txm1",
                 "txn1"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});
    var snqstroke = paths[4].getAttributeNodeNS(null, "stroke");
    var pntnfill = circs[4].getAttributeNodeNS(null, "fill");
    var txtnfill = texts[5].getAttributeNodeNS(null, "fill");
    var a = 5.0;  // fixed - do not change
    var c = 3.0;
    var xq = 0.0;
    var yq = 10.0;
    var xp = 0.0;
    var yp = 3.2;
    var xn = -3.0;
    var yn = 5.0;
    var nhidden = true;

    function nhide(on) {
      if (on) {
        snqstroke.value = pntnfill.value = txtnfill.value = "transparent";
        nhidden = true;
      } else {
        snqstroke.value = pntnfill.value = txtnfill.value = "#ff8000";
        nhidden = false;
      }
    }

    function seto(x) {
      c = -0.5 * x;
      circx[0].value = "" + x;
      textx[1].value = "" + (x - 0.3);
      ellcx.value = "" + (-c);
      ellry.value = "" + sqrt(a*a - c*c);
      setq(xq, yq);
    }

    function setq(qx, qy) {
      var ychange = (yq < 0.) != (qy < 0.);
      xq = qx;  yq = qy;
      xn = 0.5*xq - c;  yn = 0.5*yq;
      qx /= a;  qy /= a;
      var s = (2.*a - qx*c) / (qx*qx + yq*yq/(a*a - c*c));
      xp = s*qx;  yp = s*qy;
      circx[1].value = "" + xp;  circy[1].value = "" + (-yp);
      circx[2].value = "" + xq;  circy[2].value = "" + (-yq);
      circx[3].value = circx[4].value = "" + (0.5*xq - c);
      circy[3].value = circy[4].value = "" + (-0.5*yq);
      pathd[0].value = "M 0.0,0.0 L " + xp + "," + (-yp);
      var mo = "M " + (-2.0*c) + ",0.0 L "
      pathd[1].value = mo + xp + "," + (-yp) + " L " + xq + "," + (-yq);
      pathd[2].value = mo + xq + "," + (-yq);
      // Compute endpoints of PM on circle concentric with ellipse and
      // halfway between ellipse and Q-circle, center (0,-c) radius (3a-c)/2
      var cc = xp + c;
      var xoq = xq + 2.*c;
      var aa = xoq*xoq + yq*yq;
      var bb = yq*cc - xoq*yp;  // -B/2 in quadratic equation
      cc = cc*cc + yp*yp - 0.25*(3.*a - c)**2;
      var dd = bb*bb - aa*cc;
      if (dd < 0.0) {
        dd = 0.0;  // guard against rounding error
      }
      dd = sqrt(dd);
      cc = (bb - dd)/aa;  bb = (bb + dd)/aa;  // two roots or quadratic
      // (xp,yp) + (-yq,xoq)*root are endpoints
      pathd[3].value = ("M " + (xp-yq*bb) + "," + (-yp-xoq*bb) +
                        " L " + (xp-yq*cc) + "," + (-yp-xoq*cc));
      if (ychange) {
        if (yq >= 0.) {
          texty[0].value = texty[1].value = "0.9";
        } else {
          texty[0].value = texty[1].value = "-0.3";
        }
      }
      // compute Q letter position
      var qx = sqrt(xq*xq + yq*yq);
      var qy = yq / qx;
      qx = xq / qx;
      if (yq >= 0.0) {  // xprime=(qy,-qx) and yprime=(qx,qy)
        s = xq + 0.5*qy - 0.5*qx;
        qy = yq - 0.5*qx - 0.5*qy;
        qx = s;
      } else {
        s = xq - 0.5*qy - 0.5*qx;
        qy = yq + 0.5*qx - 0.5*qy;
        qx = s;
      }
      textx[3].value = "" + (qx-0.3);
      texty[3].value = "" + (0.3-qy);
      // compute P letter position
      qx = sqrt((2.*c+xp)**2 + yp**2);
      qy = yp / qx;
      qx = (2.*c+xp) / qx;
      qx = xp + 0.612*qx;
      qy = yp + 0.612*qy;
      textx[2].value = "" + (qx-0.25);
      texty[2].value = "" + (0.3-qy);
      // compute M letter position
      qx = 0.5*xq - c;
      qy = 0.5*yq;
      if (yq >= 0.0) {
        textx[4].value = "" + (qx-0.4);
        texty[4].value = "" + (-0.4-qy);
      } else {
        textx[4].value = "" + (qx-0.4);
        texty[4].value = "" + (1.0-qy);
      }
    }

    function setn(x, y) {
      xn = x;  yn = y;
      // d="M 0.0,0.0 L -3.0,-5.0 L 0.0,-10.0 M -6.0,0.0 L -3.0 -5.0"
      circx[4].value = "" + xn;
      circy[4].value = "" + (-yn);
      pathd[4].value = ("M 0.0,0.0 L " + xn + "," + (-yn) +
                        " L " + xq + "," + (-yq) +
                        " M " + (-2.*c) + ",0.0 L " + xn + "," + (-yn));
      // compute N letter position
      if (yq >= 0.0) {
        textx[5].value = "" + (xn-0.4);
        texty[5].value = "" + (-0.4-yn);
      } else {
        textx[5].value = "" + (xn-0.4);
        texty[5].value = "" + (1.0-yn);
      }
    }

    function fullreset() {
      xq = 0.0;  yq = 10.0;
      seto(-6.0);
    }

    function start(index, coords) {
      var dx = coords.x;
      var dy = coords.y;
      if (index === 0) {  // point O
        dx = -2.*c - dx;
        xn = 0.5*xq - c;
        yn = 0.5*yq;
        setn(0.5*xq - c, 0.5*yq);
        nhide(true);
      } else if (index === 1) {  // point Q
        dx = xq - dx;
        dy = yq + dy;
        setn(0.5*xq - c, 0.5*yq);
        nhide(true);
      } else {  // point N
        if (nhidden) {  // use point M coordinates
          xn = 0.5*xq - c;
          yn = 0.5*yq;
        }
        dx = xn - dx;
        dy = yn + dy;
        setn(xn, yn);
      }
      return [index, dx, dy];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var x = coords.x + tracking[1];
      var y = tracking[2] - coords.y;
      var twoa = a + a;
      var r;
      if (index === 0) {  // point O
        if (x > 0.2 || x < 0.4 - twoa) {
          fullreset();
          return null;
        }
        if (x > 0.0) {
          x = 0.0;
        }
        seto(x);
      } else if (index === 1) {  // point Q
        r = sqrt(x*x + y*y);
        if (r > 0.1) {
          x = twoa * x / r;
          y = twoa * y / r;
        }
        setq(x, y);
      } else {  // point N
        // project (x, y) onto the line PM, (-yoq, xoq)
        var xoq = xq + 2.*c;
        var r = sqrt(xoq*xoq + yq*yq);
        var yoq = yq / r;
        xoq /= r;
        r = (y-yp)*xoq - (x-xp)*yoq;
        x = xp - r*yoq;  y = yp + r*xoq;  // (x, y) now on line PM
        r = sqrt((x + c)**2 + y**2);
        if (r > 0.5*(3.*a - c)) {
          return null;
        }
        var xm = 0.5*xq - c;
        var ym = 0.5*yq;
        if ((x-xm)**2 + (y-ym)**2 > 0.25) {  // N has moved off M
          nhide(false);
        } else {
          nhide(true);
        }
        setn(x, y);
      }
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        if (tracking[0] === 2 && nhidden) {
          xn = 0.5*xq - c;
          yn = 0.5*yq;
        }
      }
      return;
    }

    add_trackers(fig1, f1handle, start, track, stop);
  }

  function fig2_interactions(evt) {
    var fig2 = evt.target;
    var f2handle = ["press2"].map(get_element);
    var paths = ["posr2", "velv2", "posv2",
                 "velg2", "posw2", "velw2"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var circs = ["dotr2", "dotv2"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var texts = ["pos2r", "vel2v", "pos2v",
                 "vel2g", "pos2w", "vel2w"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});

    var center = 5.0;
    var radius = 4.4;
    var dscale = 1.7 / radius;
    var xnow = 0.0;
    var ynow = radius;
    var dth = 0.04;  // step multiplies by (1, dth), normalized

    function redraw(x, y) {
      var flip = (x <= 0) !== (xnow <= 0);
      xnow = x;
      ynow = y;
      circx[0].value = "" + (x - center);
      circy[0].value = "" + (-y);
      circx[1].value = "" + (center - y);
      circy[1].value = "" + (-x);
      pathd[0].value = "M -5.0,0.0 L " + (x - center) + "," + (-y);
      pathd[1].value = "M 5.0,0.0 L " + (center - y) + "," + (-x);
      pathd[2].value = ("M " + (x - center) + "," + (-y) + " l " +
                        (-dscale*y) + "," + (-dscale*x));
      pathd[3].value = ("M " + (center - y) + "," + (-x) + " l " +
                        (-dscale*x) + "," + (dscale*y));
      // pos2r  x="-4.8" y="-3.2"  (+0.2, 3.2)  relative to (-5,0)
      // pos2v  x="-6.4" y="-3.5"  (-1.4, 3.5)  relative to (-5,0)
      var yx = x / radius;
      var yy = y / radius;
      var xx = yy;
      var xy = -yx;
      textx[0].value = "" + (0.4*xx + 3.45*yx - 0.2 - 5.0);
      texty[0].value = "" + (-0.4*xy - 3.45*yy + 0.25);
      textx[2].value = "" + (-0.98*xx + 3.75*yx - 0.42 - 5.0);
      texty[2].value = "" + (0.98*xy - 3.75*yy + 0.25);
      // vel2v  x="1.2" y="-0.3"  (-3.8, 0.3)   relative to (5,0)
      // vel2g  x="1.0" y="1.4"   (-4.0, -1.4)  relative to (5,0)
      textx[1].value = "" + (-3.6*xx + 0.55*yx - 0.2 + 5.0);
      texty[1].value = "" + (3.6*xy - 0.55*yy + 0.25);
      textx[3].value = "" + (-3.58*xx - 1.25*yx - 0.42 + 5.0);
      texty[3].value = "" + (3.58*xy + 1.25*yy + 0.15);
      if (flip) {
        if (x > 0) {
          pathd[4].value = "M -6.5,0.0 a 1.5,1.5 0 0,0 1.5,1.5";
          pathd[5].value = "M 5.0,1.5 a 1.5,1.5 0 0,0 1.5,-1.5";
          textx[4].value = "-6.8";
          texty[4].value = "1.5";
          textx[5].value = "6.3";
          texty[5].value = "1.4";
        } else {
          pathd[4].value = "M -3.5,0.0 a 1.5,1.5 0 0,0 -1.5,-1.5";
          pathd[5].value = "M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5";
          textx[4].value = "-4.0";
          texty[4].value = "-1.2";
          textx[5].value = "3.2";
          texty[5].value = "-1.1";
        }
      }
    }

    function stepper() {
      var x = xnow - ynow*dth;
      var y = ynow + xnow*dth;
      var r = radius / sqrt(x*x + y*y);
      redraw(x*r, y*r)
    }

    function start(index, coords) {
      var interval_timer = null;
      if (index === 0) {
        interval_timer = setInterval(stepper, 20);  // 50 frames/sec
      }
      return [index, interval_timer];
    }

    function track(tracking, coords) {
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        if (tracking[1] !== null) {
          if (abs(xnow) < 0.5 && ynow > 0.0) {
            xnow = 0.0001;
            ynow = radius;
            redraw(0.0, radius);
          }
          clearInterval(tracking[1]);
        }
      }
      return;
    }

    add_trackers(fig2, f2handle, start, track, stop);
  }

  // spanel.innerHTML = x.toFixed(ndig) + sgn + y.toFixed(ndig);

  function fig3_interactions(evt) {
    var fig3 = evt.target;
    var f3handle = ["press3", "dotc3"].map(get_element);
    var xform = f3handle[0].getAttributeNodeNS(null, "transform");
    var paths = ["posr3", "velv3", "posv3", "velg3", "velw3",
                 "velc3", "velu3"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var cdisplay = paths.slice(5).map(
      function(e) {return e.getAttributeNodeNS(null, "display");});
    var circs = ["dotr3", "dotv3", "dotc3"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var texts = ["vel3v", "vel3g", "vel3w"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});
    var vfill = texts[0].getAttributeNodeNS(null, "fill");
    var wfill = texts[2].getAttributeNodeNS(null, "fill");
    var wstro = paths[4].getAttributeNodeNS(null, "stroke");
    var wmark = paths[4].getAttributeNodeNS(null, "marker-end");

    var center = 5.0;
    var speed = 4.0;
    var gscale = 0.2;
    var gnow = 0.0;
    var vx = -4.0;
    var vy = 0.0;
    var v0x = 0.0;
    var v0y = 0.0;
    var xnow = -3.0;
    var ynow = 0.0
    var dtg = 0.01;  // timestep in velocity plane
    var dtv = 0.012;  // timestep in position plane
    var npts = 1;
    var trail = "M -2.5,0.0 L -3.0,0.0";
    var vscale = 1.2 / speed;
    var wrapped = false;
    var wupper = true;
    var vflip = false;

    function redraw() {
      circx[0].value = "" + xnow;
      circy[0].value = "" + (-ynow);
      circx[1].value = "" + (center + vx);
      circy[1].value = "" + (-vy);
      circx[2].value = "" + (center - v0x);
      circy[2].value = "" + v0y;
      npts += 1;
      if (npts > 400) {  // remove one point at head of trail after 8 sec
        trail = trail.replace(/M[^L]*L/, "M");
      }
      trail += (wrapped? " M " : " L ") + xnow + "," + (-ynow);
      pathd[0].value = trail;
      pathd[1].value = ("M " + (center - v0x) + "," + v0y +
                        " L " + (center + vx) + "," + (-vy));
      pathd[2].value = ("M " + xnow + "," + (-ynow) + " l " +
                        (vscale*(v0x+vx)) + "," + (-vscale*(v0y+vy)));
      var g = gnow * gscale;
      if (g === 0) {
        g = 0.0001;
      }
      pathd[3].value = ("M " + (center + vx) + "," + (-vy) + " l " +
                        (-g*vy) + "," + (-g*vx));
      if (v0x !== 0.0 || v0y !== 0.0) {
        pathd[5].value = ("M " + center + ",0.0" +
                          " L " + (center + vx) + "," + (-vy));
        pathd[6].value = ("M " + (center - v0x) + "," + v0y +
                          " L " + center + ",0.0");
        cdisplay[0].value = cdisplay[1].value = "block";
        vfill.value = wfill.value = wstro.value = "#c0c0c0";
        wmark.value = "url(#arrowg)";
      } else {
        cdisplay[0].value = cdisplay[1].value = "none";
        vfill.value = wfill.value = wstro.value = "#0080ff";
        wmark.value = "url(#arrowb)";
      }
      var xx = -vx / speed;
      var xy = -vy / speed;
      var yx = -xy;
      var yy = xx;
      // vel3v  x="1.6" y="-0.3"  (-3.4, 0.3)   relative to (5,0)
      // vel3g  x="1.4" y="1.4"   (-3.6, -1.4)  relative to (5,0)
      tsign = (gnow >= 0.0)? 1.0 : -1.0;
      textx[0].value = "" + (-3.2*xx + tsign*0.55*yx - 0.2 + 5.0);
      texty[0].value = "" + (3.2*xy - tsign*0.55*yy + 0.25);
      textx[1].value = "" + (-3.18*xx - tsign*1.25*yx - 0.42 + 5.0);
      texty[1].value = "" + (3.18*xy + tsign*1.25*yy + 0.15);
      if (vflip) {
        if ((vx<0)? vy > 0 : vy >= 0) {
          pathd[4].value = "M 5.0,1.5 a 1.5,1.5 0 0,0 1.5,-1.5";
          textx[2].value = "6.3";
          texty[2].value = "1.4";
          wupper = false;
        } else {
          pathd[4].value = "M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5";
          textx[2].value = "3.2";
          texty[2].value = "-1.1";
          wupper = true;
        }
      }
    }

    function stepper() {
      var g = gnow * dtg;
      var vvx = vx - vy*g;
      var vvy = vy + vx*g;
      var v = speed / sqrt(vvx**2 + vvy**2);
      vvx *= v;
      vvy *= v;
      xnow += (v0x + 0.5*(vx + vvx))*dtv;
      ynow += (v0y + 0.5*(vy + vvy))*dtv;
      wrapped = false;
      if (xnow < -10.0) {
        xnow = -0.5;
        wrapped = true;
      } else if (xnow > -0.5) {
        xnow = -10.0;
        wrapped = true;
      }
      if (ynow < -4.4) {
        ynow = 4.6;
        wrapped = true;
      } else if (ynow > 4.6) {
        ynow = -4.4;
        wrapped = true;
      }
      vflip = (vy*vvy <= 0.0);
      vx = vvx;
      vy = vvy;
      redraw();
    }

    function start(index, coords) {
      var interval_timer;
      if (index === 0) {
        interval_timer = setInterval(stepper, 20);  // 50 frames/sec
        return [index, interval_timer, -gnow-coords.x];
      } else if (index === 1) {
        vx = -4.0;
        xnow = -3.0;
        vy = ynow = gnow = 0.0;
        xform.value = "translate(0.0,0)";
        var v = v0x*v0x + v0y*v0y;
        if (v < 0.04) {
          v = 1.0;
          v0x = v0y = 0.0;
        }
        v = sqrt((v0x+vx)**2 + v0y**2);
        if (v === 0.0) {
          v = 1.0;
        }
        trail = "M "+(xnow-0.5*(v0x+vx)/v)+","+(0.5*v0y/v)+" L -3.0,0.0";
        npts = 1;
        wrapped = false;
        vflip = true;  // forces redraw to set wupper
        redraw();
        vflip = false;
        return [index, -v0x-coords.x, v0y-coords.y];
      }
      return [index, null, null];
    }

    function track(tracking, coords) {
      if (tracking === null || tracking[1] === null) {
        return null;
      }
      if (tracking[0] === 0) {
        var g = -(coords.x + tracking[2]);
        if (coords.y < 3.0) {
          clearInterval(tracking[1]);
          return null;
        }
        if (abs(g) > 4.0) {
          g *= 4.0 / abs(g);
        } if (abs(g) < 0.2) {
          g = 0.0;
        }
        gnow = g;
        xform.value = "translate(" + (-gnow) + ",0)";
      } else {
        v0x = -(coords.x + tracking[1]);
        v0y = coords.y + tracking[2];
        if (abs(v0x) >= 4.0 || abs(v0y) >= 4.0) {
          tracking = null;
        }
        if (tracking === null || v0x*v0x + v0y*v0y < 0.09) {
          v0x = v0y = 0.0;
        }
        var v = sqrt((v0x+vx)**2 + v0y**2);
        if (v === 0.0) {
          v = 1.0;
        }
        trail = "M "+(xnow-0.5*(v0x+vx)/v)+","+(0.5*v0y/v)+" L -3.0,0.0";
        redraw();
      }
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null && tracking[0] === 0 && tracking[1] !== null) {
        clearInterval(tracking[1]);
      }
      return;
    }

    add_trackers(fig3, f3handle, start, track, stop);
  }

  function mul2d_interactions(evt) {
    var mul2d = evt.target;
    var m2handle = ["mul2urx", "mul2s"].map(get_element);
    var xyz = ["mul2x", "mul2y", "mul2z"].map(get_element);
    var cl_xyz = xyz.map(function(e)
                         {return e.getAttributeNodeNS(null, "class");});
    var xf_tick = get_element("mul2t").getAttributeNodeNS(null, "transform");
    var xf_slid = m2handle[1].getAttributeNodeNS(null, "transform");
    var xnow = [1.0, 0.0];
    var ynow = [1.8, -0.8];
    var xyul = get_element("mul2ul").getAttributeNodeNS(null, "points");
    var xfur = get_element("mul2ur").getAttributeNodeNS(null, "transform");
    var xfurx = m2handle[0].getAttributeNodeNS(null, "transform");
    var twidth = get_element("mul2t").getAttributeNodeNS(null, "stroke-width");
    var mul2gg = get_element("mul2gg").getAttributeNodeNS(null, "points");
    var mul2gb = get_element("mul2gb").getAttributeNodeNS(null, "points");
    var mul2go = get_element("mul2go").getAttributeNodeNS(null, "points");
    var vec = get_element("mul2vec");
    vec = [[vec.getAttributeNodeNS(null, "x2")],
           [vec.getAttributeNodeNS(null, "y2")],
           [vec.getAttributeNodeNS(null, "marker-end")]];
    var vbx2 = get_element("mul2vb");
    var vby2 = vbx2.getAttributeNodeNS(null, "y2");
    vbx2 = vbx2.getAttributeNodeNS(null, "x2");

    function start(index, coords) {
      cl_xyz[index].value = "backlit";
      var znow = [xnow[0]*ynow[0] - xnow[1]*ynow[1],
                  xnow[0]*ynow[1] + xnow[1]*ynow[0]];
      var dx = coords.x - (index? znow[0] : xnow[0]);
      var dy = coords.y - (index? znow[1] : xnow[1]);
      return [index, [dx, dy], znow];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var xy = tracking[1];
      var x = coords.x - xy[0];
      var y = coords.y - xy[1];
      var z = tracking[2];
      if (x > 3.8 || x < -3.8) {
        cl_xyz[index].value = "";
        index = 0;
        xnow = [1.0, 0.0];
        ynow = [1.8, -0.8];
        z = ynow;
        x = 1.0;
        y = 0.0;
        tracking = null;
      }
      if (y > 3.8 || y < -3.8) {
        cl_xyz[index].value = "";
        index = 0;
        xnow = [1.0, 0.0];
        ynow = [1.8, -0.8];
        z = ynow;
        x = 1.0;
        y = 0.0;
        tracking = null;
      }
      if (index === 0) {
        if (x*x + y*y < 0.05) {
          x = 0.05;
          y = 0.0;
        } else {
          x = round(20.*x) * 0.05;
          y = round(20.*y) * 0.05;
        }
        var r = x*x + y*y;
        var rx = x / r;
        var ry = -y / r;  // rx + i*ry = 1 / (x + i*y)
        r = sqrt(r);
        xf_tick.value = "matrix("+x+","+y+","+(-y)+","+x+",0.0,0.0)";
        twidth.value = "" + (0.03 / r);
        var zox = [rx*z[0] - ry*z[1], rx*z[1] + ry*z[0]];
        ynow = [round(20.*zox[0]) * 0.05, round(20.*zox[1]) * 0.05];
        xnow = [x, y];
        // orange unit square is (0,0), xnow, xnow+perp, perp
        var perp = [xnow[1], -xnow[0]];  // remember +y is downward
        xyul.value = ("0.0,0.0, " + xnow[0] + "," + xnow[1] + ", " +
                      (xnow[0]+perp[0]) + "," + (xnow[1]+perp[1]) + ", " +
                      perp[0] + "," + perp[1]);
        mul2gb.value = "0,0, " + x+",0, " + x+","+y + ", 0,"+y;
        x /= r;
        y /= r;
        xfur.value = xfurx.value = (
          "matrix(" + x + "," + y + "," + (-y) + "," + x + "," +
            xnow[0] + "," + xnow[1] + ")");
        vbx2.value = xnow[0];
        vby2.value = xnow[1];
        str_complex(xyz[0], 2, xnow, null);
      } else {
        // in mul1d:   ynow = round(20.*(x / xnow)) * 0.05;
        var rr2 = 20. / (xnow[0]*xnow[0] + xnow[1]*xnow[1]);
        ynow = [round(rr2*(x*xnow[0]+y*xnow[1])) * 0.05,
                round(rr2*(y*xnow[0]-x*xnow[1])) * 0.05];
      }
      var znow = [xnow[0]*ynow[0] - xnow[1]*ynow[1],
                  xnow[0]*ynow[1] + xnow[1]*ynow[0]];
      xf_slid.value = "translate(" + znow[0] + "," + znow[1] + ")";
      mul2gg.value = ("0,0, " + znow[0]+",0, " + znow[0]+","+znow[1] +
                      ", 0,"+znow[1]);
      mul2go.value = ("0,0, " + (xnow[0]*ynow[0])+","+(xnow[1]*ynow[0]) +
                      ", " + znow[0]+","+znow[1]+", " +
                      (-xnow[1]*ynow[1])+","+(xnow[0]*ynow[1]));
      setvector(vec, 0, znow, "gray", null);
      str_complex(xyz[1], 2, ynow, null);
      str_complex(xyz[2], 4, znow, null);
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        cl_xyz[tracking[0]].value = "";
      }
      return;
    }

    add_trackers(mul2d, m2handle, start, track, stop);
  }
</script>
</body>
</html>
