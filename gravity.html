<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>The Geometry of Planetary Orbits</title>
  <meta name="description"
    content="A derivation of Kepler's laws from Newton's inverse square law
             using as little algebra as possible.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>MathJax = {tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
          id="MathJax-script">
  </script>
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
      float: right;
    }
    .thirdwide {
      width: 40%;
      float: right;
    }
    .clickable {
      cursor: pointer;
    }
    .backlit {
      background-color: #d8d8d8;
    }
    svg {
      background-color: #ffffff;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .belowsvg {
      font: italic bold large serif;
      padding-top: 0px;
      margin-top: 0px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .svgtxt {
        font: bold 0.8px sans-serif;
        pointer-events: none;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
      .thirdwide {
        width: 55%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;">
    <a href="index.html">The Geometry of Planetary Orbits</a></h1>


  <h2>Introduction</h2>

  <p>In 1687 Isaac Newton published "Philosophiae Naturalis Principia
    Mathematica," arguably the most influential science book ever
    written.  In addition to providing the framework still used for
    all of mechanics, the Principia introduces Newton's theory of
    universal gravitation, which posits an attractive force between
    all masses varying inversely as the square of their distance.  A
    centerpiece of Principia is Newton's demonstration that Kepler's
    three laws of planetary motion are mathematically equivalent to
    his radically simpler inverse square central force law.  This is
    an exceptionally difficult math problem, even for students who can
    bring all the developments of calculus in the intervening 350
    years to bear on it.  But every math problem has many solutions,
    and along one narrow path through the logic of this problem, each
    individual step makes no demands beyond the most elementary plane
    geometry and algebra.  Here we go.</p>
  <p>Kepler's three laws are: First, each planet orbits the sun in an
    ellipse with the sun at one focus.  Second, the planet moves
    around its ellipse so that the radius drawn from the sun to the
    planet sweeps out equal areas in equal times.  Third, the ratio of
    the cube of the semi-major axis of the orbital ellipse to the
    square of the time for a complete orbit is the same for every
    planet.  We aim to show that if a planet begins from any point in
    the solar system and moving with any velocity, and thereafter is
    attracted to the sun by a force varying inversely as the square of
    its distance from the sun, it will orbit forever according to
    Kepler's laws.  (We assume our planet is subject to no other
    forces.)</p>
  <p>Our elementary path leads through three waypoints, which you may
    visit in any order: The first is to master the geometry of the
    focus points and tangent lines of an ellipse, in order to
    comprehend what Kepler is talking about.  The second preliminary
    topic is circular motion, introducing the concept of velocity
    space.  We must extend this study to the velocity space analog of
    circular motion, which is motion at a constant speed.  The third
    preliminary is to demonstrate that all central force laws, whether
    an inverse square law or any other, cause motions obeying Kepler's
    equal area law.  Note that our third preliminary step actually
    achieves a part of our final goal.  With these three preliminaries
    fresh in our minds, the fact that an inverse square law orbit will
    be a Keplerian ellipse follows fairly easily.  Kepler's third law,
    involving cubes and squares, requires several final algebraic
    steps to complete the demonstration.</p>


  <h2>Ellipse Focus and Tangent Geometry</h2>

  <p>Kepler's first law says that a planet P moves around the sun S in
    an ellipse with the sun at one focus; this figure explains what
    that means.  A circle is the set of all points a given distance
    from a center.  An ellipse is the set of all points P with a given
    sum of distances from two focus points S and O.  You can imagine
    connecting pins at S and O by a string of length SP+PO, which you
    stretch taught by a pencil at P.  By keeping the string taught,
    you can move the pencil along the ellipse.  Instead of a single
    center, an ellipse has two focus points, S and O.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -10.5 21 21" onload="fig1_interactions(evt)"
       stroke-width="0.1">
    <path id="sp1" fill="none" stroke="black" d="M 0.0,0.0 L 0.0,-3.2" />
    <path id="opq1" fill="none" stroke="#0080ff"
          d="M -6.0,0.0 L 0.0,-3.2 L 0.0,-10.0" />
    <path id="oq1" fill="none" stroke="#c0c0c0" d="M -6.0,0.0 L 0.0,-10.0" />
    <path id="pm1" fill="none" stroke="#c0c0c0"
          d="M -4.3933,-5.8360 L 2.8051,-1.5170" />
    <circle fill="none" stroke="#c0c0c0" cx="0" cy="0" r="10.0" />
    <ellipse id="ell1" fill="none" stroke="black" stroke-width="0.13"
             cx="-3.0" cy="0" rx="5.0" ry="4.0" />
    <circle fill="black" cx="0" cy="0" r="0.2" />
    <circle id="pntp1" fill="black" cx="0" cy="-3.2" r="0.2" />
    <circle id="pntm1" fill="black" cx="-3" cy="-5" r="0.2" />
    <path id="snq1" fill="none" stroke="transparent"
          d="M 0.0,0.0 L -3.0,-5.0 L 0.0,-10.0 M -6.0,0.0 L -3.0 -5.0" />
    <circle id="pntn1" class="clickable" fill="transparent" stroke="transparent"
            stroke-width="0.3" cx="-3" cy="-5" r="0.2" />
    <circle id="foco1" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="-6.0" cy="0" r="0.2" />
    <circle id="pntq1" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="0" cy="-10.0" r="0.2" />
    <text class="svgtxt" id="txs1" x="-0.3" y="0.9">S</text>
    <text class="svgtxt" id="txo1" x="-6.3" y="0.9">O</text>
    <text class="svgtxt" id="txp1" x="0.29" y="-3.188">P</text>
    <text class="svgtxt" id="txq1" x="0.2" y="-9.2">Q</text>
    <text class="svgtxt" id="txm1" x="-3.4" y="-5.4">M</text>
    <text class="svgtxt" id="txn1" fill="transparent" x="-3.5" y="-5.4">N</text>
  </svg>
  </div>
  <p>If we extend the sun-planet line SP to point Q such that the blue
    segments OP and PQ in the figure are equal, something interesting
    happens: Since SP+OP is the same for any point P on the ellipse,
    SP+PQ is also fixed, independent of P.  Therefore, the point Q
    traces a circle with center S as P moves around the ellipse; the
    radius of this circle is the length of the string SP+PO.</p>
  <p>Next, consider the midpoint M of the segment OQ.  Since by our
    construction of Q, P is also equidistant from O and Q, the line PM
    is the perpendicular bisector of OQ, the set of all points
    equidistant from O and Q.  The line PM appears to be tangent to
    the ellipse at P, that is PM just touches the ellipse at P without
    crossing inside.  To prove this tangency, note that the sum of the
    distances from S and O is less than SP+PO inside the ellipse, and
    greater than SP+PO outside the ellipse.  For every point N on PM,
    the sum SN+NO is equal to the sum SN+NQ, which is always greater
    than SP+PQ for any N except P, because SPQ is a straight line -
    the shortest distance between S and Q.</p>
  <p>The figure is interactive.  You can drag the point O to see how the
    shape of the ellipse depends on the distance from O to S (at fixed
    string length SQ).  Notice that when O coincides with S, the ellipse
    becomes a circle.  You can drag the point Q to watch what happens as
    P moves around the ellipse.  Finally, you can drag the point M along
    PM to create a point N, to help you visualize the proof that SN+NQ
    is always greater than SPQ, so that line PM is entirely outside the
    ellipse, touching it only at point P.</p>


  <h2>Circular and Constant Speed Motion</h2>

  <p>Consider an object moving at a constant speed around a circle, as
    depicted in the next figure.  We introduce the concept of vectors
    - quantities with both magnitude and direction which we represent
    as arrows in diagrams.  The most basic vector is position measured
    from a given point.  The black vector on the left side of the
    figure goes from the center of the circle to the orbiting object;
    its magnitude $r$ is the radius of the circular orbit.  You can
    press and hold the button at the bottom of the figure to animate
    this motion.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -6.0 21 11" onload="fig2_interactions(evt)"
       stroke-width="0.1">
    <defs>
      <marker id="arrowk" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="black" stroke="black" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowg" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#c0c0c0" stroke="#c0c0c0" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowb" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#0080ff" stroke="#0080ff" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowo" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#ff8000" stroke="#ff8000" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
    </defs>
    <path fill="none" stroke="#f0f0f0" stroke-width="0.3"
          d="M 0.0,-4.85 L 0.0,3.7" />
    <circle fill="none" stroke="#c0c0c0" cx="-5.0" cy="0" r="4.4" />
    <circle fill="none" stroke="#a0d0ff" cx="5.0" cy="0" r="4.4" />
    <path id="posr2" fill="none" stroke="black" marker-end="url(#arrowk)"
          d="M -5.0,0.0 L -5.0,-4.4" />
    <path id="posv2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -5.0,-4.4 l -1.7,0.0" />
    <path id="posw2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -3.5,0.0 a 1.5,1.5 0 0,0 -1.5,-1.5" />
    <circle fill="black" cx="-5.0" cy="0.0" r="0.2" />
    <circle id="dotr2" fill="black" cx="-5.0" cy="-4.4" r="0.2" />
    <path id="velv2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,0.0 L 0.6,0.0" />
    <path id="velg2" fill="none" stroke="#ff8000" marker-end="url(#arrowo)"
          d="M 0.6,0.0 l 0.0,1.7" />
    <path id="velw2" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5" />
    <circle fill="#0080ff" cx="5.0" cy="0.0" r="0.2" />
    <circle id="dotv2" fill="#0080ff" cx="0.6" cy="0.0" r="0.2" />
    <circle id="press2" class="clickable" fill="#b0b0b0" stroke="#606060"
            stroke-width="0.2" cx="0.0" cy="4.5" r="0.4" />
    <text class="svgtxt" x="-6.6" y="-5.0">position</text>
    <text class="svgtxt" fill="#0080ff" x="3.5" y="-5.0">velocity</text>
    <text class="svgtxt" id="pos2r" fill="black" x="-4.8" y="-3.2">r</text>
    <text class="svgtxt" id="pos2v" fill="#0080ff" x="-6.4" y="-3.5">
      v&#x03c4;</text>
    <text class="svgtxt" id="pos2w" fill="#0080ff" x="-4.0" y="-1.2">
      &#x03c9;</text>
    <text class="svgtxt" id="vel2v" fill="#0080ff" x="1.2" y="-0.3">v</text>
    <text class="svgtxt" id="vel2g" fill="#ff8000" x="1.0" y="1.4">
      g&#x03c4;</text>
    <text class="svgtxt" id="vel2w" fill="#0080ff" x="3.2" y="-1.1">
      &#x03c9;</text>
  </svg>
  </div>
  <p>At any instant of time, the object is moving tangent to the
    circle, at right angles to the radius vector $r$, indicated by the
    blue vector $v\tau$.  Strictly speaking, any vector we draw in the
    position plane is a displacement vector, with its tail at the
    starting point of the displacement and its head at the final
    point.  Hence, we label the blue vector by the product $v\tau$,
    the product of the speed $v$ and some short time interval $\tau$,
    so that $v\tau$ is the displacement the object would have made if
    it had continued in a straight line at constant speed for that
    short time.</p>
  <p>We can treat the velocity, which is the rate of displacement, as
    a vector in its own right, as opposed to a displacement dependent
    on an arbitrary short time interval $\tau$.  Therefore, we
    introduce a second plane, the velocity plane indicated on the
    right side of the figure.  In this plane, we draw the tail of the
    velocity vector at a fixed point representing zero velocity rather
    than as a displacement from the moving point at the tip of the
    object.  Furthermore, the length of vectors in the velocity plane
    represents the speed an object is moving (rather than its
    position).  Notice that tip of the velocity vector orbits a circle
    in the velocity plane, staying exactly ninety degrees ahead of the
    orbit in the position plane.</p>
  <p>To a large degree, Newtonian mechanics takes place in this
    velocity plane, not in the ordinary position plane.  This is
    because $F=ma$, Newton's second law, associates force with
    acceleration, which is the rate of change of velocity.  Just as
    velocity times a short time interval $v\tau$ is a displacement
    vector in position space, acceleration times time $g\tau$ is a
    displacement in the velocity plane - the change in velocity in
    some short time $\tau$, drawn orange in the figure.  Because the
    acceleration vector stays ninety degrees ahead of the velocity
    vector, which stays ninety degrees ahead of the position vector,
    the acceleration always points directly toward the center of the
    orbital circle.  Here the acceleration will be due to a
    gravitational attraction of the orbiting object toward the center
    of the circle in the position plane, hence we use the symbol $g$
    for acceleration (rather than $a$).</p>
  <p>Let $T$ be the time it takes to complete one orbit.  Since the
    perimeter of the circle is $2\pi r,$ the speed $v$ is $2\pi r/T.$
    Similarly, the perimeter of the velocity orbit in the velocity
    plane is $2\pi v,$ so the acceleration $g$ is $2\pi v/T.$ Now the
    angle between any fixed direction and the radius or velocity
    vector changes at a constant rate, which we call $\omega.$ If we
    use radian units to measure angle, then $\omega = 2\pi/T,$ because
    there are $2\pi$ radians in one complete circle.  Thus, our
    formulas relating orbital radius, speed, and acceleration are
    simply $v=\omega r$ and $g=\omega v.$ In fact, the reason people
    use radians to measure angle instead of degrees is to make these
    important formulas as simple as possible: In radians, velocity is
    just radius times the rate of change of direction (heading angle),
    and acceleration is velocity times the rate of change of
    direction, at least for uniform circular motion.</p>
  <p>Since planets do not move in circular orbits, we need to broaden
    our study to more complicated kinds of motion.  The true shape of
    planetary orbits had been sought by ancient Greek and medieval
    Islamic astronomers before culminating in Kepler's eillipses, but
    it turns out that the position plane is the wrong place to look
    for orbital shapes.  The genius of Newton was to recognize that
    when you look at planetary motion in the velocity plane, it is
    circular after all.  Therefore, we continue this preliminary
    exercise by studying motion with a constant speed, that is, motion
    constrained to a circle in velocity space, rather than constrained
    to a circle in position space.</p>
  <p>As a first step away from uniform circular motion, we turn to an
    object moving at constant speed but with a time varying sideways
    acceleration $g.$ The following figure demonstrates this general
    case of constant speed motion.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -6.0 21 11" onload="fig3_interactions(evt)"
       stroke-width="0.1">
    <path fill="none" stroke="#f0f0f0" stroke-width="0.3"
          d="M 0.0,-4.85 L 0.0,3.7" />
    <path id="posr3" fill="none" stroke="#c0c0c0" d="M -2.5,0.0 L -3.0,0.0" />
    <circle fill="none" stroke="#a0d0ff" cx="5.0" cy="0" r="4.0" />
    <path id="posv3" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -3.0,0.0 l -1.2,0.0" />
    <circle id="dotr3" fill="black" cx="-3.0" cy="0.0" r="0.2" />
    <path id="velc3" fill="none" stroke="#c0c0c0" display="none"
          marker-end="url(#arrowg)" d="M 5.0,0.0 L 1.0,0.0" />
    <path id="velu3" fill="none" stroke="#c0c0c0" display="none"
          marker-end="url(#arrowg)" d="M 5.0,0.0 L 5.0,0.0" />
    <path id="velv3" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,0.0 L 1.0,0.0" />
    <path id="velg3" fill="none" stroke="#ff8000"
          marker-end="url(#arrowo)" d="M 1.0,0.0 l 0.0,0.0001" />
    <path id="velw3" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5" />
    <circle fill="#c0c0c0" cx="5.0" cy="0.0" r="0.2" />
    <circle id="dotc3" class="clickable" fill="#0080ff" stroke="transparent"
            stroke-width="0.3" cx="5.0" cy="0.0" r="0.2" />
    <circle id="dotv3" fill="#0080ff" cx="1.0" cy="0.0" r="0.2" />
    <path fill="none" stroke="#ff8000"
          d="M -4,4.95 L 4,4.95 M -4,4.95 l 0,-0.2 m 2,0.2 l 0,-0.2 m 2,0.3
             l 0,-0.4 m 2,0.3 l 0,-0.2 m 2,0.2 l 0,-0.2"/>
    <path id="press3" class="clickable" fill="#b0b0b0" stroke="#606060"
          stroke-width="0.2" transform="translate(0.0,0)"
          d="M -0.4,4.5 l 0.4,0.4 l 0.4,-0.4 a 0.4,0.4 0 0,0 -0.8,0.0" />
    <text class="svgtxt" x="-6.6" y="-5.0">position</text>
    <text class="svgtxt" fill="#0080ff" x="3.5" y="-5.0">velocity</text>
    <text class="svgtxt" id="vel3v" fill="#0080ff" x="1.6" y="-0.3">v</text>
    <text class="svgtxt" id="vel3g" fill="#ff8000" x="1.4" y="1.4">
      g&#x03c4;</text>
    <text class="svgtxt" id="vel3w" fill="#0080ff" x="3.2" y="-1.1">
      &#x03c9;</text>
  </svg>
  </div>
  <p>Press the button at the bottom to watch the point move at
    constant speed.  Slide the button left or right to deflect its
    course to the left or right - more positive or more negative rate
    of change of direction $\omega.$ Think of the slider as the tiller
    of a boat or the steering wheel of a car.  (In the figure, the
    point will jump to the opposite side if you drive off the visible
    part of the position plane.)  The sideways acceleration $g$ varies
    in proportion to $\omega,$ with $g=\omega v$ as for uniform
    circular motion.  The orange acceleration vector always remains
    perpendicular to the blue velocity vector, which is why the speed
    of the point remains constant while you steer it around.  Hold the
    button at a fixed position and watch the point move in a circle -
    the uniform circular motion we studied before.  Unlike that
    uniform case, a varying angular speed $\omega$ only refers to the
    angular rate of change of the velocity vector, because there is no
    longer a center in the position plane.</p>
  <p>Our second step is to study motion constrained to a velocity
    space circle centered on a non-zero velocity.  In the previous
    figure, you can drag the point at the center of the velocity plane
    away from the center of the circle to any other point you please.
    That new point becomes the origin where velocity is zero.  The
    displaced blue arrow remains the velocity of the point in position
    space, which is now the sum of the two gray velocity vectors.  The
    first is the now non-zero center velocity, running from the origin
    (tail of the blue arrow) to the center of the velocity space
    circle.  The second is a radius vector, with its tail at the
    center and its head at the head of the blue arrow.  The length $v$
    of the gray radius vector remains fixed, and both the length and
    direction of the center vector remain fixed, as the point moves.
    Again, you can animate the motion and control the magnitude of the
    acceleration by holding and sliding the button at the bottom.  The
    center velocity acts like a steady current, making the point
    harder to steer.</p>
  <p>The orange acceleration vector must remain normal to the gray
    radius vector - not to the blue velocity vector - in order to keep
    the blue vector on its circular path.  The magnitude of the
    acceleration is still $g=\omega v$, but now $v$ is the radius of
    the velocity circle, the second gray vector.  The speed of the
    point in position space, which is the length of the blue vector,
    changes depending on which way it is moving relative to the center
    velocity.</p>


  <h2>Angular Momentum</h2>

  <p>Gravity is an attraction between any two masses, according to
    Newton.  The strength of attraction is proportional to mass, and
    in the case of the sun and the planets, the mass of the sun is so
    much larger than the mass of any planet, that to a good
    approximation you can ignore the attractions of the planets to one
    another, and consider only their attraction toward the sun.  (It
    turns out that this is also the accuracy of Kepler's Laws, which
    themselves are only approximate.)  A force which is always
    directed toward a fixed point - in this case the sun - is called a
    central force.  For any central force, Newton's first two laws of
    motion turn out to produce Kepler's equal area law, as the next
    figure indicates.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -5.5 21 11" onload="fig4_interactions(evt)"
       stroke-width="0.1">
    <path id="area4" fill="#d0f0ff" stroke="#d0f0ff"
          d="M 0.0,4.0 L 2.0,-1.0 L -0.5,-2.0 Z"/>
    <path id="velw4" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 1.06067,5.06067 a 1.5,1.5 0 0,0 0.0,-2.12132" />
    <path id="path4" fill="none" stroke="#c0c0c0"
          d="M 4.5,0.0 L 2.0,-1.0" />
    <path id="rect4" fill="none" stroke="#c0d8ff"
          d="M 0.0,4.0 L -2.5,3.0 L -0.5,-2.0" />
    <circle id="dotw4" fill="#c0d8ff" cx="-2.5" cy="3.0" r="0.2" />
    <path id="velv4" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 2.0,-1.0 L -0.5,-2.0" />
    <circle id="dotv4" class="clickable" fill="#0080ff" stroke="transparent"
            stroke-width="0.3" cx="-0.5" cy="-2.0" r="0.2" />
    <path id="posp4" fill="none" stroke="black"
          marker-end="url(#arrowk)" d="M 0.0,4.0 L 2.0,-1.0" />
    <circle id="dotp4" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="2.0" cy="-1.0" r="0.2" />
    <circle id="dots4" fill="black" cx="0.0" cy="4.0" r="0.2" />
    <text class="svgtxt" id="txt4o" fill="#0080ff" x="1.7" y="4.2">
      &#x03c9;</text>
    <text class="svgtxt" id="txt4s" fill="black" x="-0.2" y="4.9">S</text>
    <text class="svgtxt" id="txt4p" fill="black" x="1.973" y="-1.307">P</text>
    <text class="svgtxt" id="txt4v" fill="black" x="-1.357" y="-1.973">V</text>
    <text class="svgtxt" id="txt4w" fill="black" x="-3.543" y="2.953">W</text>
    <text class="svgtxt" id="txt4r" fill="black" x="1.892" y="0.314">r</text>
    <text class="svgtxt" id="txt4vt" fill="#0080ff" x="0.244" y="-1.948">
      v&#x03c4;</text>
  </svg>
  </div>
  <p>Here S is the sun, the center of attraction, and P is the planet
    at distance $r$ from the sun, moving with velocity $v.$ Again, we
    can draw the blue velocity vector in this position plane by
    plotting the point V the planet would reach in a time $\tau$ if it
    continued in a straight line at its current speed.  The shaded
    blue triangle is the area which the radius vector would sweep out
    were it to follow that course.  This area is half the parallelogram
    SPVW; we have added point W such that SW is parallel to PV and the
    same length.</p>
  <p>Now according to Newton's first law of motion, if there were no
    force acting on the planet P, it would continue along PV at a constant
    speed $v.$  You can drag the point P along this no-force trajectory.
    Notice that no matter where the point lies on the line PV, the area
    of the parallelogram (hence of triangle SPV) remains unchanged, since
    the parallelogram always has base SW and lies between the parallel
    lines SW and PV.</p>
  <p>On the other hand, according to Newton's second law of motion,
    any force on the planet P directed towards (or away from) S causes
    its velocity to change in the direction PS, which is parallel to
    VW.  You can drag the point V along the line VW to see all the
    different velocities a central force toward (or away from) S could
    produce.  Once again, the area of SPVW (hence of SPV) remains the
    same, no matter how strong the deflection in the direction of S.</p>
  <p>The shaded area is what would be swept over by the radius if P
    were to continue along its trajectory for a time $\tau.$ In other
    words, the rate of change of area swept out by the radius SP is
    the shaded area divided by $\tau.$ In order to calculate how the
    point P actually moves, we can break the motion into a sequence of
    very short time steps (much smaller than the $\tau$ in the
    figure).  In each time step, the velocity changes only slightly,
    so we can use the current velocity to compute a new position.
    Similarly, the position changes only slightly, so we can use the
    acceleration due to the central force at the current position to
    compute the change in velocity.  We take the next step from the
    new position with the new velocity.  What the figure shows is that
    both parts of each of these time steps - the calculation of the
    change in position and the calculation of the change in velocity
    - leave the rate of change of swept area unchanged.  That is, the
    rate of change of swept area remains constant as the planet P
    moves along its path as long as its acceleration is centrally
    directed, no matter how that force changes along its trajectory.</p>
  <p>Instead of the area SPV swept out by the radius vector, we will
    write a formula for twice that area, SPVW.  The rate of change of
    parallelogram area is called the angular momentum of the planet P
    relative to the center S.  (Actually, it is the angular momnetum
    per unit planetary mass.)  What we have shown is that for a
    central force directed toward S, the angular momentum remains
    constant throughout the orbit; we will denote this rate of change
    of parallelogram area by $L.$ And this conservation of angular
    momentum is equivalent to Kepler's law that the planet's radius
    vector sweeps out equal areas in equal times.</p>
  <p>The area of SPVW is the length of its base SP, which is the
    sun-planet distance $r,$ times the component of the velocity
    normal to SP times $\tau.$ This normal component of the velocity
    is $\omega r,$ where $\omega$ is the angular speed of P around S,
    measured in radians per unit time.  That is, the area SPVW is
    $(r)(\omega r)(\tau).$ The rate of change of this area is the
    angular momentum $L=\omega r^2.$ This formula relates the
    unchanging angular momentum to the changing distance $r$ and
    angular speed $\omega.$</p>


  <h2>An Ellipse with the Sun at One Focus</h2>

  <p>Our three preliminary studies - the construction of an ellipse
    and its tangent lines from its two focus points, motion with
    velocity constrained to a circle, and the fact that central force
    laws produce orbits which conserve angular momentum - fit together
    like puzzle pieces.  We now assemble the puzzle, showing that an
    inverse square law for gravity is equivalent to elliptical
    planetary orbits with the sun at one focus.</p>
  <p>We begin with the formula we wrote for angular momentum, which we
    rewrite as an equation for the angular speed $\omega$ of the
    planet around its center of attraction, the sun: $\omega=L/r^2,$
    where the angular momentum $L$ (twice the rate of change of area
    swept out by the radius vector) remains constant as the planet
    orbits.  In other words, for any central force law, the angular
    speed of the planet around the sun is inversely proportional to
    the square of its distance from the sun - the closer it gets, the
    faster it goes around.  If the gravitational acceleration of the
    planet toward the sun <em>also</em> varies inversely as the square
    of the distance - $g=M/r^2,$ where the constant $M,$ Newton
    argues, is proportional to the mass of the sun - that means its
    acceleration will be proportional to its angular speed.  In fact,
    $g=\omega M/L,$ where $M$ is the solar mass constant, and $L$ is
    the constant angular momentum of the planet as it orbits.</p>
  <p>From our study of circular motion in velocity space, we found
    that acceleration toward the center in velocity space is
    proportional to angular speed around that center: $g=\omega v,$
    where $v$ is the radius of the circle in velocity space.  Thus, if
    we could arrange for the center of the circle in velocity space to
    somehow coincide with the sun in position space, we would know the
    planetary orbit is a circle in velocity space with radius
    $v=M/L.$</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -10.5 21 21" onload="fig5_interactions(evt)"
       stroke-width="0.1">
    <path id="os5" fill="none" stroke="#c0c0c0"
          marker-end="url(#arrowg)" d="M -6.0,0.0 L 0.0,0.0" />
    <path id="sq5" fill="none" stroke="#c0c0c0"
          marker-end="url(#arrowg)" d="M 0.0,0.0 L 0.0,-10.0" />
    <path id="oq5" fill="none" stroke="#0080ff"
          marker-end="url(#arrowb)" d="M -6.0,0.0 L 0.0,-10.0" />
    <circle fill="none" stroke="#c0c0c0" cx="0" cy="0" r="10.0" />
    <ellipse id="ell5" fill="none" stroke="black" stroke-width="0.13"
             cx="-3.0" cy="0" rx="5.0" ry="4.0" />
    <circle fill="black" cx="0" cy="0" r="0.2" />
    <circle id="foco5" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="-6.0" cy="0" r="0.2" />
    <circle id="pntq5" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="0" cy="-10.0" r="0.2" />
    <path id="inset5" fill="white" stroke="#f0f0f0" stroke-width="0.4"
          transform="rotate(0.0)"
          d="M 5.5,2.0 L 10.4,2.0 L 10.4,10.4 L 2.0,10.4 L 2.0,5.5 Z"/>
    <path id="posu5" fill="none" stroke="#c0c0c0"
          marker-end="url(#arrowg)" d="M 0.0,-3.2 L 0.0,-5.18" />
    <path id="posr5" fill="none" stroke="#c0c0c0"
          marker-end="url(#arrowg)" d="M 0.0,-5.18 L -3.2,-5.18" />
    <path id="posv5" fill="none" stroke="#0080ff"
          marker-end="url(#arrowb)" d="M 0.0,-3.2 L -3.2,-5.18" />
    <circle id="pntp5" fill="black" cx="0" cy="-3.2" r="0.2" />
    <g id="vplane5" transform="translate(6.2,6.2)">
      <circle fill="none" stroke="#a0d0ff" cx="0" cy="0" r="3.2"/>
      <path id="velu5" fill="none" stroke="#c0c0c0"
            marker-end="url(#arrowg)" d="M 0.0,1.92 L 0.0,0.0" />
      <path id="velr5" fill="none" stroke="#c0c0c0"
            marker-end="url(#arrowg)" d="M 0.0,0.0 L -3.2,0.0" />
      <path id="velg5" fill="none" stroke="#ff8000"
            marker-end="url(#arrowo)" d="M -3.2,0.0 L -3.2,0.9375" />
      <path id="velv5" fill="none" stroke="#0080ff"
            marker-end="url(#arrowb)" d="M 0.0,1.92 L -3.2,0.0" />
      <text class="svgtxt" fill="#0080ff" x="0.0" y="-3.6">velocity</text>
    </g>
    <text class="svgtxt" x="-9.0" y="-9.0">position</text>
    <text class="svgtxt" id="txs5" x="-0.3" y="0.9">S</text>
    <text class="svgtxt" id="txo5" x="-6.3" y="0.9">O</text>
    <text class="svgtxt" id="txp5" x="0.29" y="-3.188">P</text>
    <text class="svgtxt" id="txq5" x="0.2" y="-9.2">Q</text>
  </svg>
  </div>
  <p>Our diagram of ellipse geometry shows us how to arrange for the
    velocity space circle to connect to a Keplerian ellipse in exactly
    this way: The three vectors OS, SQ, and OQ resemble the
    decompostion of the velocity into a drift component (OS) and a
    radial component (SQ) to make a total velocity (OQ), which is
    constrained to lie on a circle in velocity space.  The only
    difference is that we must rotate the velocity diagram ninety
    degrees clockwise relative to the OSQ position space triangle.
    With that rotation, the blue velocity vector indeed becomes
    parallel to the ellipse tangent, since that tangent is
    perpendicular to OQ.  Furthermore, the drift component velocity is
    now perpendicular to OS, in other words vertical, and the radial
    velocity component is perpendicular to the sun-planet direction SQ
    or SP.  Since the radial velocity component is perpendicular to
    PS, the orange acceleration vector is parallel to PS.  That is,
    the acceleration of the planet P is directly toward the sun S.
    The puzzle pieces indeed fit perfectly.</p>
  <p>You can drag the points O and Q around as before to show that
    our construction works for any ellipse shape and for any position
    of the planet P on its orbital ellipse.</p>
  <p>A planet which obeys $F=ma$ with the force directed toward the
    sun and varying inversely as the square of its distance will
    indeed orbit in an ellipse with the sun at one focus.  We already
    found that for any central force law the planet's radius vector
    will sweep over equal areas in equal times, so we have proven
    the first two of Kepler's laws are equivalent to Newton's
    inverse square law.  We have learned the additional fact, which
    Kepler did not notice, that the velocity vector of the planet
    orbits in a circle in the velocity plane.</p>


  <h2>The Cube-Square Law</h2>

  <p>Since Kepler's first two laws merely describe the motion of a
    single planet, he wanted a third law to relate the orbits of the
    different planets.  More than a decade elapsed between his
    publication of his ellipse and equal area laws and his discovery
    of the third law, that the cubes of the semi-major axes are
    proportional to the squares of the orbital periods.  In contrast,
    Newton explains Kepler's first two laws as consequences of an
    inverse square force law, $g=M/r^2,$ in which the constant of
    proportionality $M$ is a property of the sun - in fact, a measure
    of the mass of the sun.  Therefore, in the Newtonian system,
    the same force law already applies to all the planets, so he does
    not need any additional laws relating the orbits of different
    planets.</p>
  <p>Our proof that the inverse square law produces elliptical orbits
    completely sidestepped the question of when the planet reaches any
    point on its orbit.  However, since we know that the rate of
    change of area swept out by the radius is constant, $L/2$ in fact,
    we can use the area between any fixed radius, say the point of
    closest approach to the sun, and any point P on the ellipse to
    compute the time when the planet will reach P.  We will not derive
    this equation of time in detail (it requires some trigonometry).
    However, we do need a formula for the orbital period $T$ - the
    length of the planet's year.</p>
  <p>The area of an ellipse with semi-major axis $a$ and semi-minor
    axis $b$ is $\pi ab,$ a generalization of the celebrated formula
    $\pi r^2$ for a circle.  Since the constant angular momentum $L$
    is twice the rate of change of the area, the time for one complete
    orbit must be $T=2\pi ab/L.$</p>
  <div class="thirdwide">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="-9.0 -7.5 12 12"
       stroke-width="0.1">
    <path fill="none" stroke="#c0c0c0"
          d="M -3.0,-4.0 L 2.0,-4.0 L 2.0,0.0 L 0.0,0.0"/>
    <path fill="none" stroke="#c0c0c0" d="M -6.0,0.0 L 0.0,0.0"/>
    <path fill="none" stroke="#c0c0c0" d="M 0.0,0.0 L -3.0,-4.0 L -3.0,0.0"/>
    <!-- <path fill="none" stroke="#0080ff"
          marker-end="url(#arrowb)" d="M -6.0,0.0 L -6.0,-8.0"/> -->
    <ellipse fill="none" stroke="black" stroke-width="0.13"
             cx="-3.0" cy="0" rx="5.0" ry="4.0"/>
    <path fill="none" stroke="#c0c0c0"
          marker-end="url(#arrowg)" d="M -3.0,-4.0 L -3.0,-7.0"/>
    <path fill="none" stroke="#c0c0c0"
          marker-end="url(#arrowg)" d="M -3.0,-7.0 L -7.0,-4.0"/>
    <path fill="none" stroke="#0080ff"
          marker-end="url(#arrowb)" d="M -3.0,-4.0 L -7.0,-4.0"/>
    <circle fill="black" cx="0" cy="0" r="0.2"/>
    <circle fill="black" cx="-6.0" cy="0" r="0.2"/>
    <!-- <circle fill="black" cx="-6.0" cy="-8.0" r="0.2"/> -->
    <circle fill="black" cx="-3.0" cy="-4.0" r="0.2"/>
    <text class="svgtxt" x="-0.3" y="0.9">S</text>
    <text class="svgtxt" x="-6.3" y="0.9">O</text>
    <text class="svgtxt" x="-2.85" y="-4.25">P</text>
    <text class="svgtxt" x="-3.65" y="-5.2">u</text>
    <text class="svgtxt" x="-5.6" y="-5.5">v</text>
    <text class="svgtxt" x="-0.5" y="-4.15">a</text>
    <text class="svgtxt" x="-3.65" y="-1.6">b</text>
    <text class="svgtxt" x="-2.0" y="-0.15">c</text>
    <text class="svgtxt" x="-1.4" y="-2.0">a</text>
    <!-- <text class="svgtxt" x="-5.5" y="-7.8">Q</text> -->
  </svg>
  </div>
  <p>Now SQ, the string length for constructing the ellipse, is twice
    its semi-major axis, or $2a.$ We define $c$ to be the distance
    from the center of the ellipse to either focus, so that OS is
    $2c.$ In the velocity plane, we have already named the radius of
    the circle $v=M/L.$ We now give the name $u$ to the drift
    component of the velocity.  Since the velocity plane triangle is
    similar to OSQ in the position plane, the ratio OS/SP equals
    $u/v=c/a.$</p>
  <p>To derive Kepler's cube-square law, consider the moment when the
    planet P is equidistant from the foci O and S.  At that instant,
    the total velocity is horizontal with magnitude $\sqrt{v^2-u^2}$,
    and the point P is a distance $b$ above OS.  Since $u/v=c/a,$
    $\sqrt{v^2-u^2}=vb/a.$ The angular momentum is therefore
    $L=vb^2/a.$ Since $v=M/L,$ we have $M=v^2b^2/a.$ We can eliminate
    the velocity $v$ to find an expression relating $M,$ $L,$ $a,$ and
    $b,$ namely $M=L^2a/b^2.$ The final step is to square our
    expression for the period $T^2=4\pi^2 a^2b^2/L^2.$ Rearranging
    this, we have $a^3/T^2 = L^2a/b/(4\pi^2),$ which is
    $a^3/T^2=M/(4\pi^2).$ Thus, we identify Kepler's third law
    constant as Newton's solar mass constant $M$ divided by $4\pi^2.$
    Since the mass $M$ is a property of the sun, the constant is the
    same for every planetary orbit, completing our demonstration that
    the Newtonian law of gravity produces Keplerian orbits.</p>


  <h2>Conclusion</h2>

  <p>Kepler's three laws describe planetary motion without giving any
    insight into what causes the orbital shapes or speeds.  Newton's
    law of motion $F=ma,$ on the other hand, applies to the motion of
    everyday objects on earth.  While there isn't any more cause for
    Newton's inverse square law of gravitational force $g=M/r^2$ than
    for Kepler's laws, it is far simpler and the fact that planets
    respond to this simple force law by moving in Keplerian orbits
    shows us that planets move according to the same rules as rocks on
    earth.  A planet is just a large rock, moving as rocks move.</p>
  <p>Despite its apparently simpler form, Newtonian gravity is really
    dramatically more complicated because of its universal character.
    Newtonian gravity acts between every pair of objects, between
    every atom of the sun or planet or rock.  Before Principia, no one
    had any idea that the force holding the planets in their orbits
    around the sun is identical to the force that makes a rock fall to
    earth.</p>
  <p>With Newtonian gravity, we can compare the acceleration of the
    moon in orbit around the earth to the downward acceleration of a
    rock: A sidereal month is 27.3 days or about 2.36 million seconds
    and the moon is about 60 earth radii away, so $\omega^2 r$ for the
    moon is $(2\pi/2.36\times 10^6)^2\times 60=4.3\times 10^{-10}$
    earth radii per second per second.  According to the inverse
    square law, the acceleration of gravity at the surface of the
    earth, 60 times closer, should be $60^2=3600$ times greater.
    Since the radius of the earth is about $6.4\times 10^6$ meters,
    the gravity holding the moon in its orbit would have an
    acceleration of $4.3\times 10^{-10} \times 3600\times 6.4\times
    10^6=9.9$ meters per second per second.  When you drop a rock, it
    falls to earth with an acceleration of 9.8 meters per second per
    second, "which answers pretty nearly," as Newton put it; the
    inverse square law describes how both the moon and the rock
    move.  No one before Newton connected the two.</p>
  <p>Because of all of the gravitational attractions to other planets
    as well as to the sun, the planetary orbits should not quite be
    ellipses with the sun at one focus sweeping out equal areas in
    equal times - they should wobble about in slightly irregular
    orbits.  The moon is an extreme case, because its attraction to
    the sun is an appreciable fraction of its attraction to the earth,
    which causes the orbit of the moon to be particularly irregular,
    deviating obviously from a Keplerian ellipse.  Newton himself
    spent years computing these orbital perturbations, particularly
    for the moon.  In every case, the observed deviations from perfect
    Keplerian ellipses and equal area sweep rates match what you
    expect from all those additional inverse square attractions.  In
    other words, the complexity of Newtonian universal gravitation
    appears to match the complexity we observe in the real world.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-10.5 -6.0 21 11" onload="fig7_interactions(evt)"
       stroke-width="0.1">
    <defs>
      <marker id="arrowk" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="black" stroke="black" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowg" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#c0c0c0" stroke="#c0c0c0" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowb" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#0080ff" stroke="#0080ff" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrowo" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#ff8000" stroke="#ff8000" stroke-width="1"
                 points="0,-3, 6,0, 0,3"/>
      </marker>
    </defs>
    <path fill="none" stroke="#f0f0f0" stroke-width="0.3"
          d="M 0.0,-4.85 L 0.0,3.7"/>
    <ellipse id="ell7" fill="none" stroke="#c0c0c0"
             cx="-5.0" cy="0" rx="4.4" ry="3.52"/>
    <circle fill="none" stroke="#a0d0ff" cx="5.0" cy="0" r="4.4"/>
    <path id="posr7" fill="none" stroke="black" marker-end="url(#arrowk)"
          d="M -2.36,0.0 L -5.0,-3.52"/>
    <path id="posv7" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M -5.0,-3.52 l -2.0,0.0"/>
    <circle id="dots7" class="clickable" fill="black" stroke="transparent"
            stroke-width="0.3" cx="-2.36" cy="0.0" r="0.2"/>
    <circle id="doto7" class="clickable" fill="#c0c0c0" stroke="transparent"
            stroke-width="0.3" cx="-7.64" cy="0.0" r="0.2"/>
    <circle id="dotr7" fill="black" cx="-5.0" cy="-3.52" r="0.2"/>
    <path id="velu7" fill="none" stroke="#c0c0c0" marker-end="url(#arrowg)"
          d="M 5.0,2.64 L 5.0,0.0"/>
    <path id="velc7" fill="none" stroke="#c0c0c0" marker-end="url(#arrowg)"
          d="M 5.0,0.0 L 1.48,2.64"/>
    <path id="velv7" fill="none" stroke="#0080ff" marker-end="url(#arrowb)"
          d="M 5.0,2.64 L 1.48,2.64"/>
    <path id="velg7" fill="none" stroke="#ff8000" marker-end="url(#arrowo)"
          d="M 1.47,2.64 l 0.24,0.32"/>
    <circle fill="#c0c0c0" cx="5.0" cy="0.0" r="0.2"/>
    <circle id="dotc7" fill="#0080ff" cx="5.0" cy="2.64" r="0.2"/>
    <circle id="dotv7" fill="#0080ff" cx="1.48" cy="2.64" r="0.2"/>
    <circle id="press7" class="clickable" fill="#b0b0b0" stroke="#606060"
            stroke-width="0.2" cx="0.0" cy="4.5" r="0.4"/>
    <text class="svgtxt" x="-6.6" y="-5.0">position</text>
    <text class="svgtxt" fill="#0080ff" x="3.5" y="-5.0">velocity</text>
  </svg>
  </div>
</div>
<script>
  var tracking = null;

  function add_trackers(svg, targets, start, track, stop) {
    // svg = svg element
    // targets = array of elements in svg to listen for mouse down events
    // start(index, coords) --> tracking (or null to abort)
    //   index = index into targets
    //   coords = event coordinates in svg coordinate system
    // track(tracking, coords) --> tracking (or null to abort)
    //   tracking = returned by start
    //   coords = event coordinates in svg coordinate system
    // stop(tracking)
    //   tracking = returned by start

    function svgcoords(evt) {  // return event coordinates
      var CTM = svg.getScreenCTM();
      if (evt.touches) {
        evt = evt.touches[0];
      }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    function wrapstart(evt) {
      if (tracking !== null) {
        wrapstop(evt);
      }
      var t = evt.target;
      var index = targets.indexOf(t);
      if (index < 0) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = start(index, svgcoords(evt));
    }

    function wraptrack(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = track(tracking, svgcoords(evt));
    }

    function wrapstop(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      stop(tracking);
      tracking = null;
    }

    svg.addEventListener("mousedown", wrapstart);
    svg.addEventListener("mousemove", wraptrack);
    svg.addEventListener("mouseup", wrapstop);
    svg.addEventListener("mouseleave", wrapstop);
    svg.addEventListener("touchstart", wrapstart);
    svg.addEventListener("touchmove", wraptrack);
    svg.addEventListener("touchend", wrapstop);
    svg.addEventListener("touchcancel", wrapstop);
  }

  function get_element(id) {
    return document.getElementById(id);
  }

  var abs = Math.abs;
  var sqrt = Math.sqrt;

  function fig1_interactions(evt) {
    var fig1 = evt.target;
    var f1handle = ["foco1", "pntq1", "pntn1"].map(get_element);
    var pntcx = f1handle.map(function(e)
                             {return e.getAttributeNodeNS(null, "cx");});
    var pntcy = f1handle.map(function(e)
                             {return e.getAttributeNodeNS(null, "cy");});
    var ellipse = get_element("ell1");
    var ellcx = ellipse.getAttributeNodeNS(null, "cx");
    var ellry = ellipse.getAttributeNodeNS(null, "ry");
    var circs = ["foco1", "pntp1", "pntq1", "pntm1", "pntn1"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var paths = ["sp1", "opq1", "oq1", "pm1", "snq1"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var texts = ["txs1", "txo1", "txp1", "txq1", "txm1",
                 "txn1"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});
    var snqstroke = paths[4].getAttributeNodeNS(null, "stroke");
    var pntnfill = circs[4].getAttributeNodeNS(null, "fill");
    var txtnfill = texts[5].getAttributeNodeNS(null, "fill");
    var a = 5.0;  // fixed - do not change
    var c = 3.0;
    var xq = 0.0;
    var yq = 10.0;
    var xp = 0.0;
    var yp = 3.2;
    var xn = -3.0;
    var yn = 5.0;
    var nhidden = true;

    function nhide(on) {
      if (on) {
        snqstroke.value = pntnfill.value = txtnfill.value = "transparent";
        nhidden = true;
      } else {
        snqstroke.value = pntnfill.value = txtnfill.value = "#ff8000";
        nhidden = false;
      }
    }

    function seto(x) {
      c = -0.5 * x;
      circx[0].value = "" + x;
      textx[1].value = "" + (x - 0.3);
      ellcx.value = "" + (-c);
      ellry.value = "" + sqrt(a*a - c*c);
      setq(xq, yq);
    }

    function setq(qx, qy) {
      var ychange = (yq < 0.) != (qy < 0.);
      xq = qx;  yq = qy;
      xn = 0.5*xq - c;  yn = 0.5*yq;
      qx /= a;  qy /= a;
      var s = (2.*a - qx*c) / (qx*qx + yq*yq/(a*a - c*c));
      xp = s*qx;  yp = s*qy;
      circx[1].value = "" + xp;  circy[1].value = "" + (-yp);
      circx[2].value = "" + xq;  circy[2].value = "" + (-yq);
      circx[3].value = circx[4].value = "" + (0.5*xq - c);
      circy[3].value = circy[4].value = "" + (-0.5*yq);
      pathd[0].value = "M 0.0,0.0 L " + xp + "," + (-yp);
      var mo = "M " + (-2.0*c) + ",0.0 L "
      pathd[1].value = mo + xp + "," + (-yp) + " L " + xq + "," + (-yq);
      pathd[2].value = mo + xq + "," + (-yq);
      // Compute endpoints of PM on circle concentric with ellipse and
      // halfway between ellipse and Q-circle, center (0,-c) radius (3a-c)/2
      var cc = xp + c;
      var xoq = xq + 2.*c;
      var aa = xoq*xoq + yq*yq;
      var bb = yq*cc - xoq*yp;  // -B/2 in quadratic equation
      cc = cc*cc + yp*yp - 0.25*(3.*a - c)**2;
      var dd = bb*bb - aa*cc;
      if (dd < 0.0) {
        dd = 0.0;  // guard against rounding error
      }
      dd = sqrt(dd);
      cc = (bb - dd)/aa;  bb = (bb + dd)/aa;  // two roots or quadratic
      // (xp,yp) + (-yq,xoq)*root are endpoints
      pathd[3].value = ("M " + (xp-yq*bb) + "," + (-yp-xoq*bb) +
                        " L " + (xp-yq*cc) + "," + (-yp-xoq*cc));
      if (ychange) {
        if (yq >= 0.) {
          texty[0].value = texty[1].value = "0.9";
        } else {
          texty[0].value = texty[1].value = "-0.3";
        }
      }
      // compute Q letter position
      var qx = sqrt(xq*xq + yq*yq);
      var qy = yq / qx;
      qx = xq / qx;
      if (yq >= 0.0) {  // xprime=(qy,-qx) and yprime=(qx,qy)
        s = xq + 0.5*qy - 0.5*qx;
        qy = yq - 0.5*qx - 0.5*qy;
        qx = s;
      } else {
        s = xq - 0.5*qy - 0.5*qx;
        qy = yq + 0.5*qx - 0.5*qy;
        qx = s;
      }
      textx[3].value = "" + (qx-0.3);
      texty[3].value = "" + (0.3-qy);
      // compute P letter position
      qx = sqrt((2.*c+xp)**2 + yp**2);
      qy = yp / qx;
      qx = (2.*c+xp) / qx;
      qx = xp + 0.612*qx;
      qy = yp + 0.612*qy;
      textx[2].value = "" + (qx-0.25);
      texty[2].value = "" + (0.3-qy);
      // compute M letter position
      qx = 0.5*xq - c;
      qy = 0.5*yq;
      if (yq >= 0.0) {
        textx[4].value = "" + (qx-0.4);
        texty[4].value = "" + (-0.4-qy);
      } else {
        textx[4].value = "" + (qx-0.4);
        texty[4].value = "" + (1.0-qy);
      }
    }

    function setn(x, y) {
      xn = x;  yn = y;
      // d="M 0.0,0.0 L -3.0,-5.0 L 0.0,-10.0 M -6.0,0.0 L -3.0 -5.0"
      circx[4].value = "" + xn;
      circy[4].value = "" + (-yn);
      pathd[4].value = ("M 0.0,0.0 L " + xn + "," + (-yn) +
                        " L " + xq + "," + (-yq) +
                        " M " + (-2.*c) + ",0.0 L " + xn + "," + (-yn));
      // compute N letter position
      if (yq >= 0.0) {
        textx[5].value = "" + (xn-0.4);
        texty[5].value = "" + (-0.4-yn);
      } else {
        textx[5].value = "" + (xn-0.4);
        texty[5].value = "" + (1.0-yn);
      }
    }

    function fullreset() {
      xq = 0.0;  yq = 10.0;
      texty[0].value = texty[1].value = "0.9";
      seto(-6.0);
    }

    function start(index, coords) {
      var dx = coords.x;
      var dy = coords.y;
      if (index === 0) {  // point O
        dx = -2.*c - dx;
        xn = 0.5*xq - c;
        yn = 0.5*yq;
        setn(0.5*xq - c, 0.5*yq);
        nhide(true);
      } else if (index === 1) {  // point Q
        dx = xq - dx;
        dy = yq + dy;
        setn(0.5*xq - c, 0.5*yq);
        nhide(true);
      } else {  // point N
        if (nhidden) {  // use point M coordinates
          xn = 0.5*xq - c;
          yn = 0.5*yq;
        }
        dx = xn - dx;
        dy = yn + dy;
        setn(xn, yn);
      }
      return [index, dx, dy];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var x = coords.x + tracking[1];
      var y = tracking[2] - coords.y;
      var twoa = a + a;
      var r;
      if (index === 0) {  // point O
        if (x > 0.2 || x < 0.4 - twoa) {
          fullreset();
          return null;
        }
        if (x > 0.0) {
          x = 0.0;
        }
        seto(x);
      } else if (index === 1) {  // point Q
        r = sqrt(x*x + y*y);
        if (r > 0.1) {
          x = twoa * x / r;
          y = twoa * y / r;
        }
        setq(x, y);
      } else {  // point N
        // project (x, y) onto the line PM, (-yoq, xoq)
        var xoq = xq + 2.*c;
        var r = sqrt(xoq*xoq + yq*yq);
        var yoq = yq / r;
        xoq /= r;
        r = (y-yp)*xoq - (x-xp)*yoq;
        x = xp - r*yoq;  y = yp + r*xoq;  // (x, y) now on line PM
        r = sqrt((x + c)**2 + y**2);
        if (r > 0.5*(3.*a - c)) {
          return null;
        }
        var xm = 0.5*xq - c;
        var ym = 0.5*yq;
        if ((x-xm)**2 + (y-ym)**2 > 0.25) {  // N has moved off M
          nhide(false);
        } else {
          nhide(true);
        }
        setn(x, y);
      }
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        if (tracking[0] === 2 && nhidden) {
          xn = 0.5*xq - c;
          yn = 0.5*yq;
        }
      }
      return;
    }

    add_trackers(fig1, f1handle, start, track, stop);
  }

  function fig2_interactions(evt) {
    var fig2 = evt.target;
    var f2handle = ["press2"].map(get_element);
    var paths = ["posr2", "velv2", "posv2",
                 "velg2", "posw2", "velw2"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var circs = ["dotr2", "dotv2"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var texts = ["pos2r", "vel2v", "pos2v",
                 "vel2g", "pos2w", "vel2w"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});

    var center = 5.0;
    var radius = 4.4;
    var dscale = 1.7 / radius;
    var xnow = 0.0;
    var ynow = radius;
    var dth = 0.04;  // step multiplies by (1, dth), normalized

    function redraw(x, y) {
      var flip = (x <= 0) !== (xnow <= 0);
      xnow = x;
      ynow = y;
      circx[0].value = "" + (x - center);
      circy[0].value = "" + (-y);
      circx[1].value = "" + (center - y);
      circy[1].value = "" + (-x);
      pathd[0].value = "M -5.0,0.0 L " + (x - center) + "," + (-y);
      pathd[1].value = "M 5.0,0.0 L " + (center - y) + "," + (-x);
      pathd[2].value = ("M " + (x - center) + "," + (-y) + " l " +
                        (-dscale*y) + "," + (-dscale*x));
      pathd[3].value = ("M " + (center - y) + "," + (-x) + " l " +
                        (-dscale*x) + "," + (dscale*y));
      // pos2r  x="-4.8" y="-3.2"  (+0.2, 3.2)  relative to (-5,0)
      // pos2v  x="-6.4" y="-3.5"  (-1.4, 3.5)  relative to (-5,0)
      var yx = x / radius;
      var yy = y / radius;
      var xx = yy;
      var xy = -yx;
      textx[0].value = "" + (0.4*xx + 3.45*yx - 0.2 - 5.0);
      texty[0].value = "" + (-0.4*xy - 3.45*yy + 0.25);
      textx[2].value = "" + (-0.98*xx + 3.75*yx - 0.42 - 5.0);
      texty[2].value = "" + (0.98*xy - 3.75*yy + 0.25);
      // vel2v  x="1.2" y="-0.3"  (-3.8, 0.3)   relative to (5,0)
      // vel2g  x="1.0" y="1.4"   (-4.0, -1.4)  relative to (5,0)
      textx[1].value = "" + (-3.6*xx + 0.55*yx - 0.2 + 5.0);
      texty[1].value = "" + (3.6*xy - 0.55*yy + 0.25);
      textx[3].value = "" + (-3.58*xx - 1.25*yx - 0.42 + 5.0);
      texty[3].value = "" + (3.58*xy + 1.25*yy + 0.15);
      if (flip) {
        if (x > 0) {
          pathd[4].value = "M -6.5,0.0 a 1.5,1.5 0 0,0 1.5,1.5";
          pathd[5].value = "M 5.0,1.5 a 1.5,1.5 0 0,0 1.5,-1.5";
          textx[4].value = "-6.8";
          texty[4].value = "1.5";
          textx[5].value = "6.3";
          texty[5].value = "1.4";
        } else {
          pathd[4].value = "M -3.5,0.0 a 1.5,1.5 0 0,0 -1.5,-1.5";
          pathd[5].value = "M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5";
          textx[4].value = "-4.0";
          texty[4].value = "-1.2";
          textx[5].value = "3.2";
          texty[5].value = "-1.1";
        }
      }
    }

    function stepper() {
      var x = xnow - ynow*dth;
      var y = ynow + xnow*dth;
      var r = radius / sqrt(x*x + y*y);
      redraw(x*r, y*r);
    }

    function start(index, coords) {
      var interval_timer = null;
      if (index === 0) {
        interval_timer = setInterval(stepper, 20);  // 50 frames/sec
      }
      return [index, interval_timer];
    }

    function track(tracking, coords) {
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        if (tracking[1] !== null) {
          if (abs(xnow) < 0.5 && ynow > 0.0) {
            xnow = 0.0001;
            ynow = radius;
            redraw(0.0, radius);
          }
          clearInterval(tracking[1]);
        }
      }
      return;
    }

    add_trackers(fig2, f2handle, start, track, stop);
  }

  function fig3_interactions(evt) {
    var fig3 = evt.target;
    var f3handle = ["press3", "dotc3"].map(get_element);
    var xform = f3handle[0].getAttributeNodeNS(null, "transform");
    var paths = ["posr3", "velv3", "posv3", "velg3", "velw3",
                 "velc3", "velu3"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var cdisplay = paths.slice(5).map(
      function(e) {return e.getAttributeNodeNS(null, "display");});
    var circs = ["dotr3", "dotv3", "dotc3"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var texts = ["vel3v", "vel3g", "vel3w"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});
    var vfill = texts[0].getAttributeNodeNS(null, "fill");
    var wfill = texts[2].getAttributeNodeNS(null, "fill");
    var wstro = paths[4].getAttributeNodeNS(null, "stroke");
    var wmark = paths[4].getAttributeNodeNS(null, "marker-end");

    var center = 5.0;
    var speed = 4.0;
    var gscale = 0.2;
    var gnow = 0.0;
    var vx = -4.0;
    var vy = 0.0;
    var v0x = 0.0;
    var v0y = 0.0;
    var xnow = -3.0;
    var ynow = 0.0
    var dtg = 0.01;  // timestep in velocity plane
    var dtv = 0.012;  // timestep in position plane
    var npts = 1;
    var trail = "M -2.5,0.0 L -3.0,0.0";
    var vscale = 1.2 / speed;
    var wrapped = false;
    var wupper = true;
    var vflip = false;

    function redraw() {
      circx[0].value = "" + xnow;
      circy[0].value = "" + (-ynow);
      circx[1].value = "" + (center + vx);
      circy[1].value = "" + (-vy);
      circx[2].value = "" + (center - v0x);
      circy[2].value = "" + v0y;
      npts += 1;
      if (npts > 400) {  // remove one point at head of trail after 8 sec
        trail = trail.replace(/M[^L]*L/, "M");
      }
      trail += (wrapped? " M " : " L ") + xnow + "," + (-ynow);
      pathd[0].value = trail;
      pathd[1].value = ("M " + (center - v0x) + "," + v0y +
                        " L " + (center + vx) + "," + (-vy));
      pathd[2].value = ("M " + xnow + "," + (-ynow) + " l " +
                        (vscale*(v0x+vx)) + "," + (-vscale*(v0y+vy)));
      var g = gnow * gscale;
      if (g === 0) {
        g = 0.0001;
      }
      pathd[3].value = ("M " + (center + vx) + "," + (-vy) + " l " +
                        (-g*vy) + "," + (-g*vx));
      if (v0x !== 0.0 || v0y !== 0.0) {
        pathd[5].value = ("M " + center + ",0.0" +
                          " L " + (center + vx) + "," + (-vy));
        pathd[6].value = ("M " + (center - v0x) + "," + v0y +
                          " L " + center + ",0.0");
        cdisplay[0].value = cdisplay[1].value = "block";
        vfill.value = wfill.value = wstro.value = "#c0c0c0";
        wmark.value = "url(#arrowg)";
      } else {
        cdisplay[0].value = cdisplay[1].value = "none";
        vfill.value = wfill.value = wstro.value = "#0080ff";
        wmark.value = "url(#arrowb)";
      }
      var xx = -vx / speed;
      var xy = -vy / speed;
      var yx = -xy;
      var yy = xx;
      // vel3v  x="1.6" y="-0.3"  (-3.4, 0.3)   relative to (5,0)
      // vel3g  x="1.4" y="1.4"   (-3.6, -1.4)  relative to (5,0)
      tsign = (gnow >= 0.0)? 1.0 : -1.0;
      textx[0].value = "" + (-3.2*xx + tsign*0.55*yx - 0.2 + 5.0);
      texty[0].value = "" + (3.2*xy - tsign*0.55*yy + 0.25);
      textx[1].value = "" + (-3.18*xx - tsign*1.25*yx - 0.42 + 5.0);
      texty[1].value = "" + (3.18*xy + tsign*1.25*yy + 0.15);
      if (vflip) {
        if ((vx<0)? vy > 0 : vy >= 0) {
          pathd[4].value = "M 5.0,1.5 a 1.5,1.5 0 0,0 1.5,-1.5";
          textx[2].value = "6.3";
          texty[2].value = "1.4";
          wupper = false;
        } else {
          pathd[4].value = "M 5.0,-1.5 a 1.5,1.5 0 0,0 -1.5,1.5";
          textx[2].value = "3.2";
          texty[2].value = "-1.1";
          wupper = true;
        }
      }
    }

    function stepper() {
      var g = gnow * dtg;
      var vvx = vx - vy*g;
      var vvy = vy + vx*g;
      var v = speed / sqrt(vvx**2 + vvy**2);
      vvx *= v;
      vvy *= v;
      xnow += (v0x + 0.5*(vx + vvx))*dtv;
      ynow += (v0y + 0.5*(vy + vvy))*dtv;
      wrapped = false;
      if (xnow < -10.0) {
        xnow = -0.5;
        wrapped = true;
      } else if (xnow > -0.5) {
        xnow = -10.0;
        wrapped = true;
      }
      if (ynow < -4.4) {
        ynow = 4.6;
        wrapped = true;
      } else if (ynow > 4.6) {
        ynow = -4.4;
        wrapped = true;
      }
      vflip = (vy*vvy <= 0.0);
      vx = vvx;
      vy = vvy;
      redraw();
    }

    function start(index, coords) {
      var interval_timer;
      if (index === 0) {
        interval_timer = setInterval(stepper, 20);  // 50 frames/sec
        return [index, interval_timer, -gnow-coords.x];
      } else if (index === 1) {
        vx = -4.0;
        xnow = -3.0;
        vy = ynow = gnow = 0.0;
        xform.value = "translate(0.0,0)";
        var v = v0x*v0x + v0y*v0y;
        if (v < 0.04) {
          v = 1.0;
          v0x = v0y = 0.0;
        }
        v = sqrt((v0x+vx)**2 + v0y**2);
        if (v === 0.0) {
          v = 1.0;
        }
        trail = "M "+(xnow-0.5*(v0x+vx)/v)+","+(0.5*v0y/v)+" L -3.0,0.0";
        npts = 1;
        wrapped = false;
        vflip = true;  // forces redraw to set wupper
        redraw();
        vflip = false;
        return [index, -v0x-coords.x, v0y-coords.y];
      }
      return [index, null, null];
    }

    function track(tracking, coords) {
      if (tracking === null || tracking[1] === null) {
        return null;
      }
      if (tracking[0] === 0) {
        var g = -(coords.x + tracking[2]);
        if (coords.y < 3.0) {
          clearInterval(tracking[1]);
          return null;
        }
        if (abs(g) > 4.0) {
          g *= 4.0 / abs(g);
        } if (abs(g) < 0.2) {
          g = 0.0;
        }
        gnow = g;
        xform.value = "translate(" + (-gnow) + ",0)";
      } else {
        v0x = -(coords.x + tracking[1]);
        v0y = coords.y + tracking[2];
        if (abs(v0x) >= 4.0 || abs(v0y) >= 4.0) {
          tracking = null;
        }
        if (tracking === null || v0x*v0x + v0y*v0y < 0.09) {
          v0x = v0y = 0.0;
        }
        var v = sqrt((v0x+vx)**2 + v0y**2);
        if (v === 0.0) {
          v = 1.0;
        }
        trail = "M "+(xnow-0.5*(v0x+vx)/v)+","+(0.5*v0y/v)+" L -3.0,0.0";
        redraw();
      }
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null && tracking[0] === 0 && tracking[1] !== null) {
        clearInterval(tracking[1]);
      }
      return;
    }

    add_trackers(fig3, f3handle, start, track, stop);
  }

  function fig4_interactions(evt) {
    var fig4 = evt.target;
    var f4handle = ["dotp4", "dotv4"].map(get_element);
    var xform = f4handle[0].getAttributeNodeNS(null, "transform");
    var paths = ["posp4", "velv4", "rect4", "area4", "path4"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var circs = ["dotp4", "dotv4", "dotw4"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var texts = ["txt4p", "txt4v", "txt4w", "txt4r", "txt4vt"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});

    var center = 4.0;
    var rx0 = 2.0;
    var ry0 = 5.0;
    var vtx0 = -2.5;
    var vty0 = 1.0;
    var rx = rx0;
    var ry = ry0;
    var vtx = vtx0;
    var vty = vty0;

    function redraw() {
      circx[0].value = "" + rx;
      circy[0].value = "" + (center - ry);
      circx[1].value = "" + (rx + vtx);
      circy[1].value = "" + (center - ry - vty);
      circx[2].value = "" + vtx;
      circy[2].value = "" + (center - vty);
      pathd[0].value = "M 0.0," + center + " L " + rx + "," + (center-ry);
      pathd[1].value = ("M " + rx + "," + (center-ry) + " L " +
                        (rx+vtx) + "," + (center-ry-vty));
      pathd[2].value = ("M 0.0,"+center + " L "+vtx+","+(center-vty) +
                        " L "+(rx+vtx)+","+(center-ry-vty));
      pathd[3].value = ("M 0.0,"+center + " L "+rx+","+(center-ry) +
                        " L "+(rx+vtx)+","+(center-ry-vty) + "Z");
      pathd[4].value = ("M " + (rx-vtx) + "," + (center-ry+vty) + 
                        " L " + rx + "," + (center-ry));
      var r = sqrt(rx*rx + ry*ry);
      var x = rx / r;
      var y = ry / r;
      var v = sqrt(vtx*vtx + vty*vty);
      var vx = vtx / v;
      var vy = vty / v;
      textx[0].value = "" + (0.6*x + rx - 0.25);
      texty[0].value = "" + (-0.6*y + center - ry + 0.25);
      textx[1].value = "" + (0.6*vx + vtx + rx - 0.3);
      texty[1].value = "" + (-0.6*vy + center - vty - ry + 0.25);
      textx[2].value = "" + (0.8*vx + vtx - 0.3);
      texty[2].value = "" + (-0.8*vy + center - vty + 0.25);
      textx[3].value = "" + (-1.0*x+0.5*y + rx - 0.2);
      texty[3].value = "" + (1.0*y+0.5*x + center - ry + 0.2);
      textx[4].value = "" + (-1.1*vx+0.6*vy + vtx + rx - 0.5);
      texty[4].value = "" + (1.1*vy+0.6*vx + center - vty - ry + 0.2);
    }
    redraw();

    function start(index, coords) {
      if (index === 0) {  // P
        return [index, rx-coords.x, ry-center+coords.y];
      } else if (index === 1) {  // V
        return [index, rx+vtx-coords.x, ry+vty-center+coords.y];
      }
      return null;
    }

    function track(tracking, coords) {
      if (tracking === null) {
        return null;
      }
      // (x, y) position of P or V relative to (0,-center), where y>0 is up
      var x = coords.x + tracking[1];
      var y = center - coords.y + tracking[2];
      var xydot;
      if (vtx < -9.0 || vty - center < -5.0) {
        tracking = null;  // W off left or bottom edge
      } else if (tracking[0] === 0) {
        // P: (x, y-center)  V: (x+vtx, y+vty-center)  W: (vtx, vty-center)
        if (x > 9. || x+vtx < -9. || y+vty-center > 5. || y-center > 5.) {
          tracking = null;
        } else {
          // project (x-rx,y-ry) onto line PV
          xydot = ((x-rx)*vtx + (y-ry)*vty) / (vtx*vtx + vty*vty);
          rx += vtx*xydot;
          ry += vty*xydot;
        }
      } else {
        // P: (x-vtx, y-vty-center)  V: (x, y-center)  W: (vtx, vty-center)
        if (x-vtx > 9. || x < -9. || y-center > 5. || y-vty-center > 5.) {
          tracking = null;
        } else {
          // project (x-rx-vtx,y-ry-vty) onto line VW
          xydot = ((x-rx-vtx)*rx + (y-ry-vty)*ry) / (rx*rx + ry*ry);
          vtx += rx*xydot;
          vty += ry*xydot;
        }
      }
      if (tracking === null) {
        rx = rx0;
        ry = ry0;
        vtx = vtx0;
        vty = vty0;
      }
      redraw();
      return tracking;
    }

    function stop(tracking) {
      return;
    }

    add_trackers(fig4, f4handle, start, track, stop);
  }

  function fig5_interactions(evt) {
    var fig5 = evt.target;
    var f5handle = ["foco5", "pntq5"].map(get_element);
    var pntcx = f5handle.map(function(e)
                             {return e.getAttributeNodeNS(null, "cx");});
    var pntcy = f5handle.map(function(e)
                             {return e.getAttributeNodeNS(null, "cy");});
    var ellipse = get_element("ell5");
    var ellcx = ellipse.getAttributeNodeNS(null, "cx");
    var ellry = ellipse.getAttributeNodeNS(null, "ry");
    var circs = ["foco5", "pntp5", "pntq5"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});
    var paths = ["os5", "sq5", "oq5", "posu5", "posr5", "posv5",
                 "velu5", "velr5", "velv5", "velg5"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var xforms = ["inset5", "vplane5"].map(get_element);
    xforms = xforms.map(function(e)
                        {return e.getAttributeNodeNS(null, "transform");});
    var texts = ["txs5", "txo5", "txp5", "txq5"].map(get_element);
    var textx = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "x");});
    var texty = texts.map(function(e)
                          {return e.getAttributeNodeNS(null, "y");});
    var a = 5.0;  // fixed - do not change
    var c = 3.0;
    var xq = 0.0;
    var yq = 10.0;
    var xp = 0.0;
    var yp = 3.2;
    var vr = 3.2;  // coincidence, independent of initial yp
    var gmax = 2.4;
    var vx = -vr;
    var vy = 0.0;
    var vc = vr * c/a;
    var nhidden = true;

    function seto(x) {
      c = -0.5 * x;
      vc = vr * c/a;
      circx[0].value = "" + x;
      textx[1].value = "" + (x - 0.3);
      ellcx.value = "" + (-c);
      ellry.value = "" + sqrt(a*a - c*c);
      setq(xq, yq);
    }

    function setq(qx, qy) {
      var ychange = (yq < 0.) != (qy < 0.);
      var in4th = (yq < 0.) && (xq > 0.);
      xq = qx;  yq = qy;
      qx /= a;  qy /= a;
      var s = (2.*a - qx*c) / (qx*qx + yq*yq/(a*a - c*c));
      xp = s*qx;  yp = s*qy;
      qx *= 0.5;
      qy *= 0.5;
      vx = -qy * vr;
      vy = qx * vr;
      // perihelion is r=a-c, want g = gmax there
      var g = gmax * (a-c)**2 / (xp*xp + yp*yp);
      circx[1].value = "" + xp;  circy[1].value = "" + (-yp);
      circx[2].value = "" + xq;  circy[2].value = "" + (-yq);
      var mo = "M " + (-2.0*c) + ",0.0 L "
      pathd[0].value = mo + "0.0,0.0";
      pathd[1].value = "M 0.0,0.0 L " + xq + "," + (-yq);
      pathd[2].value = mo + xq + "," + (-yq);
      mo = "M 0.0," + vc + " L ";
      pathd[6].value = mo + "0.0,0.0";
      pathd[7].value = "M 0.0,0.0 L " + vx + "," + (-vy);
      pathd[8].value = mo + vx + "," + (-vy);
      pathd[9].value = ("M " + vx + "," + (-vy) + " L " +
                        (vx-qx*g) + "," + (-vy+qy*g));
      mo = "M " + xp + "," + (-yp) + " L ";
      pathd[3].value = mo + xp + "," + (-yp-vc);
      pathd[4].value = ("M " + xp + "," + (-yp-vc) + " L " +
                        (xp+vx) + "," + (-yp-vc-vy));
      pathd[5].value = mo + (xp+vx) + "," + (-yp-vc-vy);
      if (ychange) {
        if (yq >= 0.) {
          texty[0].value = texty[1].value = "0.9";
        } else {
          texty[0].value = texty[1].value = "-0.3";
        }
      }
      // compute Q letter position
      qx = sqrt(xq*xq + yq*yq);
      qy = yq / qx;
      qx = xq / qx;
      if (yq >= 0.0) {  // xprime=(qy,-qx) and yprime=(qx,qy)
        s = xq + 0.5*qy - 0.5*qx;
        qy = yq - 0.5*qx - 0.5*qy;
        qx = s;
      } else {
        s = xq - 0.5*qy - 0.5*qx;
        qy = yq + 0.5*qx - 0.5*qy;
        qx = s;
      }
      textx[3].value = "" + (qx-0.3);
      texty[3].value = "" + (0.3-qy);
      // compute P letter position
      qx = sqrt((2.*c+xp)**2 + yp**2);
      qy = yp / qx;
      qx = (2.*c+xp) / qx;
      qx = xp + 0.612*qx;
      qy = yp + 0.612*qy;
      textx[2].value = "" + (qx-0.25);
      texty[2].value = "" + (0.3-qy);
      // flip inset when Q in fourth quadrant
      if (in4th != ((yq < 0.) && (xq > 0.))) {
        if (in4th) {
          xforms[0].value = "rotate(0.0)";
          xforms[1].value = "translate(6.2,6.2)";
        } else {
          xforms[0].value = "rotate(-90.0)";
          xforms[1].value = "translate(6.2,-6.2)";
        }
      }
    }

    function fullreset() {
      xq = 0.0;  yq = 10.0;
      texty[0].value = texty[1].value = "0.9";
      xforms[0].value = "rotate(0.0)";
      xforms[1].value = "translate(6.2,6.2)";
      seto(-6.0);
    }

    function start(index, coords) {
      var dx = coords.x;
      var dy = coords.y;
      if (index === 0) {  // point O
        dx = -2.*c - dx;
      } else if (index === 1) {  // point Q
        dx = xq - dx;
        dy = yq + dy;
      }
      return [index, dx, dy];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var x = coords.x + tracking[1];
      var y = tracking[2] - coords.y;
      var twoa = a + a;
      var r;
      if (index === 0) {  // point O
        if (x > 0.2 || x < 0.4 - twoa) {
          fullreset();
          return null;
        }
        if (x > 0.0) {
          x = 0.0;
        }
        seto(x);
      } else if (index === 1) {  // point Q
        r = sqrt(x*x + y*y);
        if (r > 0.1) {
          x = twoa * x / r;
          y = twoa * y / r;
        }
        setq(x, y);
      }
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        if (tracking[0] === 2 && nhidden) {
          xn = 0.5*xq - c;
          yn = 0.5*yq;
        }
      }
      return;
    }

    add_trackers(fig5, f5handle, start, track, stop);
  }

  function fig7_interactions(evt) {
    var fig7 = evt.target;
    var f7handle = ["press7", "dots7", "doto7"].map(get_element);
    var ellipse = get_element("ell7");
    var ellry = ellipse.getAttributeNodeNS(null, "ry");
    var paths = ["posr7", "velv7", "posv7", "velg7",
                 "velc7", "velu7"].map(get_element);
    var pathd = paths.map(function(e)
                          {return e.getAttributeNodeNS(null, "d");});
    var circs = ["dotr7", "dotv7", "dots7", "doto7", "dotc7"].map(get_element);
    var circx = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cx");});
    var circy = circs.map(function(e)
                          {return e.getAttributeNodeNS(null, "cy");});

    var center = 5.0;
    var radius = 4.4;
    var a = radius;
    var b = 0.8 * a;
    var c = 0.6 * a;
    var dscale = 2.5 / radius;
    var xnow = 0.0;
    var ynow = 0.8 * radius;
    var u = radius * c/a;
    var vcx = -radius * b/a;
    var vcy = -u;
    var gscale = 2.5;
    var gnow = 0.16;
    var dt = 0.03;

    function reshape(cc) {
      c = cc;
      b = sqrt(a*a - c*c);
      u = radius * c/a;
      gnow = (a - c)**2 / ((xnow - c)**2 + ynow**2);
      ellry.value = "" + b;
      circx[2].value = "" + (c-center);
      circx[3].value = "" + (-c-center);
      circy[4].value = "" + u;
      pathd[5].value = "M " + center + "," + u + " L " + center + ",-0.00001";
    }

    function redraw(x, y) {
      var xn = sqrt((x-c)**2 + y**2);
      var yn = y / xn;
      xn = (x-c) / xn;
      xnow = x;
      ynow = y;
      vcx = -yn * radius;
      vcy = xn * radius;
      var g = gscale * gnow;
      circx[0].value = "" + (x - center);
      circy[0].value = "" + (-y);
      circx[1].value = "" + (center + vcx);
      circy[1].value = "" + (-vcy);
      pathd[0].value = "M " + (c-center) + ",0.0 L " + (x-center) + "," + (-y);
      pathd[1].value = "M "+center+","+u+" L "+(center+vcx)+","+(-vcy);
      pathd[2].value = ("M " + (x-center) + "," + (-y) + " l " +
                        (dscale*vcx) + "," + (-dscale*(vcy+u)));
      pathd[3].value = ("M " + (center + vcx) + "," + (-vcy) + " l " +
                        (-g*xn) + "," + (g*yn));
      pathd[4].value = "M " + center + ",0.0 L " + (center+vcx) + "," + (-vcy);
    }

    function stepper() {
      gnow = (a - c)**2 / ((xnow - c)**2 + ynow**2);
      var vx = vcx;
      var vy = vcy;
      vx = vcx - vcy*gnow*dt;
      vy = vcy + vcx*gnow*dt;
      var norm = radius / sqrt(vx*vx + vy*vy);
      vx *= norm;
      vy *= norm;
      var x = xnow + 0.5*(vx+vcx)*dt;
      var y = ynow + (0.5*(vy+vcy) + u)*dt;
      vcx = vx;
      vcy = vy;
      // adjust new point to lie exactly on ellipse
      norm = 1. / sqrt((x/a)**2 + (y/b)**2);
      x *= norm;
      y *= norm;
      redraw(x, y);
    }

    function start(index, coords) {
      var dx = null;
      if (index === 0) {
        dx = setInterval(stepper, 20);  // 50 frames/sec
      } else if (index === 1) {
        dx = coords.x + center - c;
      } else if (index === 2) {
        dx = coords.x + center + c;
      }
      return [index, dx];
    }

    function track(tracking, coords) {
      var cc = null;
      if (tracking !== null) {
        if (tracking[0] === 1) {
          cc = coords.x - tracking[1] + center;
        } else if (tracking[0] === 2) {
          cc = -(coords.x - tracking[1] + center);
        }
      }
      if (cc !== null) {
        if (cc > 0.9*radius || cc < -0.5) {
          cc = 0.6 * radius;
          tracking = null;
        } else if (cc < 0.0) {
          cc = 0.0;
        }
        reshape(cc);
        redraw(0.0, b);
      }
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        if (tracking[0] === 0) {
          clearInterval(tracking[1]);
        }
      }
      return;
    }

    add_trackers(fig7, f7handle, start, track, stop);
  }
</script>
</body>
</html>
