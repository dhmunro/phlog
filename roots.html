<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Roots of Unity</title>
  <meta name="description"
    content="Angles are powers of complex numbers on the unit circle.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>MathJax = {tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
          id="MathJax-script">
  </script>
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
      float: right;
    }
    .clickable {
      cursor: pointer;
    }
    .backlit {
      background-color: #d8d8d8;
    }
    svg {
      background-color: #ffffff;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .belowsvg {
      font: italic bold large serif;
      padding-top: 0px;
      margin-top: 0px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .svgtxt {
      font: bold 0.45px sans-serif;
    }
    .bselected {
      background-color: #80c0ff;
    }
    .dothot {
      stroke: none;
      fill: #0080ff;
      opacity: 1.0;
    }
    .dotnot {
      stroke: none;
      fill: black;
      opacity: 0.1;
    }
    .dotoff {
      display: none;
    }
    .linehot {
      stroke: #0080ff;
      fill: none;
      opacity: 0.6;
    }
    .linenot {
      stroke: black;
      fill: none;
      opacity: 0.1;
    }
    .buttondiv {
      margin-top: 0em;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      margin-bottom: 1em;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;"><a href="index.html">Roots of Unity</a></h1>

  <h2>Powers of complex numbers</h2>
  <p><a href="coords.html">We define</a> complex multiplication to
    scale and rotate coordinates in a plane.  This definition
    automatically includes a definition of raising any complex number
    $z$ to the power $p$ -- multiply $z$ by itself $p$ times.
    Multiplying two powers evidently adds the powers: $z^p z^q =
    z^{p+q}$.  We can use this rule to uniquely define the zero power
    and negative powers, so we know how to raise a number to any
    integer power: $z^0 = 1$ and $z^{-p} = 1/z^p$.  Lastly, raising a
    power to a power evidently multiplies the powers: $(z^p)^q =
    z^{pq}$.  Following the idea we used to define negative integer
    powers, we naturally want to use this relation to define
    fractional powers, for example $(z^{1/p})^p = z^1 = z$ defines
    $z^{1/p}$.  For complex $z$, this procedure hits an extremely
    interesting and fruitful snag, which we explore here.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-2.1 -2.1 4.2 4.2" onload="pow_interactions(evt)"
       stroke-width="0.03">
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.015"
          x1="-2.1" y1="0" x2="2.1" y2="0"/>
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.015"
          x1="0" y1="-2.1" x2="0" y2="2.1"/>
    <circle fill="none" stroke="#0080ff" opacity="0.3" stroke-width="0.015"
            cx="0" cy="0" r="1"/>
    <polyline fill="none" stroke="#0080ff" points="0,0, 1,0"/>
    <polyline id="parc" fill="none" stroke="black" opacity="0.3"
              points="1,0, 1.1,-0.2, 1.17,-0.44, 1.199,-0.718, 1.1753,-1.0296,
                      1.08691,-1.36762, 0.922077,-1.721764"/>
    <polyline id="pow6" fill="none" stroke="black" opacity="0.3"
              points="0,0, 0.922077,-1.721764"/>
    <polyline id="pow5" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.08691,-1.36762"/>
    <polyline id="pow4" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.1753,-1.0296"/>
    <polyline id="pow3" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.199,-0.718"/>
    <polyline id="pow2" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.17,-0.44"/>
    <polyline id="pow1" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.1,-0.2"/>
    <circle id="ppt6" fill="black" stroke="none" opacity="0.6"
            cx="0.922077" cy="-1.721764" r="0.06"/>
    <circle id="ppt5" fill="black" stroke="none" opacity="0.6"
            cx="1.08691" cy="-1.36762" r="0.06"/>
    <circle id="ppt4" fill="black" stroke="none" opacity="0.6"
            cx="1.1753" cy="-1.0296" r="0.06"/>
    <circle id="ppt3" fill="black" stroke="none" opacity="0.6"
            cx="1.199" cy="-0.718" r="0.06"/>
    <circle id="ppt2" fill="black" stroke="none" opacity="0.6"
            cx="1.17" cy="-0.44" r="0.06"/>
    <circle id="ppt1" fill="#ff8000" stroke="transparent" stroke-width="0.05"
            cx="1.1" cy="-0.2" r="0.06"/>  <!-- fat stroke easier to grab -->
  </svg></div>
  <p>The modulus of the product of any two complex numbers is the
    product of their moduli, and the argument of their product is the
    sum of their arguments.  Geometrically, this means that when you
    raise a complex number $z$ to successive powers by squaring it,
    cubing it, raising it to the fourth power, and so on, what you are
    doing is constructing a series of triangles the same shape as the
    one formed by the points $0$, $1$, and $z$, stacked onto each
    other as shown in the figure.  The orange dot is $z$, and the blue
    segment goes from $0$ to $1$.  The arc of gray points are $z^2$,
    $z^3$, $z^4$, $z^5$, and $z^6$.  You can drag the orange point $z$
    around to observe the pattern its powers make on the plane: An arc
    that spirals outward or inward according to whether $z$ is outside
    or inside the unit circle (of radius one centered at the origin).
    Examine what happens when $z$ lies on the unit circle or on the
    real (horizontal) or imaginary (vertical) axis.</p>
  <p>If the lovely arc of the powers of $z$ strikes your fancy, look
    up "logarithmic spiral" and you will find many people agree.</p>
</div>
<div class="textcolumn" style="clear: right;">

  <h2>Fractional powers</h2>
  <p>The case when $z$ lies on the unit circle richly rewards closer
    scrutiny.  All powers of any such $z$ also lie on the unit circle.
    In the figure below, you may select a power $p$ from two to six
    and explore how $z^p$ changes as you move $z$ around the unit
    circle.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-1.1 -1.1 2.2 2.2" onload="unit_interactions(evt)"
       stroke-width="0.015">
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
          x1="-2.1" y1="0" x2="2.1" y2="0"/>
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
          x1="0" y1="-2.1" x2="0" y2="2.1"/>
    <circle fill="none" stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
            cx="0" cy="0" r="1"/>
    <polyline fill="none" stroke="#0080ff" points="0,0, 1,0"/>
    <polyline id="uarc" fill="none" stroke="black" opacity="0.0"
              points="1,0, 0.983870,-0.178885, 0.936000,-0.352000,
                      0.857935,-0.513759, 0.752192,-0.658944,
                      0.622184,-0.782871, 0.472103,-0.881543"/>
    <polyline fill="none" stroke="#ff8000" points="1,0, 1.1,0"/>
    <polyline id="utk1" fill="none" stroke="#ff8000" display="block"
              points="0.5,0.866025, 0.55,0.952628"/>
    <polyline id="utk2" fill="none" stroke="#ff8000" display="block"
              points="-0.5,0.866025, -0.55,0.952628"/>
    <polyline id="utk3" fill="none" stroke="#ff8000" display="block"
              points="-1,0, -1.1,0"/>
    <polyline id="utk4" fill="none" stroke="#ff8000" display="block"
              points="-0.5,-0.866025, -0.55,-0.952628"/>
    <polyline id="utk5" fill="none" stroke="#ff8000" display="block"
              points="0.5,-0.866025, 0.55,-0.952628"/>
    <polyline id="uow6" class="linehot"
              points="0,0, 0.472103,-0.881543"/>
    <polyline id="uow5" class="linenot"
              points="0,0, 0.622184,-0.782871"/>
    <polyline id="uow4" class="linenot"
              points="0,0, 0.752192,-0.658944"/>
    <polyline id="uow3" class="linenot"
              points="0,0, 0.857935,-0.513759"/>
    <polyline id="uow2" class="linenot"
              points="0,0, 0.936000,-0.352000"/>
    <polyline id="uow1" fill="none" stroke="#ff8000" opacity="0.6"
              points="0,0, 0.983870,-0.178885"/>
    <circle id="upt6" class="dothot"
            cx="0.472103" cy="-0.881543" r="0.034"/>
    <circle id="upt5" class="dotnot"
            cx="0.622184" cy="-0.782871" r="0.034"/>
    <circle id="upt4" class="dotnot"
            cx="0.752192" cy="-0.658944" r="0.034"/>
    <circle id="upt3" class="dotnot"
            cx="0.857935" cy="-0.513759" r="0.034"/>
    <circle id="upt2" class="dotnot"
            cx="0.936000" cy="-0.352000" r="0.034"/>
    <circle id="upt1" fill="#ff8000" stroke="transparent" stroke-width="0.025"
            cx="0.983870" cy="-0.178885" r="0.034"/>
  </svg>
    <div class="buttondiv">
    <br/>Choose power: 
    <button id="ubut2" type="button" class=""><b>2</b></button>
    <button id="ubut3" type="button" class=""><b>3</b></button>
    <button id="ubut4" type="button" class=""><b>4</b></button>
    <button id="ubut5" type="button" class=""><b>5</b></button>
    <button id="ubut6" type="button" class="bselected"><b>6</b></button>
    </div>
  </div>
  <p>When you drag the orange point $z$ once around the circle, the
    blue point $z^p$ to orbits $p$ times.  Thus there are $p$ values
    of $z$ for which $z^p = 1$, marked by the orange ticks around the
    perimeter of the unit circle.  Since the angles between successive
    powers are equal, these $p$ points are equally spaced around the
    unit circle, forming a regular $p$-gon.  Each of these $p$ points
    is a $p$-th root of $1$.  We see that the fact that two real
    numbers ($+1$ and $-1$) which square to give one is a special case
    of the general rule that there are $p$ complex numbers with a
    $p$-th power of one.  These "$p$-th roots of unity" are equally
    spaced around the unit circle.</p>
  <p>In standard mathematical notation, $1^{1/p} = 1$ for all $p$ --
    the most boring choice is the most convenient and consistent for
    many purposes.  But fractional powers are ambiguous, and in the
    case of roots of one, we can make a far more useful choice: On
    this page, let's write $1^{1/p}$ for the first
    <em>interesting</em> $p$-th root of unity.  The other $p$-th roots
    are then $1^{2/p}$, $1^{3/p}$, $1^{4/p}$, and so on up to $1^{p/p}
    = 1$.  Still higher powers hop counterclockwise around the circle
    again, looping back to $1$ at every multiple of $p$; negative
    powers loop clockwise.  By our definition, powers of $1^{1/p}$ are
    clock arithmetic.</p>
  <p>Thus by defining $1^{1/p}$, we have in fact defined $1^\alpha$
    for all rational numbers $\alpha=n/p$, and by continuity for all
    real numbers $\alpha$.  Namely, $1^\alpha$ is the complex number
    which lies $\alpha$ clockwise revolutions around the unit circle
    starting from the point $1$, including fractions of a revolution.
    That is, an angle in units of revolutions (often called cycles) is
    a power of $1$.  In trigonometry, the $x$ and $y$ coordinates of a
    point on the unit circle as functions of angle from the $x$-axis
    are called cosine and sine, respectively, so by our definition

    $$1^\alpha = \cos\alpha + i\sin\alpha.$$

    Sine and cosine are available on many calculators and in any math
    library.  However, note that our angle $\alpha$ is in units of
    revolutions, so you will usually need to multiply it by either
    $360$ to convert to degrees or by $2\pi$ to convert to radians
    before invoking a library function.</p>

  <h2>Computing the trigonometric functions</h2>
  <p>This formula maps fractional powers $1^\alpha$ to the points on
    the unit circle and hence to the sine and cosine functions is
    lovely, but we still need to figure out how to compute both
    $\cos\alpha$ and $\sin\alpha$ given $\alpha$, and $\alpha$ given
    the coordinates of a point on the unit circle.  We do know values
    for a handful of fractions $\alpha$, and by raising these to
    powers we can get their multiples.  The half and quarter
    revolutions $1^{1/2}=-1$ and $1^{1/4}=i$ are obvious.
    Additionally, the angles associated with regular pentagons,
    hexagons, and octagons are mainstays of elementary geometry:

    $$\begin{eqnarray*}
    1^{1/5} &=& \left.\left(\sqrt{5}-1 + i\sqrt{10+2\sqrt{5}}\right)
                \middle/ 4 \right. \\
    1^{1/6} &=& (1 + i\sqrt{3}) / 2 \\
    1^{1/8} &=& (1 + i) / \sqrt{2} \\
    \end{eqnarray*}$$

    (The more complicated pentagon formula doesn't get much love these
    days, but the ancient Greeks were enamored because of its
    connection to the golden ratio.)
  </p>
  <p>Complex multiplication (division) gets us beyond this handful
    of known values by allowing us to add (subtract) any pair of known
    angles.  The formula for adding angles is exactly the same as for
    multiplying two complex numbers:

    $$\begin{eqnarray*}
    1^{(\alpha+\beta)} &=& 1^\alpha 1^\beta \\
    \cos(\alpha+\beta) + i\sin(\alpha+\beta)
    &=& (\cos\alpha + i\sin\alpha)(\cos\beta + i\sin\beta)
    \end{eqnarray*}$$
    $$\quad\quad = (\cos\alpha\cos\beta - \sin\alpha\sin\beta)
    + i(\sin\alpha\cos\beta + \cos\alpha\sin\beta)$$

    To subtract angles, just reverse the sign of $\beta$ of the left
    side and $\sin\beta$ on the right side.  (The reciprocal of a
    complex number on the unit circle is its complex conjugate.)
    Unfortunately, these operations can only give us values for
    rational $\alpha$ which are multiples of the least common
    denominator of whatever angles we already know.  So if we start
    with $1/5$, $1/6$, and $1/8$, we can find any multiple of $1/120$
    or $3$ degrees.  For example, $1/5-1/6=1/30$ then
    $4/30-1/8=1/120$, or in degrees $72-60=12$ then $4\times 12-45=3$.
  </p>
  <p>
    More important are the half-angle formulas, which follow from
    the fact that the diagonal of the rhombus formed by the points
    $1^\alpha$, $0$, $1$, and $1+1^\alpha$ bisects angle $\alpha$.
    Algebraically, $1^\alpha||1+1^\alpha||^2 = (1+1^\alpha)^2$, so

    $$\begin{eqnarray*}
    1^{\alpha/2} &=& (1+1^\alpha) / ||1 + 1^\alpha|| \\
    &=& (1+\cos\alpha + i\sin\alpha) / \sqrt{2+2\cos\alpha} \\
    &=& \sqrt{(1+\cos\alpha)/2} + i\sqrt{(1-\cos\alpha)/2},
    \end{eqnarray*}$$

    where $||z||$ means the modulus of $z$, and we have used the fact
    that $||1^\alpha|| = \cos^2\alpha + \sin^2\alpha = 1$.</p>
  <p>Using the half-angle formula, we can compute the sine and cosine
    of $1/2^n$ revolutions for any $n$, and using the sum formulas we
    can recombine them to find the sine and cosine of any terminating
    binary fraction of a revolution.  This is how people computed the
    earliest tables of sines and cosines, although usually such
    calculations began by bisecting the $30$ degree half angle of an
    equilateral triangle rather than a $90$ degree quarter
    revolution.</p>
  <p>Note that there are simple formulas for $1^{1/p}$ for $p$ equal
    to $2$, $3$, $4$, $5$, $6$, and $8$.  The ancient Greeks were
    inordinately fond of the $p=5$ case, which involves the Golden
    ratio.</p>

  <h2>Relation to Euler's formula</h2>
  <p>You probably won't see this definition of the complex valued
    function $1^\alpha$ anywhere else.  The standard way to express
    the same idea is Euler's formula:

    $$e^{i\theta} = \cos\theta + i\sin\theta.$$

    Here, $\theta$ is in units of radians, and the meaning of both the
    real number $e$ and the meaning of raising a number to an
    imaginary power require a long discussion which, though brilliant
    and important, has nothing to do with the connection between
    trigonometry and powers of complex numbers.  Since $\theta=2\pi$
    equals one revolution, Euler writes

    $$e^{i2\pi} = 1,$$

    which shows how to get back and forth between our notation and the
    standard notation introduced by Euler: Just substitute $e^{i2\pi}$
    for $1$ as the base for the exponential, and remember to convert
    angles elsewhere from units of revolutions to units of
    radians:

    $$1^\alpha = e^{i2\pi\alpha} = \cos\alpha + i\sin\alpha.$$

  </p>
  <p>Our definition of $1^\alpha$ shows how powers of complex numbers
    relate to sines and cosines without needing to explain imaginary
    exponents.</p>
</div>
<script>
  var tracking = null;

  function add_trackers(svg, targets, start, track, stop) {
    // svg = svg element
    // targets = array of elements in svg to listen for mouse down events
    // start(index, coords) --> tracking (or null to abort)
    //   index = index into targets
    //   coords = event coordinates in svg coordinate system
    // track(tracking, coords) --> tracking (or null to abort)
    //   tracking = returned by start
    //   coords = event coordinates in svg coordinate system
    // stop(tracking)
    //   tracking = returned by start

    function svgcoords(evt) {  // return event coordinates
      var CTM = svg.getScreenCTM();
      if (evt.touches) {
        evt = evt.touches[0];
      }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    function wrapstart(evt) {
      if (tracking !== null) {
        wrapstop(evt);
      }
      var t = evt.target;
      var index = targets.indexOf(t);
      if (index < 0) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = start(index, svgcoords(evt));
    }

    function wraptrack(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = track(tracking, svgcoords(evt));
    }

    function wrapstop(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      stop(tracking);
      tracking = null;
    }

    svg.addEventListener("mousedown", wrapstart);
    svg.addEventListener("mousemove", wraptrack);
    svg.addEventListener("mouseup", wrapstop);
    svg.addEventListener("mouseleave", wrapstop);
    svg.addEventListener("touchstart", wrapstart);
    svg.addEventListener("touchmove", wraptrack);
    svg.addEventListener("touchend", wrapstop);
    svg.addEventListener("touchcancel", wrapstop);
  }

  function get_element(id) {
    return document.getElementById(id);
  }

  var round = Math.round;
  var abs = Math.abs;
  var sqrt = Math.sqrt;

  function pow_interactions(evt) {
    var power = evt.target;
    var handle = ["ppt1"].map(get_element);
    var apts = get_element("parc").getAttributeNodeNS(null, "points");
    var pws = ["pow1","pow2","pow3","pow4","pow5","pow6"].map(get_element);
    var pts = ["ppt1","ppt2","ppt3","ppt4","ppt5","ppt6"].map(get_element);
    var pxy = pws.map(function(e)
                      {return e.getAttributeNodeNS(null, "points");});
    var cxy = pts.map(function(e) { return [
      e.getAttributeNodeNS(null, "cx"), e.getAttributeNodeNS(null, "cy")];});
    var xnow = 1.1;
    var ynow = -0.2;  // that is, 1.1+i0.2 since svg plots y downward

    function start(index, coords) {
      return [coords.x - xnow, coords.y - ynow];
    }

    function track(tracking, coords) {
      xnow = coords.x - tracking[0];
      ynow = coords.y - tracking[1];
      if (xnow*xnow + ynow*ynow > 4.0) {
        xnow = 1.1;
        ynow = -0.2;
      }
      var x = xnow;
      var y = ynow;
      var points = "1,0";
      var i, xq, yq, xyq, xx;
      for (i=0 ; i<6 ; i+=1) {
        xq = "" + x;  yq = "" + y;
        xyq = ", " + xq + "," + yq;
        points += xyq;
        pxy[i].value = "0,0" + xyq;
        cxy[i][0].value = xq;  cxy[i][1].value = yq;
        xx = x;
        x = x*xnow - y*ynow;  y = xx*ynow + y*xnow;  // (x, y) *= (xnow, ynow)
      }
      apts.value = points;
      return tracking;
    }
    
    function stop(tracking) {
      return;
    }

    add_trackers(power, handle, start, track, stop);
  }

  function classof(elem) {
    return elem.getAttributeNodeNS(null, "class");
  }

  function unit_interactions(evt) {
    var unit = evt.target;
    var handle = ["upt1"].map(get_element);
    var apts = get_element("uarc").getAttributeNodeNS(null, "points");
    var tks = ["utk1","utk2","utk3","utk4","utk5"].map(get_element);
    var pws = ["uow1","uow2","uow3","uow4","uow5","uow6"].map(get_element);
    var pts = ["upt1","upt2","upt3","upt4","upt5","upt6"].map(get_element);
    var pxy = pws.map(function(e){return e.getAttributeNodeNS(null,"points")});
    var cxy = pts.map(function(e) { return [
      e.getAttributeNodeNS(null, "cx"), e.getAttributeNodeNS(null, "cy")];});
    var xnow = 1.1;
    var ynow = -0.2;  // that is, 1.1+i0.2 since svg plots y downward

    var power = 6;
    var buts = ["ubut2", "ubut3", "ubut4", "ubut5", "ubut6"].map(get_element);
    var butcl = buts.map(classof);
    var pwcl = pws.map(classof);
    var ptcl = pts.map(classof);
    var tkd = tks.map(function(e){return e.getAttributeNodeNS(null,"display")});
    var tkp = tks.map(function(e){return e.getAttributeNodeNS(null,"points")});
    // table of cosines and sines of 2pi/p for p=2, 3, 4, 5, 6
    var ctk = [-1.0, -0.5, 0.0, 0.309017, 0.5];
    var stk = [0.0, 0.866025, 1.0, 0.951057, 0.866025];

    function power_select(evt) {
      var but = evt.currentTarget;
      var old_power = power;
      var n = buts.indexOf(but)
      var i;
      power = n + 2;
      if (power < 2 || power > 7) {
        power = 6;
        but = buts[4];
      }
      if (power != old_power) {
        butcl[old_power-2].value = "";
        n = power - 1;
        butcl[power-2].value = "bselected";
        for (i=1 ; i<n ; i+=1) {
          pwcl[i].value = "linenot";
          ptcl[i].value = "dotnot";
        }
        if (n) {
          pwcl[n].value = "linehot";
          ptcl[n].value = "dothot";
        }
        for (i=n+1 ; i<6 ; i+=1) {
          pwcl[i].value = ptcl[i].value = "dotoff";
        }
        var c = ctk[power-2];
        var s = stk[power-2];
        var x = 1.0;
        var y = 0.0;
        var xx;
        for (i=0 ; i<5 ; i+=1) {
          tkd[i].value = (i <= n)? "block" : "none";
          if (i > n) {
            continue;
          }
          xx = x;
          x = x*c - y*s;
          y = xx*s + y*c;
          tkp[i].value = x + "," + y + ", " + (1.1*x) + "," + (1.1*y);
        }
      }
    }
    buts.map(function(e) {e.addEventListener("click", power_select);});

    function start(index, coords) {
      return [coords.x - xnow, coords.y - ynow];
    }

    function track(tracking, coords) {
      xnow = coords.x - tracking[0];
      ynow = coords.y - tracking[1];
      var r = sqrt(xnow*xnow + ynow*ynow);
      if (r > 1.2 || r < 0.1) {
        xnow = 0.983870;
        ynow = -0.178885;
        r = 1.0;
      } else {
        xnow /= r;
        ynow /= r;
      }
      var x = xnow;
      var y = ynow;
      var points = "1,0";
      var i, xq, yq, xyq, xx;
      for (i=0 ; i<6 ; i+=1) {
        xq = "" + x;  yq = "" + y;
        xyq = ", " + xq + "," + yq;
        points += xyq;
        pxy[i].value = "0,0" + xyq;
        cxy[i][0].value = xq;  cxy[i][1].value = yq;
        xx = x;
        x = x*xnow - y*ynow;  y = xx*ynow + y*xnow;  // (x, y) *= (xnow, ynow)
      }
      apts.value = points;
      return tracking;
    }
    
    function stop(tracking) {
      return;
    }

    add_trackers(unit, handle, start, track, stop);
  }
</script>
</body>
</html>
