<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Roots of Unity</title>
  <meta name="description"
    content="Angles are powers of complex numbers on the unit circle.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>MathJax = {tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
          id="MathJax-script">
  </script>
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
      float: right;
    }
    .clickable {
      cursor: pointer;
    }
    .backlit {
      background-color: #d8d8d8;
    }
    svg {
      background-color: #ffffff;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .belowsvg {
      font: italic bold large serif;
      padding-top: 0px;
      margin-top: 0px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .svgtxt {
      font: bold 0.45px sans-serif;
    }
    .bselected {
      background-color: #80c0ff;
    }
    .dothot {
      stroke: none;
      fill: #0080ff;
      opacity: 1.0;
    }
    .dotnot {
      stroke: none;
      fill: black;
      opacity: 0.1;
    }
    .dotoff {
      display: none;
    }
    .linehot {
      stroke: #0080ff;
      fill: none;
      opacity: 0.6;
    }
    .linenot {
      stroke: black;
      fill: none;
      opacity: 0.1;
    }
    .buttondiv {
      margin-top: 0em;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      margin-bottom: 1em;
    }
    .svgtxt {
        font: bold 0.2px sans-serif;
        fill: black;
        stroke: none;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;"><a href="index.html">Roots of Unity</a></h1>

  <h2>Powers of complex numbers</h2>
  <p>Raising a number $z$ to the power $p$ means multiplying $z$ by
    itself $p$ times, so multiplying two powers evidently adds the
    powers: $z^p z^q = z^{p+q}.$ This relationship uniquely defines
    the meaning of raising $z$ to the $0$ power or to a negative
    power: We must have $z^0 = 1$ and $z^{-p} = 1/z^p$ in order to
    preserve the rule that multiplying powers adds the powers.  Thus
    we know the meaning of any integer power $p$, positive or
    negative.</p>
  <p>Continuing in this way, raising a power to a power evidently
    multiplies the powers: $(z^p)^q = z^{pq},$ which we naturally hope
    to use to define any rational power by $(z^{p/q})^q = z^p.$ Unlike
    non-positive integer powers, however, this attempt hits a snag,
    which textbooks often gloss over little comment.  When $z$ is a
    real number (on a number line) the snag is subtle: For even
    denominators $q$, the sign of $z^{p/q}$ is ambiguous (there is a
    plus and a minus square root for example), and the definition
    doesn't work at all when $z\lt 0.$ We can sweep away the whole
    problem by simply declaring that both $z$ and all its non-integer
    powers $z^p$ only exist for positive $z$.  This step is imminently
    practical, but not as tidy as we like math to be.</p>
  <p>Arguably, complex numbers are interesting precisely because they
    clean up the meaning of raising a number to a fractional power;
    when $z$ is complex, the restrictions on the values of $z^p$
    disappear.  Because <a href="coords.html">complex
    multiplication</a> rotates coordinates in a plane in addition to
    simply scaling them up and down (like ordinary multiplication), in
    the complex plane multiplication by a negative number becomes
    rotation by $180^\circ$, part of a smooth progression of
    rotations.  However, in the complex plane, the ambiguity of a
    fractional power $z^p$ becomes impossible to sweep under the rug,
    and gives us multiple viable choices for what we mean by $z^p$
    when $p$ is not an integer.  (When $p$ is an integer all
    definitions agree on a unique result.)  Here we embrace the
    ambiguity by showing how a non-standard choice can be useful.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-2.2 -2.1 4.3 4.2" onload="pow_interactions(evt)"
       stroke-width="0.03">
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.015"
          x1="-2.1" y1="0" x2="2.1" y2="0"/>
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.015"
          x1="0" y1="-2.1" x2="0" y2="2.1"/>
    <circle fill="none" stroke="#0080ff" opacity="0.3" stroke-width="0.015"
            cx="0" cy="0" r="1"/>
    <polyline fill="none" stroke="#0080ff" points="0,0, 1,0"/>
    <polyline id="parc" fill="none" stroke="black" opacity="0.3"
              points="1,0, 1.1,-0.2, 1.17,-0.44, 1.199,-0.718, 1.1753,-1.0296,
                      1.08691,-1.36762, 0.922077,-1.721764"/>
    <polyline id="pow6" fill="none" stroke="black" opacity="0.3"
              points="0,0, 0.922077,-1.721764"/>
    <polyline id="pow5" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.08691,-1.36762"/>
    <polyline id="pow4" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.1753,-1.0296"/>
    <polyline id="pow3" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.199,-0.718"/>
    <polyline id="pow2" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.17,-0.44"/>
    <polyline id="pow1" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.1,-0.2"/>
    <circle id="ppt6" fill="black" stroke="none" opacity="0.6"
            cx="0.922077" cy="-1.721764" r="0.06"/>
    <circle id="ppt5" fill="black" stroke="none" opacity="0.6"
            cx="1.08691" cy="-1.36762" r="0.06"/>
    <circle id="ppt4" fill="black" stroke="none" opacity="0.6"
            cx="1.1753" cy="-1.0296" r="0.06"/>
    <circle id="ppt3" fill="black" stroke="none" opacity="0.6"
            cx="1.199" cy="-0.718" r="0.06"/>
    <circle id="ppt2" fill="black" stroke="none" opacity="0.6"
            cx="1.17" cy="-0.44" r="0.06"/>
    <circle id="ppt1" fill="#ff8000" stroke="transparent" stroke-width="0.05"
            cx="1.1" cy="-0.2" r="0.06"/>  <!-- fat stroke easier to grab -->
  </svg></div>
  <p>The modulus of the product of any two complex numbers is the
    product of their moduli, and the argument of their product is the
    sum of their arguments.  Geometrically, this means that when you
    raise a complex number $z$ to successive powers by squaring it,
    cubing it, raising it to the fourth power, and so on, what you are
    doing is constructing a series of triangles the same shape as the
    one formed by the points $0$, $1$, and $z$, stacked onto each
    other as shown in the figure.  The orange dot is $z$, and the blue
    segment goes from $0$ to $1$.  The gray dots are $z^2$, $z^3$,
    $z^4$, $z^5$, and $z^6$.  You can drag the orange point $z$ around
    to observe the pattern its powers make on the plane: An arc that
    spirals outward or inward according to whether $z$ is outside or
    inside the unit circle (of radius one centered at the origin).
    Examine what happens when $z$ lies on the unit circle or on the
    real (horizontal) or imaginary (vertical) axis.</p>
  <p>If the lovely arc of the powers of $z$ strikes your fancy, look
    up "logarithmic spiral" and you will find many people agree.
    We'll learn a lot more about these curves by the end of this page.
  </p>
</div>
<div class="textcolumn" style="clear: right;">

  <h2>Fractional powers</h2>
  <p>Let's take a closer look at the case when $z$ lies on the unit
    circle.  All powers of any such $z$ also lie on the unit circle.
    In the figure below, you may select a power $p$ from two to six
    and explore how $z^p$ changes as you move $z$ around the unit
    circle.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-1.15 -1.1 2.25 2.2" onload="unit_interactions(evt)"
       stroke-width="0.015">
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
          x1="-1.1" y1="0" x2="1.1" y2="0"/>
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
          x1="0" y1="-1.1" x2="0" y2="1.1"/>
    <circle fill="none" stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
            cx="0" cy="0" r="1"/>
    <polyline fill="none" stroke="#0080ff" points="0,0, 1,0"/>
    <polyline id="uarc" fill="none" stroke="black" opacity="0.0"
              points="1,0, 0.983870,-0.178885, 0.936000,-0.352000,
                      0.857935,-0.513759, 0.752192,-0.658944,
                      0.622184,-0.782871, 0.472103,-0.881543"/>
    <polyline fill="none" stroke="#ff8000" points="1,0, 1.1,0"/>
    <polyline id="utk1" fill="none" stroke="#ff8000" display="block"
              points="0.5,0.866025, 0.55,0.952628"/>
    <polyline id="utk2" fill="none" stroke="#ff8000" display="block"
              points="-0.5,0.866025, -0.55,0.952628"/>
    <polyline id="utk3" fill="none" stroke="#ff8000" display="block"
              points="-1,0, -1.1,0"/>
    <polyline id="utk4" fill="none" stroke="#ff8000" display="block"
              points="-0.5,-0.866025, -0.55,-0.952628"/>
    <polyline id="utk5" fill="none" stroke="#ff8000" display="block"
              points="0.5,-0.866025, 0.55,-0.952628"/>
    <polyline id="uow6" class="linehot"
              points="0,0, 0.472103,-0.881543"/>
    <polyline id="uow5" class="linenot"
              points="0,0, 0.622184,-0.782871"/>
    <polyline id="uow4" class="linenot"
              points="0,0, 0.752192,-0.658944"/>
    <polyline id="uow3" class="linenot"
              points="0,0, 0.857935,-0.513759"/>
    <polyline id="uow2" class="linenot"
              points="0,0, 0.936000,-0.352000"/>
    <polyline id="uow1" fill="none" stroke="#ff8000" opacity="0.6"
              points="0,0, 0.983870,-0.178885"/>
    <circle id="upt6" class="dothot"
            cx="0.472103" cy="-0.881543" r="0.034"/>
    <circle id="upt5" class="dotnot"
            cx="0.622184" cy="-0.782871" r="0.034"/>
    <circle id="upt4" class="dotnot"
            cx="0.752192" cy="-0.658944" r="0.034"/>
    <circle id="upt3" class="dotnot"
            cx="0.857935" cy="-0.513759" r="0.034"/>
    <circle id="upt2" class="dotnot"
            cx="0.936000" cy="-0.352000" r="0.034"/>
    <circle id="upt1" fill="#ff8000" stroke="transparent" stroke-width="0.025"
            cx="0.983870" cy="-0.178885" r="0.034"/>
  </svg>
    <div class="buttondiv">
    <br/>Choose power: 
    <button id="ubut2" type="button" class=""><b>2</b></button>
    <button id="ubut3" type="button" class=""><b>3</b></button>
    <button id="ubut4" type="button" class=""><b>4</b></button>
    <button id="ubut5" type="button" class=""><b>5</b></button>
    <button id="ubut6" type="button" class="bselected"><b>6</b></button>
    </div>
  </div>
  <p>When you drag the orange point $z$ once around the circle, the
    blue point $z^p$ to orbits $p$ times.  Thus there are $p$ values
    of $z$ for which $z^p = 1$, marked by the orange ticks around the
    perimeter of the unit circle.  Since the angles between successive
    powers are equal, these $p$ points are equally spaced around the
    unit circle, forming a regular $p$-gon with one corner at the
    point $1$.  Each of these $p$ points is a $p$-th root of $1$, also
    called a $p$-th root of unity.  We see that the fact that two real
    numbers ($+1$ and $-1$) whose squares are one is a special case of
    the general rule that there are $p$ complex numbers with a $p$-th
    power of one.</p>
  <p>In standard mathematical notation, $1^{1/p} = 1$ for all $p$ --
    the most boring choice is the most convenient and consistent for
    many purposes.  But fractional powers are ambiguous, and in the
    case of roots of one, we can make a far more useful choice: On
    this page, let's write $1^{1/p}$ for the first
    <em>interesting</em> $p$-th root of unity - the nearest to $1$ as
    we go counterclockwise around the unit circle.  The other $p$-th
    roots are then $1^{2/p}$, $1^{3/p}$, $1^{4/p}$, and so on up to
    $1^{p/p} = 1.$ Powers greater than $p$ hop counterclockwise around
    the circle again, looping back to $1$ at every multiple of $p$;
    negative powers loop clockwise.</p>
  <p>Thus by defining $1^{1/p}$, we have in fact defined $1^\alpha$
    for all rational numbers $\alpha=n/p$, and by continuity for all
    real numbers $\alpha$.  Namely, $1^\alpha$ is the complex number
    which lies $\alpha$ counterclockwise revolutions around the unit
    circle starting from the point $1$, including fractions of a
    revolution.  That is, an angle in units of revolutions (often
    called cycles) is a power of $1$ in the complex plane.</p>
  <p>In trigonometry, the $x$ and $y$ coordinates of a point on the
    unit circle as functions of angle from the $x$-axis are called
    cosine and sine, respectively, so by our definition

    $$1^\alpha = \cos\alpha + i\sin\alpha.$$

    Sine and cosine are available on many calculators and in any math
    library.  However, note that our angle $\alpha$ is in units of
    revolutions, so you will usually need to multiply it by either
    $360$ to convert to degrees or by $2\pi$ to convert to radians
    before invoking a library function.  Before computers, every
    scientist and engineer owned tables of sines (and several other
    functions) covering dozens of pages with numbers; they're
    important but not easy to calculate.  But now we can.</p>

  <h2>Trigonometry, briefly</h2>
  <p>The identity of angles with powers of $1$ makes it easy to derive
    all of the trigonometric identities from complex multiplication.
    The most important are the angle addition formulas, which we now
    recognize as nothing more than complex multiplication:

    $$\begin{align*}
    1^{(\alpha+\beta)} &= 1^\alpha 1^\beta \\
    \cos(\alpha+\beta) + i\sin(\alpha+\beta)
    &= (\cos\alpha + i\sin\alpha)(\cos\beta + i\sin\beta)
    \end{align*}$$
    $$\quad\quad = (\cos\alpha\cos\beta - \sin\alpha\sin\beta)
    + i(\sin\alpha\cos\beta + \cos\alpha\sin\beta)$$

    The real parts are the cosine sum formula; the imaginary parts the
    sine sum formula.  The formulas for the difference of angles
    $\alpha-\beta$ are the same but with the signs of $\sin\beta$
    reversed:

    $$1^{-\beta} = 1/1^\beta = \overline{1^\beta}$$

    where $\overline{z}$ means the complex conjugate of $z,$ that is,
    the number with equal and opposite imaginary part.  Trigonometry
    teachers delight in torturing students with endless variants of
    this single idea, that complex multiplication marches around the
    unit circle.
  </p>
  <p>Finally, if we want to build tables of values of the sine
    function, we need to be able to subdivide angles into smaller
    parts.  To compute smaller angles, we can use the fact that the
    diagonal of the rhombus formed by the points $1^\alpha,$ $0,$ $1,$
    and $1+1^\alpha$ bisects angle $\alpha$.  To translate this
    geometric fact into algebra, first write
    $||z||=\sqrt{\overline{z}z}$ for the modulus of $z.$ Next, notice
    that

    $$1^\alpha||1+1^\alpha||^2 = 1^\alpha(1+1^{-\alpha})(1+1^\alpha) =
    (1+1^\alpha)^2,$$

    which implies

    $$\begin{align*}
    1^{\alpha/2} &= (1+1^\alpha) / ||1 + 1^\alpha|| \\
    \cos(\alpha/2) + i\sin(\alpha/2)
      &= (1+\cos\alpha + i\sin\alpha) / \sqrt{2+2\cos\alpha}.
    \end{align*}$$
  </p>
  <p>This half angle formula would suffice for building sine tables.
    However, if you want a challenge and know a little calculus, work
    out the equations you need to solve in order to subdivide an angle
    into three or five parts, by writing out the binomial expansion of
    $1^{3\alpha}$ and $1^{5\alpha}.$ The imaginary parts produce third
    and fifth degree polynomials, respectively, which you can very
    efficiently solve by Newton iteration (the guess-divide-average
    algorithm in the case of square roots) to get $\sin(\alpha/3)$ or
    $\sin(\alpha/5)$ given only $\sin\alpha$.  Note that if you can
    divide an angle in half and into fifths, you can divide it into
    tenths, which is an interesting capability if you want to build a
    sine table.  Dividing by three comes in handy if you work with
    angles in degrees, minutes, and seconds.  There are also nice
    Newton iterations for versine, $\text{ver }\alpha=1-\cos\alpha$
    for the half-angle or quarter angle, if you want to avoid the
    square root in the non-iterative half-angle formula.  The real
    part of $1^{n\alpha}$ gives a nice iteration for
    $\text{ver}(\alpha/n)$ for even $n$, while the imaginary part
    produces a nice iteration for $\sin(\alpha/n)$ for odd $n$.</p>
  <p>It is impossible to overstate the importance of the relationship
    between the complex powers $1^\alpha$ and the trigonometric
    functions $\cos\alpha$ and $\sin\alpha$.  Working with a power law
    is just far simpler than working with raw sines and cosines.
    Practical fields from signal processing to quantum mechanics rely
    heavily on the fact that the complex roots of unity and their
    powers orbit smoothly around the unit circle.  We have approached
    this relationship from the opposite direction of current
    textbooks, and invented a notation $1^\alpha$ you won't see
    anywhere else.  It's time to close the loop by demonstrating how
    our approach relates to the textbook approach.</p>

  <h2>Analytic continuation</h2>
  <p>We've worked our way from powers which are counting numbers, to
    zero or negative integer powers, to rational powers, until finally
    we have a useful definition of a complex value for $1^x$ for any
    real number $x$.  So now the burning question becomes, how can we
    define $1^z$ for any complex number $z$ in a useful and consistent
    way?  The general method for extending a partially defined
    function to cover the whole complex plane is called analytic
    continuation - a cornerstone of the theory of analytic functions
    (smooth functions of a complex number that return a value which is
    also a complex number).</p>
  <p>The simplest case of analytic continuation is complex
    multiplication.  Just as raising to a power begins with the idea
    that a power is repeated multiplication, the basic idea behind
    multiplication is repeated addition.  For powers of a number $a$,
    we decided to preserve the property that $a^xa^y=a^{x+y}.$ For
    multiplication, the property we want to preserve is the
    distributive law, $ax+ay=a(x+y)$, and it leads us through the same
    progression - from counting numbers $x$ being repeated addition of
    $a$ to itself, to multiplying by zero or negative $x$, and finally
    to multiplying by any rational fraction $x$, all defined uniquely
    by the requirement that the distributive law continue to apply.</p>
  <p>This whole chain of reasoning works for any complex value of $a$
    (once we've defined complex addition), but we still have only
    defined how to multiply a complex number $a$ by a real number $x$.
    We now want to broaden this definition to cover the product $az$
    for any complex $z=x+iy.$ Let's think of this product as a mapping
    from one complex number $z$ to a second complex number $w$, which
    is its product with $a$, $w=az.$ Our chain starting from repeated
    addition tells us how to map the real axis; it maps to the line in
    $w$ determined by the origin $0$ and the point $a$, corresponding
    to the $z$ values $0$ and $1$, respectively.  When we move
    perpendicular to the real axis in $z$, the natural response is to
    move perpendicular to the line through $0$ and $a$ in $w$, with
    the same map scale factor as when we move along the real axis
    (namely the length of $a$).  Geometrically, this means that we map
    a square grid in the $z$-plane with edges $0$, $1$, and $i$ into a
    square grid in the $w$-plane with edges $0$, $a$, and $ia$.  The
    grid squares can be any size, for example, the grid based on
    $1/100$ and $i/100$ maps to the grid based on $a/100$ and
    $ia/100$.</p>
  <p>Return now to our function $1^x$, which maps the real axis onto
    the unit circle periodically, revolving around the circle once
    every time $x$ increases by $1$.  Let's assume this is a part of a
    function $w = 1^z$ which produces a complex value $w$ for every
    complex value $z$, that is, a mapping from a complex plane with
    coordinates $z$ to a second complex plane with coordinates $w$.
    We know the values $w = 1^z$ where $z = x + i0$, and we want to
    extend this definition to all values $z = x + iy.$ If we make a
    fine enough square grid in the $z$ plane, we can do the same thing
    for grid squares adjacent to the $y=0$ line as we did for
    multiplication, namely just rotate the squares in the $z$-grid so
    they fit adjacent to the unit circle in the $w$-plane.  Because of
    the curvature, the squares won't quite fit in $w$, overlapping
    slightly inside the circle and leaving slight gaps outside the
    circle.  However, the finer we make the $z$-grid, the smaller the
    overlaps or gaps in the $w$-grid become.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-2.2 -3.5 4.3 5.6" onload="map_interactions(evt)"
       fill="none" stroke="#808080" stroke-width="0.01">
    <!-- begin z-plane -->
    <g transform="translate(-1.8,-2.7)">
    <line stroke="#ff8000" x1="-0.3" y1="0" x2="3.9" y2="0"/>
    <line stroke="#ff8000" x1="0" y1="-0.7" x2="0" y2="0.5"/>
    <!-- coordinates are 3.6*z, so dz=0.06 gives 60 steps from z=0 to 1 -->
    <path d="M -0.09,-0.42, 3.69,-0.42
             M -0.09,-0.36, 3.69,-0.36
             M -0.09,-0.30, 3.69,-0.30
             M -0.09,-0.24, 3.69,-0.24
             M -0.09,-0.18, 3.69,-0.18
             M -0.09,-0.12, 3.69,-0.12
             M -0.09,-0.06, 3.69,-0.06
             M -0.09,0.06, 3.69,0.06
             M -0.09,0.12, 3.69,0.12
             M -0.09,0.18, 3.69,0.18
             M -0.09,0.24, 3.69,0.24
             M -0.09,0.30, 3.69,0.30
             M -0.09,0.36, 3.69,0.36"/>
    <path d="M -0.06,-0.45, -0.06,0.39
             M 0.00,-0.45, 0.00,0.39
             M 0.06,-0.45, 0.06,0.39
             M 0.12,-0.45, 0.12,0.39
             M 0.18,-0.45, 0.18,0.39
             M 0.24,-0.45, 0.24,0.39
             M 0.30,-0.45, 0.30,0.39
             M 0.36,-0.45, 0.36,0.39
             M 0.42,-0.45, 0.42,0.39
             M 0.48,-0.45, 0.48,0.39
             M 0.54,-0.45, 0.54,0.39
             M 0.60,-0.45, 0.60,0.39
             M 0.66,-0.45, 0.66,0.39
             M 0.72,-0.45, 0.72,0.39
             M 0.78,-0.45, 0.78,0.39
             M 0.84,-0.45, 0.84,0.39
             M 0.90,-0.45, 0.90,0.39
             M 0.96,-0.45, 0.96,0.39
             M 1.02,-0.45, 1.02,0.39
             M 1.08,-0.45, 1.08,0.39
             M 1.14,-0.45, 1.14,0.39
             M 1.20,-0.45, 1.20,0.39
             M 1.26,-0.45, 1.26,0.39
             M 1.32,-0.45, 1.32,0.39
             M 1.38,-0.45, 1.38,0.39
             M 1.44,-0.45, 1.44,0.39
             M 1.50,-0.45, 1.50,0.39
             M 1.56,-0.45, 1.56,0.39
             M 1.62,-0.45, 1.62,0.39
             M 1.68,-0.45, 1.68,0.39
             M 1.74,-0.45, 1.74,0.39
             M 1.80,-0.45, 1.80,0.39
             M 1.86,-0.45, 1.86,0.39
             M 1.92,-0.45, 1.92,0.39
             M 1.98,-0.45, 1.98,0.39
             M 2.04,-0.45, 2.04,0.39
             M 2.10,-0.45, 2.10,0.39
             M 2.16,-0.45, 2.16,0.39
             M 2.22,-0.45, 2.22,0.39
             M 2.28,-0.45, 2.28,0.39
             M 2.34,-0.45, 2.34,0.39
             M 2.40,-0.45, 2.40,0.39
             M 2.46,-0.45, 2.46,0.39
             M 2.52,-0.45, 2.52,0.39
             M 2.58,-0.45, 2.58,0.39
             M 2.64,-0.45, 2.64,0.39
             M 2.70,-0.45, 2.70,0.39
             M 2.76,-0.45, 2.76,0.39
             M 2.82,-0.45, 2.82,0.39
             M 2.88,-0.45, 2.88,0.39
             M 2.94,-0.45, 2.94,0.39
             M 3.00,-0.45, 3.00,0.39
             M 3.06,-0.45, 3.06,0.39
             M 3.12,-0.45, 3.12,0.39
             M 3.18,-0.45, 3.18,0.39
             M 3.24,-0.45, 3.24,0.39
             M 3.30,-0.45, 3.30,0.39
             M 3.36,-0.45, 3.36,0.39
             M 3.42,-0.45, 3.42,0.39
             M 3.48,-0.45, 3.48,0.39
             M 3.54,-0.45, 3.54,0.39
             M 3.60,-0.45, 3.60,0.39
             M 3.66,-0.45, 3.66,0.39"/>
    <line stroke="#0080ff" stroke-width="0.03"
          x1="-0.3" y1="0" x2="3.9" y2="0"/>
    <circle fill="#ff8000" stroke="#ff8000" stroke-width="0.015"
            cx="3.6" cy="0" r="0.04"/>
    <circle fill="#ff8000" stroke="#ff8000" stroke-width="0.015"
            cx="0" cy="0" r="0.04"/>
    <text class="svgtxt" x="0.1" y="-0.53">z-plane</text>
    <text class="svgtxt" x="-0.05" y="0.0" style="text-anchor:end;">
      <tspan fill="#ff8000" dy="1em">0</tspan></text>
    <text class="svgtxt" x="3.65" y="0.0">
      <tspan fill="#ff8000" dy="1em">1</tspan></text>
    <g id="zmkg" transform="translate(0.36,0.0)">
      <polygon id="zmk1" fill="white" stroke="#000000" stroke-width="0.02"
               points="-0.06,-0.06, -0.06,0.06, 0.06,0.06, 0.06,-0.06"/>
      <polyline id="zmk2" stroke="#c04000" stroke-width="0.03"
                points="-0.06,0, 0,0, 0,0.06"/>
      <polyline id="zmk3" stroke="#0000ff" stroke-width="0.03"
                points="0.06,0, 0,0, 0,-0.06"/>
    </g>
    </g>
    <!-- begin w-plane -->
    <line stroke="#ff8000" x1="-2.1" y1="0" x2="2.1" y2="0"/>
    <line stroke="#ff8000" x1="0" y1="-2.1" x2="0" y2="2.1"/>
    <!-- r = exp(-2*pi*n/60) for n = 7, 6, 5, ..., -4, -5, -6 -->
    <circle cx="0" cy="0" r="0.48045"/>
    <circle cx="0" cy="0" r="0.53349"/>
    <circle cx="0" cy="0" r="0.59238"/>
    <circle cx="0" cy="0" r="0.65778"/>
    <circle cx="0" cy="0" r="0.73040"/>
    <circle cx="0" cy="0" r="0.81104"/>
    <circle cx="0" cy="0" r="0.90058"/>
    <circle cx="0" cy="0" r="1" stroke="#0080ff" stroke-width="0.03"/>
    <circle cx="0" cy="0" r="1.11040"/>
    <circle cx="0" cy="0" r="1.23299"/>
    <circle cx="0" cy="0" r="1.36911"/>
    <circle cx="0" cy="0" r="1.52026"/>
    <circle cx="0" cy="0" r="1.68809"/>
    <circle cx="0" cy="0" r="1.87446"/>
    <!-- theta = 2*pi*n/60 radians for n=0 to 59 -->
    <path d="M 0.43,0, 1.95,0
             M 0,0.43, 0,1.95
             M -0.43,0, -1.95,0
             M 0,-0.43, 0,-1.95
             M 0.42764, 0.04495, 1.93932, 0.20383
             M 0.42764, -0.04495, 1.93932, -0.20383
             M -0.42764, -0.04495, -1.93932, -0.20383
             M -0.42764, 0.04495, -1.93932, 0.20383
             M 0.4206, 0.0894, 1.90739, 0.40543
             M 0.4206, -0.0894, 1.90739, -0.40543
             M -0.4206, -0.0894, -1.90739, -0.40543
             M -0.4206, 0.0894, -1.90739, 0.40543
             M 0.40895, 0.13288, 1.85456, 0.60258
             M 0.40895, -0.13288, 1.85456, -0.60258
             M -0.40895, -0.13288, -1.85456, -0.60258
             M -0.40895, 0.13288, -1.85456, 0.60258
             M 0.39282, 0.1749, 1.78141, 0.79314
             M 0.39282, -0.1749, 1.78141, -0.79314
             M -0.39282, -0.1749, -1.78141, -0.79314
             M -0.39282, 0.1749, -1.78141, 0.79314
             M 0.37239, 0.215, 1.68875, 0.975
             M 0.37239, -0.215, 1.68875, -0.975
             M -0.37239, -0.215, -1.68875, -0.975
             M -0.37239, 0.215, -1.68875, 0.975
             M 0.34788, 0.25275, 1.57758, 1.14618
             M 0.34788, -0.25275, 1.57758, -1.14618
             M -0.34788, -0.25275, -1.57758, -1.14618
             M -0.34788, 0.25275, -1.57758, 1.14618
             M 0.31955, 0.28773, 1.44913, 1.3048
             M 0.31955, -0.28773, 1.44913, -1.3048
             M -0.31955, -0.28773, -1.44913, -1.3048
             M -0.31955, 0.28773, -1.44913, 1.3048
             M 0.28773, 0.31955, 1.3048, 1.44913
             M 0.28773, -0.31955, 1.3048, -1.44913
             M -0.28773, -0.31955, -1.3048, -1.44913
             M -0.28773, 0.31955, -1.3048, 1.44913
             M 0.25275, 0.34788, 1.14618, 1.57758
             M 0.25275, -0.34788, 1.14618, -1.57758
             M -0.25275, -0.34788, -1.14618, -1.57758
             M -0.25275, 0.34788, -1.14618, 1.57758
             M 0.215, 0.37239, 0.975, 1.68875
             M 0.215, -0.37239, 0.975, -1.68875
             M -0.215, -0.37239, -0.975, -1.68875
             M -0.215, 0.37239, -0.975, 1.68875
             M 0.1749, 0.39282, 0.79314, 1.78141
             M 0.1749, -0.39282, 0.79314, -1.78141
             M -0.1749, -0.39282, -0.79314, -1.78141
             M -0.1749, 0.39282, -0.79314, 1.78141
             M 0.13288, 0.40895, 0.60258, 1.85456
             M 0.13288, -0.40895, 0.60258, -1.85456
             M -0.13288, -0.40895, -0.60258, -1.85456
             M -0.13288, 0.40895, -0.60258, 1.85456
             M 0.0894, 0.4206, 0.40543, 1.90739
             M 0.0894, -0.4206, 0.40543, -1.90739
             M -0.0894, -0.4206, -0.40543, -1.90739
             M -0.0894, 0.4206, -0.40543, 1.90739
             M 0.04495, 0.42764, 0.20383, 1.93932
             M 0.04495, -0.42764, 0.20383, -1.93932
             M -0.04495, -0.42764, -0.20383, -1.93932
             M -0.04495, 0.42764, -0.20383, 1.93932"/>
    <circle fill="#ff8000" stroke="#ff8000" stroke-width="0.015"
            cx="1" cy="0" r="0.04"/>
    <text class="svgtxt" x="0.1" y="-2.0">w-plane</text>
    <text class="svgtxt" x="-2.0" y="-1.7">
      w = 1<tspan dy="-0.6em" font-size="0.8em">z</tspan></text>
    <text class="svgtxt" x="-0.02" y="0.0" style="text-anchor:end;">
      <tspan fill="#ff8000" dy="0.8em">0</tspan></text>
    <text class="svgtxt" x="1.02" y="0.0">
      <tspan fill="#ff8000" dy="0.8em">1</tspan></text>
    <polygon id="wmk1" fill="white" stroke="#000000" stroke-width="0.02"
             points="0.77992,-0.45029, 0.96163,-0.55520, 0.89833,-0.65268,
                     0.82519,-0.74300, 0.66925,-0.60260, 0.72858,-0.52935"/>
    <polyline id="wmk2" stroke="#c04000" stroke-width="0.03"
              points="0.89833,-0.65268, 0.80902,-0.58779, 0.866025,-0.50000"/>
    <polyline id="wmk3" stroke="#0000ff" stroke-width="0.03"
              points="0.72858,-0.52935, 0.80902,-0.58779, 0.74314,-0.66913"/>
  </svg></div>
  <p>In this way, we can define $1^{x+iy}$ for very small but non-zero
    values of $y$.  Evidently, for a fixed value of $y$, $w$ will
    trace concentric circles, slightly inside the unit circle when
    $y\gt 0$ and slightly outside the unit circle when $y\lt 0.$ We
    can repeat this procedure for each new value of $y$ to work our
    way farther inward or outward.  But as we move inward or outward a
    curious thing happens: The circumference of the circle at fixed
    $y$ shrinks or grows, while the number of grid steps in $x$ to go
    once arond remains fixed.  Therefore, the size of the grid squares
    in the $w$-plane shrinks or grows in proportion to the radius of
    the circle corresponding to the value of $y$.  We wind up with a
    $w$-grid like the one in this figure, consisting of squares (in
    the limit of a very fine grid) arranged in circles.</p>
  <p>You can drag the marked set of four adjacent squares around on
    the $z$-plane or the $w$-plane to get a feeling for how our
    expanded mapping $w=1^z$ works.  For this grid, you can still see
    the squares are slightly distorted in the $w$-plane, but you can
    also see that the distortion would be smaller for an even finer
    grid.  Notice how moving along the blue line - the real axis in
    $z$ and the unit circle in $w$ - where we had originally defined
    $1^x$ defines adjacent concentric circles in $w$.  Orbiting those
    adjacent circles defines the values on slightly larger circles,
    eventually mapping the whole $z$-plane to the whole the whole
    $w$-plane.  In fact, because the mapping is periodic in $z$ ($z+1$
    always maps to the same $w$ as $z$), our function $1^z$ covers the
    $w$-plane an infinite number of times.</p>
  <p>The key principle of analytic continuation is that we expand our
    mapping in such a way that locally, over any small grid square, it
    looks like a simple complex multiplication and addition.  Near any
    point $z_0$, our function $1^z = 1^{z_0} + c(z_0)(z-z_0)$ for some
    complex number $c$ (which may be different for each $z_0$).  (If
    you know calculus, you'll recognize that the function $c$ is the
    derivative of the function $1^z$.)  A function that is locally
    linear is called analytic.  When you think about it, you realize
    that this is what makes it possible to compute functions like
    $1^z$: If we define a function so that we can compute it by
    addition and multiplication in a small region, and we have an
    appetite for doing lots of adding and multiplying, we can slowly
    march as far from our starting point as we please.</p>

  <h2>Euler's formula</h2>

  <p>You will notice that according to our mapping, $1^{iy}$ is a
    point on the positive $w$-real axis, running from very near the
    origin $w=0$ for large positive $y$ through $w=1$ at $y=0,$ then
    out to infinity for large negative $y.$ In other words, $1^i$ is a
    real number less than $1$, and our mapping is simply

    $$1^z = 1^{x+iy} = 1^x(1^i)^y.$$

    Since $1^i$ is a positive real number, we can raise it to a real
    power $y$ using the standard definition.  The standard way to
    define $a^y$ for any positive real $a$ and any real $y$ goes
    through the same familiar steps we took to define $1^x$, beginning
    with counting numbers $y$, extending that to any integer $y$, then
    to any rational $y$ by defining reciprocal powers as roots.</p>
  <p>So what is the value of $1^i$?  If our grid has $n$ squares
    running from $z=0$ to $z=1$, then in the $w$-plane, we will go
    around the unit circle in $n$ steps.  Hence near the unit circle,
    the side of the grid squares must be $2\pi/n$, since the perimeter
    of the unit circle is $2\pi.$ The radial edge of each square
    resting on the unit circle must also be $2\pi/n$, so the next
    circle inward has radius $1-2\pi/n$.  This represents a step
    upward in the $z$-plane to the line $z=x+i/n.$ Exactly the same
    reasoning takes us to $z=x+i2/n,$ except that the perimeter of the
    circle was as factor of $1-2\pi/n$ smaller, so the corresponding
    circle radius drops by that factor to $(1-2\pi/n)^2$, after $n$
    such steps, we will have reached the line $z=x+i$, which maps to
    the circle of radius $1^i$ in the $w$-plane.  Therefore, $1^i
    \approx (1 - 2\pi/n)^n.$ Now for any finite $n$, this formula is
    not quite correct, because the grid in the $w$-plane is slightly
    distorted squares.  (For example, $n=60$ in the figure.)  So to
    get the exact answer we have to take the limit of an infinite $n$,
    an infinitely fine grid, written like this:

    $$1^i = \lim_{n\rightarrow\infty} (1 - 2\pi/n)^n.$$

    Thus, $1^i$ is roughly $1/535,$ although you need to make $n$ very
    large, above ten thousand, to begin to see convergence.</p>
  <p>Euler studied the function he defined by

    $$f(x) = \lim_{n\rightarrow\infty} (1 + x/n)^n.$$

    We have just demonstrated that $1^i = f(-2\pi),$ so we'll follow
    Euler's reasoning about this more general form.  You can replace
    $n$ on the right hand side by any multiple of $n$ since all grow
    without limit.  If you replace $n$ by $n|x|$ and work through some
    technical details, you find that Euler's limit is just a disguised
    form of an exponential function:

    $$f(x) = f(1)^x = f(-1)^{-x} = e^x.$$

    Here, Euler writes $e$ for the number $f(1)$, which is roughly
    $2.72$, and his choice has become the mathematical standard.</p>
  <p>Thus, our notation here is related to standard notation by $1^i =
    e^{-2\pi},$ where the left side is non-standard and the right side
    is standard.  Now, Euler had to work out how to analytically
    continue the function $e^x$ from the real axis into the complex
    plane.  We've already worked this out in reverse.  Since $1^{iy} =
    e^{-2\pi y}$ for all real $y$, we know

    $$e^z = 1^{-iz/(2\pi)}$$

    for any complex $z.$ This gives the standard notation in terms of
    ours, which means that our notation would look like this in
    textbooks:

    $$1^z = e^{i2\pi z}.$$

    In other words, to get from our notation on this page to textbook
    notation, just substitute $e^{i2\pi}$ for $1$ wherever $1$ appears
    as the base of an exponent.  Since in the standard notation, $1$
    is useless as the base of an exponent, so no one uses it and there
    is little chance of confusion.</p>
  <p>The relation to the trigonometric functions that appeared
    naturally from our discussion of the complex roots of unity,

    $$1^\alpha = \cos\alpha + i\sin\alpha,$$

    looks like this in standard notation

    $$e^{i\theta} = \cos\theta + i\sin\theta.$$

    This is the celebrated Euler formula.  The major difference is
    that the power of the number $e$ in the Euler formula is the pure
    imaginary number $i\theta,$ while in our non-standard notation,
    the exponent of $1$ is the ordinary real number $\alpha$.  The
    secondary difference is that the units of the angle $\theta$ are
    implicitly radians, while the units of the angle $\alpha$ are
    revolutions or cycles.  (So $\theta = 2\pi\alpha.$)</p>
  <p>To understand the meaning of an imaginary exponent, you need to
    work through the analytic continuation argument.  In the geometric
    approach on this page, the key element of that argument was that
    we want our extended function to look like a linear function, a
    complex multiplication and a complex add, on small scales, so that
    a grid of fine squares in $z$ maps to a grid of fine squares in
    $w$.  In Euler's purely algebraic approach, this analytic
    continuation step hardly needs to be mentioned.  Since his
    definition of $e^x$ in terms of $(1+x/n)^n$ begins with just
    addition and multiplication operations, all he needs to to is plug
    in complex numbers for $x$ and he automatically has definition of
    $e^x$ for complex values that will look like complex
    multiplication on small scales.</p>
  <p>In our roots of unity approach, angles were the primary players
    from the beginning; we didn't need to introduce radian angle
    measure or the constants $e$ or $\pi$ at all to reach the
    important relations between complex multiplication and the
    trigonometric functions.  It was only when we analytically
    continued our function $1^z$ to pure imaginary numbers that we
    discovered its relation to ordinary real exponential functions.
    The standard textbook approach, Euler's approach, is to begin with
    ordinary real exponentials and discover their connection to angles
    by analytic continuation to pure imaginaries.</p>
  <p>Our notation $1^\alpha$ simplifies many important mathematical
    formulas, especially in Fourier analysis.  However, it makes many
    others more complicated, notably anything involving rates of
    change of angles.  Similarly, measuring angles in revolutions or
    cycles is often the best choice in engineering - witness the units
    Hertz (cycles per second) or RPM (revolutions per minute) - while
    measuring angles in radians is often simplest in problems
    involving rates of change.</p>
</div>
<script>
  var tracking = null;

  function add_trackers(svg, targets, start, track, stop) {
    // svg = svg element
    // targets = array of elements in svg to listen for mouse down events
    // start(index, coords) --> tracking (or null to abort)
    //   index = index into targets
    //   coords = event coordinates in svg coordinate system
    // track(tracking, coords) --> tracking (or null to abort)
    //   tracking = returned by start
    //   coords = event coordinates in svg coordinate system
    // stop(tracking)
    //   tracking = returned by start

    function svgcoords(evt) {  // return event coordinates
      var CTM = svg.getScreenCTM();
      if (evt.touches) {
        evt = evt.touches[0];
      }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    function wrapstart(evt) {
      if (tracking !== null) {
        wrapstop(evt);
      }
      var t = evt.target;
      var index = targets.indexOf(t);
      if (index < 0) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = start(index, svgcoords(evt));
    }

    function wraptrack(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = track(tracking, svgcoords(evt));
    }

    function wrapstop(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      stop(tracking);
      tracking = null;
    }

    svg.addEventListener("mousedown", wrapstart);
    svg.addEventListener("mousemove", wraptrack);
    svg.addEventListener("mouseup", wrapstop);
    svg.addEventListener("mouseleave", wrapstop);
    svg.addEventListener("touchstart", wrapstart);
    svg.addEventListener("touchmove", wraptrack);
    svg.addEventListener("touchend", wrapstop);
    svg.addEventListener("touchcancel", wrapstop);
  }

  function get_element(id) {
    return document.getElementById(id);
  }

  var round = Math.round;
  var abs = Math.abs;
  var sqrt = Math.sqrt;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var cos = Math.cos;
  var atan2 = Math.atan2;
  var round = Math.round;
  var pi = Math.PI;

  function pow_interactions(evt) {
    var power = evt.target;
    var handle = ["ppt1"].map(get_element);
    var apts = get_element("parc").getAttributeNodeNS(null, "points");
    var pws = ["pow1","pow2","pow3","pow4","pow5","pow6"].map(get_element);
    var pts = ["ppt1","ppt2","ppt3","ppt4","ppt5","ppt6"].map(get_element);
    var pxy = pws.map(function(e)
                      {return e.getAttributeNodeNS(null, "points");});
    var cxy = pts.map(function(e) { return [
      e.getAttributeNodeNS(null, "cx"), e.getAttributeNodeNS(null, "cy")];});
    var xnow = 1.1;
    var ynow = -0.2;  // that is, 1.1+i0.2 since svg plots y downward

    function start(index, coords) {
      return [coords.x - xnow, coords.y - ynow];
    }

    function track(tracking, coords) {
      xnow = coords.x - tracking[0];
      ynow = coords.y - tracking[1];
      if (xnow*xnow + ynow*ynow > 4.0) {
        xnow = 1.1;
        ynow = -0.2;
      }
      var x = xnow;
      var y = ynow;
      var points = "1,0";
      var i, xq, yq, xyq, xx;
      for (i=0 ; i<6 ; i+=1) {
        xq = "" + x;  yq = "" + y;
        xyq = ", " + xq + "," + yq;
        points += xyq;
        pxy[i].value = "0,0" + xyq;
        cxy[i][0].value = xq;  cxy[i][1].value = yq;
        xx = x;
        x = x*xnow - y*ynow;  y = xx*ynow + y*xnow;  // (x, y) *= (xnow, ynow)
      }
      apts.value = points;
      return tracking;
    }
    
    function stop(tracking) {
      return;
    }

    add_trackers(power, handle, start, track, stop);
  }

  function classof(elem) {
    return elem.getAttributeNodeNS(null, "class");
  }

  function unit_interactions(evt) {
    var unit = evt.target;
    var handle = ["upt1"].map(get_element);
    var apts = get_element("uarc").getAttributeNodeNS(null, "points");
    var tks = ["utk1","utk2","utk3","utk4","utk5"].map(get_element);
    var pws = ["uow1","uow2","uow3","uow4","uow5","uow6"].map(get_element);
    var pts = ["upt1","upt2","upt3","upt4","upt5","upt6"].map(get_element);
    var pxy = pws.map(function(e){return e.getAttributeNodeNS(null,"points")});
    var cxy = pts.map(function(e) { return [
      e.getAttributeNodeNS(null, "cx"), e.getAttributeNodeNS(null, "cy")];});
    var xnow = 1.1;
    var ynow = -0.2;  // that is, 1.1+i0.2 since svg plots y downward

    var power = 6;
    var buts = ["ubut2", "ubut3", "ubut4", "ubut5", "ubut6"].map(get_element);
    var butcl = buts.map(classof);
    var pwcl = pws.map(classof);
    var ptcl = pts.map(classof);
    var tkd = tks.map(function(e){return e.getAttributeNodeNS(null,"display")});
    var tkp = tks.map(function(e){return e.getAttributeNodeNS(null,"points")});
    // table of cosines and sines of 2pi/p for p=2, 3, 4, 5, 6
    var ctk = [-1.0, -0.5, 0.0, 0.309017, 0.5];
    var stk = [0.0, 0.866025, 1.0, 0.951057, 0.866025];

    function power_select(evt) {
      var but = evt.currentTarget;
      var old_power = power;
      var n = buts.indexOf(but)
      var i;
      power = n + 2;
      if (power < 2 || power > 7) {
        power = 6;
        but = buts[4];
      }
      if (power != old_power) {
        butcl[old_power-2].value = "";
        n = power - 1;
        butcl[power-2].value = "bselected";
        for (i=1 ; i<n ; i+=1) {
          pwcl[i].value = "linenot";
          ptcl[i].value = "dotnot";
        }
        if (n) {
          pwcl[n].value = "linehot";
          ptcl[n].value = "dothot";
        }
        for (i=n+1 ; i<6 ; i+=1) {
          pwcl[i].value = ptcl[i].value = "dotoff";
        }
        var c = ctk[power-2];
        var s = stk[power-2];
        var x = 1.0;
        var y = 0.0;
        var xx;
        for (i=0 ; i<5 ; i+=1) {
          tkd[i].value = (i <= n)? "block" : "none";
          if (i > n) {
            continue;
          }
          xx = x;
          x = x*c - y*s;
          y = xx*s + y*c;
          tkp[i].value = x + "," + y + ", " + (1.1*x) + "," + (1.1*y);
        }
      }
    }
    buts.map(function(e) {e.addEventListener("click", power_select);});

    function start(index, coords) {
      return [coords.x - xnow, coords.y - ynow];
    }

    function track(tracking, coords) {
      xnow = coords.x - tracking[0];
      ynow = coords.y - tracking[1];
      var r = sqrt(xnow*xnow + ynow*ynow);
      if (r > 1.2 || r < 0.1) {
        xnow = 0.983870;
        ynow = -0.178885;
        r = 1.0;
      } else {
        xnow /= r;
        ynow /= r;
      }
      var x = xnow;
      var y = ynow;
      var points = "1,0";
      var i, xq, yq, xyq, xx;
      for (i=0 ; i<6 ; i+=1) {
        xq = "" + x;  yq = "" + y;
        xyq = ", " + xq + "," + yq;
        points += xyq;
        pxy[i].value = "0,0" + xyq;
        cxy[i][0].value = xq;  cxy[i][1].value = yq;
        xx = x;
        x = x*xnow - y*ynow;  y = xx*ynow + y*xnow;  // (x, y) *= (xnow, ynow)
      }
      apts.value = points;
      return tracking;
    }
    
    function stop(tracking) {
      return;
    }

    add_trackers(unit, handle, start, track, stop);
  }

  function map_interactions(evt) {
    var acmap = evt.target;
    var handle = ["zmk1", "zmk2", "zmk3",
                  "wmk1", "wmk2", "wmk3"].map(get_element);
    var wpts = handle.slice(3, 6).map(
      function(e) {return e.getAttributeNodeNS(null, "points");});
    var ztrans = get_element("zmkg").getAttributeNodeNS(null, "transform");
    // (zx, zy) are z-plane coords in the zmkg group
    // note translate(-1.8,-2.7) on zmkg group
    // multiply by pi/1.8 to get z in radians, w=exp(z*pi/1.8)
    // but also note that y coordinates are sign-reversed for both zy and wy
    var zx = 0.36;
    var zy = 0.0;
    var torad = pi / 1.8;
    var wx = cos(torad*zx);
    var wy = -sin(torad*zx);

    function start(index, coords) {
      index = index > 2;
      if (index) {  // drag w-plane marker
        return [index, coords.x - wx, coords.y - wy];
      } else {  // drag z-plane marker
        return [index, coords.x - (zx - 1.8), coords.y - (zy - 2.7)];
      }
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var ezx, ezy, ewx, ewy, ewr;
      if (index) {  // drag w-plane marker
        ewx = coords.x - tracking[1];
        ewy = coords.y - tracking[2];
        ewr = sqrt(ewx**2 + ewy**2);
        if (ewr < 0.48) {
          if (ewr != 0.) {
            ewr = 0.48;
          } else {
            ewx = cos(torad*0.36);
            ewy = -sin(torad*0.36);
            ewr = 1.0;
          }
        } else if (ewr > 1.87) {
          ewr = 1.87;
        }
        // convert (ewx, ewy) to z-plane coordinates (ezx, ezy)
        ezx = atan2(-ewy, ewx) / torad;
        if (ezx < 0.) {
          ezx += 3.6;
        }
        ezy = log(ewr) / torad;
      } else {  // drag z-plane marker
        ezx = 1.8 + coords.x - tracking[1];
        ezy = 2.7 + coords.y - tracking[2];
        if (ezx < 0.) {
          ezx += 3.6;
          if (ezx < 0.) {
            ezx = 3.599;
          }
          tracking = null;
        } else if (ezx >= 3.6) {
          ezx -= 3.6;
          if (ezx > 3.6) {
            ezx = 0.;
          }
          tracking = null;
        }
        if (ezy < -0.42) {
          ezy = -0.42;
          tracking = null;
        } else if (ezy > 0.36) {
          ezy = 0.36;
          tracking = null;
        }
        ewr = exp(torad*ezy);
        ewx = ewr * cos(torad*ezx);
        ewy = -ewr * sin(torad*ezx);
      }
      ezx = 0.06 * round(ezx / 0.06);
      ezy = 0.06 * round(ezy / 0.06);
      if (abs(ezx - zx) > 0.03 || abs(ezy - zy) > 0.03) {
        zx = ezx;
        zy = ezy;
        ztrans.value = "translate(" + zx + "," + zy + ")";
        ewr = [];
        var x, y;
        for (y = zy-0.06 ; y < zy+0.09 ; y += 0.06) {
          ewr.push(exp(torad*y));
        }
        ewx = [];
        for (x = zx-0.06 ; x < zx+0.09 ; x += 0.06) {
          ewx.push([cos(torad*x), -sin(torad*x)]);
        }
        ewy = [];
        var i, j;
        for (i=0 ; i<3 ; i+=1) {
          y = ewr[i];
          for (j=0 ; j<3 ; j+=1) {
            x = ewx[j];
            ewy.push([y * x[0], y * x[1]])
          }
        }
        wx = ewy[4][0];
        wy = ewy[4][1];
        wpts[0].value = ("" + ewy[0][0] + "," + ewy[0][1] + ", " +
                         ewy[6][0] + "," + ewy[6][1] + ", " +
                         ewy[7][0] + "," + ewy[7][1] + ", " +
                         ewy[8][0] + "," + ewy[8][1] + ", " +
                         ewy[2][0] + "," + ewy[2][1] + ", " +
                         ewy[1][0] + "," + ewy[1][1]);
        wpts[1].value = ("" + ewy[3][0] + "," + ewy[3][1] + ", " +
                         ewy[4][0] + "," + ewy[4][1] + ", " +
                         ewy[7][0] + "," + ewy[7][1]);
        wpts[2].value = ("" + ewy[5][0] + "," + ewy[5][1] + ", " +
                         ewy[4][0] + "," + ewy[4][1] + ", " +
                         ewy[1][0] + "," + ewy[1][1]);
      }
      return tracking;
    }

    function stop(tracking) {
      return;
    }

    add_trackers(acmap, handle, start, track, stop);
  }
</script>
</body>
</html>
