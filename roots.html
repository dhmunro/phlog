<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Roots of Unity</title>
  <meta name="description"
    content="Angles are powers of complex numbers on the unit circle.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>MathJax = {tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
          id="MathJax-script">
  </script>
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
      float: right;
    }
    .clickable {
      cursor: pointer;
    }
    .backlit {
      background-color: #d8d8d8;
    }
    svg {
      background-color: #ffffff;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .belowsvg {
      font: italic bold large serif;
      padding-top: 0px;
      margin-top: 0px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .svgtxt {
      font: bold 0.45px sans-serif;
    }
    .bselected {
      background-color: #80c0ff;
    }
    .dothot {
      stroke: none;
      fill: #0080ff;
      opacity: 1.0;
    }
    .dotnot {
      stroke: none;
      fill: black;
      opacity: 0.1;
    }
    .dotoff {
      display: none;
    }
    .linehot {
      stroke: #0080ff;
      fill: none;
      opacity: 0.6;
    }
    .linenot {
      stroke: black;
      fill: none;
      opacity: 0.1;
    }
    .buttondiv {
      margin-top: 0em;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      margin-bottom: 1em;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;"><a href="index.html">Roots of Unity</a></h1>

  <h2>Powers of complex numbers</h2>
  <p><a href="coords.html">We define</a> complex multiplication to
    scale and rotate coordinates in a plane.  This definition
    automatically includes a definition of raising any complex number
    $z$ to the power $p$ -- multiply $z$ by itself $p$ times.
    Multiplying two powers evidently adds the powers: $z^p z^q =
    z^{p+q}$.  We can use this rule to uniquely define the zero power
    and negative powers, so we know how to raise a number to any
    integer power: $z^0 = 1$ and $z^{-p} = 1/z^p$.  Lastly, raising a
    power to a power evidently multiplies the powers: $(z^p)^q =
    z^{pq}$.  Following the idea we used to define negative integer
    powers, we naturally want to use this relation to define
    fractional powers, for example $(z^{1/p})^p = z^1 = z$ defines
    $z^{1/p}$.  For complex $z$, this procedure hits an extremely
    interesting and fruitful snag, which we explore here.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-2.1 -2.1 4.2 4.2" onload="pow_interactions(evt)"
       stroke-width="0.03">
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.015"
          x1="-2.1" y1="0" x2="2.1" y2="0"/>
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.015"
          x1="0" y1="-2.1" x2="0" y2="2.1"/>
    <circle fill="none" stroke="#0080ff" opacity="0.3" stroke-width="0.015"
            cx="0" cy="0" r="1"/>
    <polyline fill="none" stroke="#0080ff" points="0,0, 1,0"/>
    <polyline id="parc" fill="none" stroke="black" opacity="0.3"
              points="1,0, 1.1,-0.2, 1.17,-0.44, 1.199,-0.718, 1.1753,-1.0296,
                      1.08691,-1.36762, 0.922077,-1.721764"/>
    <polyline id="pow6" fill="none" stroke="black" opacity="0.3"
              points="0,0, 0.922077,-1.721764"/>
    <polyline id="pow5" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.08691,-1.36762"/>
    <polyline id="pow4" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.1753,-1.0296"/>
    <polyline id="pow3" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.199,-0.718"/>
    <polyline id="pow2" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.17,-0.44"/>
    <polyline id="pow1" fill="none" stroke="black" opacity="0.3"
              points="0,0, 1.1,-0.2"/>
    <circle id="ppt6" fill="black" stroke="none" opacity="0.6"
            cx="0.922077" cy="-1.721764" r="0.06"/>
    <circle id="ppt5" fill="black" stroke="none" opacity="0.6"
            cx="1.08691" cy="-1.36762" r="0.06"/>
    <circle id="ppt4" fill="black" stroke="none" opacity="0.6"
            cx="1.1753" cy="-1.0296" r="0.06"/>
    <circle id="ppt3" fill="black" stroke="none" opacity="0.6"
            cx="1.199" cy="-0.718" r="0.06"/>
    <circle id="ppt2" fill="black" stroke="none" opacity="0.6"
            cx="1.17" cy="-0.44" r="0.06"/>
    <circle id="ppt1" fill="#ff8000" stroke="transparent" stroke-width="0.05"
            cx="1.1" cy="-0.2" r="0.06"/>  <!-- fat stroke easier to grab -->
  </svg></div>
  <p>The modulus of the product of any two complex numbers is the
    product of their moduli, and the argument of their product is the
    sum of their arguments.  Geometrically, this means that when you
    raise a complex number $z$ to successive powers by squaring it,
    cubing it, raising it to the fourth power, and so on, what you are
    doing is constructing a series of triangles the same shape as the
    one formed by the points $0$, $1$, and $z$, stacked onto each
    other as shown in the figure.  The orange dot is $z$, and the blue
    segment goes from $0$ to $1$.  The gray dots are $z^2$, $z^3$,
    $z^4$, $z^5$, and $z^6$.  You can drag the orange point $z$ around
    to observe the pattern its powers make on the plane: An arc that
    spirals outward or inward according to whether $z$ is outside or
    inside the unit circle (of radius one centered at the origin).
    Examine what happens when $z$ lies on the unit circle or on the
    real (horizontal) or imaginary (vertical) axis.</p>
  <p>If the lovely arc of the powers of $z$ strikes your fancy, look
    up "logarithmic spiral" and you will find many people agree.</p>
</div>
<div class="textcolumn" style="clear: right;">

  <h2>Fractional powers</h2>
  <p>Let's take a closer look at the case when $z$ lies on the unit
    circle.  All powers of any such $z$ also lie on the unit circle.
    In the figure below, you may select a power $p$ from two to six
    and explore how $z^p$ changes as you move $z$ around the unit
    circle.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-1.1 -1.1 2.2 2.2" onload="unit_interactions(evt)"
       stroke-width="0.015">
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
          x1="-2.1" y1="0" x2="2.1" y2="0"/>
    <line stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
          x1="0" y1="-2.1" x2="0" y2="2.1"/>
    <circle fill="none" stroke="#0080ff" opacity="0.3" stroke-width="0.0075"
            cx="0" cy="0" r="1"/>
    <polyline fill="none" stroke="#0080ff" points="0,0, 1,0"/>
    <polyline id="uarc" fill="none" stroke="black" opacity="0.0"
              points="1,0, 0.983870,-0.178885, 0.936000,-0.352000,
                      0.857935,-0.513759, 0.752192,-0.658944,
                      0.622184,-0.782871, 0.472103,-0.881543"/>
    <polyline fill="none" stroke="#ff8000" points="1,0, 1.1,0"/>
    <polyline id="utk1" fill="none" stroke="#ff8000" display="block"
              points="0.5,0.866025, 0.55,0.952628"/>
    <polyline id="utk2" fill="none" stroke="#ff8000" display="block"
              points="-0.5,0.866025, -0.55,0.952628"/>
    <polyline id="utk3" fill="none" stroke="#ff8000" display="block"
              points="-1,0, -1.1,0"/>
    <polyline id="utk4" fill="none" stroke="#ff8000" display="block"
              points="-0.5,-0.866025, -0.55,-0.952628"/>
    <polyline id="utk5" fill="none" stroke="#ff8000" display="block"
              points="0.5,-0.866025, 0.55,-0.952628"/>
    <polyline id="uow6" class="linehot"
              points="0,0, 0.472103,-0.881543"/>
    <polyline id="uow5" class="linenot"
              points="0,0, 0.622184,-0.782871"/>
    <polyline id="uow4" class="linenot"
              points="0,0, 0.752192,-0.658944"/>
    <polyline id="uow3" class="linenot"
              points="0,0, 0.857935,-0.513759"/>
    <polyline id="uow2" class="linenot"
              points="0,0, 0.936000,-0.352000"/>
    <polyline id="uow1" fill="none" stroke="#ff8000" opacity="0.6"
              points="0,0, 0.983870,-0.178885"/>
    <circle id="upt6" class="dothot"
            cx="0.472103" cy="-0.881543" r="0.034"/>
    <circle id="upt5" class="dotnot"
            cx="0.622184" cy="-0.782871" r="0.034"/>
    <circle id="upt4" class="dotnot"
            cx="0.752192" cy="-0.658944" r="0.034"/>
    <circle id="upt3" class="dotnot"
            cx="0.857935" cy="-0.513759" r="0.034"/>
    <circle id="upt2" class="dotnot"
            cx="0.936000" cy="-0.352000" r="0.034"/>
    <circle id="upt1" fill="#ff8000" stroke="transparent" stroke-width="0.025"
            cx="0.983870" cy="-0.178885" r="0.034"/>
  </svg>
    <div class="buttondiv">
    <br/>Choose power: 
    <button id="ubut2" type="button" class=""><b>2</b></button>
    <button id="ubut3" type="button" class=""><b>3</b></button>
    <button id="ubut4" type="button" class=""><b>4</b></button>
    <button id="ubut5" type="button" class=""><b>5</b></button>
    <button id="ubut6" type="button" class="bselected"><b>6</b></button>
    </div>
  </div>
  <p>When you drag the orange point $z$ once around the circle, the
    blue point $z^p$ to orbits $p$ times.  Thus there are $p$ values
    of $z$ for which $z^p = 1$, marked by the orange ticks around the
    perimeter of the unit circle.  Since the angles between successive
    powers are equal, these $p$ points are equally spaced around the
    unit circle, forming a regular $p$-gon.  Each of these $p$ points
    is a $p$-th root of $1$.  We see that the fact that two real
    numbers ($+1$ and $-1$) whose squares are one is a special case of
    the general rule that there are $p$ complex numbers with a $p$-th
    power of one.  These "$p$-th roots of unity" are equally spaced
    around the unit circle.</p>
  <p>In standard mathematical notation, $1^{1/p} = 1$ for all $p$ --
    the most boring choice is the most convenient and consistent for
    many purposes.  But fractional powers are ambiguous, and in the
    case of roots of one, we can make a far more useful choice: On
    this page, let's write $1^{1/p}$ for the first
    <em>interesting</em> $p$-th root of unity - the nearest to $1$ as
    we go counterclockwise around the unit circle.  The other $p$-th
    roots are then $1^{2/p}$, $1^{3/p}$, $1^{4/p}$, and so on up to
    $1^{p/p} = 1.$ Powers greater than $p$ hop counterclockwise around
    the circle again, looping back to $1$ at every multiple of $p$;
    negative powers loop clockwise.</p>
  <p>Thus by defining $1^{1/p}$, we have in fact defined $1^\alpha$
    for all rational numbers $\alpha=n/p$, and by continuity for all
    real numbers $\alpha$.  Namely, $1^\alpha$ is the complex number
    which lies $\alpha$ counterclockwise revolutions around the unit
    circle starting from the point $1$, including fractions of a
    revolution.  That is, an angle in units of revolutions (often
    called cycles) is a power of $1$.</p>
  <p>In trigonometry, the $x$ and $y$ coordinates of a point on the
    unit circle as functions of angle from the $x$-axis are called
    cosine and sine, respectively, so by our definition

    $$1^\alpha = \cos\alpha + i\sin\alpha.$$

    Sine and cosine are available on many calculators and in any math
    library.  However, note that our angle $\alpha$ is in units of
    revolutions, so you will usually need to multiply it by either
    $360$ to convert to degrees or by $2\pi$ to convert to radians
    before invoking a library function.</p>

  <h2>Computing the trigonometric functions</h2>
  <p>This formula maps fractional powers $1^\alpha$ to the points on
    the unit circle and hence to the sine and cosine functions is
    lovely, but we still need to figure out how to compute both
    $\cos\alpha$ and $\sin\alpha$ given $\alpha$, and $\alpha$ given
    the coordinates of a point on the unit circle.  We do know values
    for a handful of fractions $\alpha$, and by raising these to
    powers we can get their multiples.  The half and quarter
    revolutions $1^{1/2}=-1$ and $1^{1/4}=i$ are obvious.
    Additionally, the angles associated with regular pentagons,
    hexagons, and octagons are mainstays of elementary geometry:

    $$\begin{align*}
    1^{1/5} &= \left.\left(\sqrt{5}-1 + i\sqrt{10+2\sqrt{5}}\right)
                \middle/ 4 \right. \\
    1^{1/6} &= (1 + i\sqrt{3}) / 2 \\
    1^{1/8} &= (1 + i) / \sqrt{2} \\
    \end{align*}$$

    (The more complicated pentagon formula doesn't get much love these
    days, but the ancient Greeks were enamored because of its
    connection to the golden ratio.)
  </p>
  <p>Complex multiplication (division) gets us beyond this handful
    of known values by allowing us to add (subtract) any pair of known
    angles.  The formula for adding angles is exactly the same as for
    multiplying two complex numbers:

    $$\begin{align*}
    1^{(\alpha+\beta)} &= 1^\alpha 1^\beta \\
    \cos(\alpha+\beta) + i\sin(\alpha+\beta)
    &= (\cos\alpha + i\sin\alpha)(\cos\beta + i\sin\beta)
    \end{align*}$$
    $$\quad\quad = (\cos\alpha\cos\beta - \sin\alpha\sin\beta)
    + i(\sin\alpha\cos\beta + \cos\alpha\sin\beta)$$

    To subtract angles, just reverse the sign of $\beta$ of the left
    side and $\sin\beta$ on the right side.  (The reciprocal of a
    complex number on the unit circle is its complex conjugate.)
    Unfortunately, these operations can only give us values for
    rational $\alpha$ which are multiples of the least common
    denominator of whatever angles we already know.  So if we start
    with $1/5$, $1/6$, and $1/8$, we can find any multiple of $1/120$
    or $3$ degrees.  For example, $1/5-1/6=1/30$ then
    $4/30-1/8=1/120$, or in degrees $72-60=12$ then $4\times 12-45=3$.
  </p>
  <p>To compute smaller angles, we can use the fact that the diagonal
    of the rhombus formed by the points $1^\alpha$, $0$, $1$, and
    $1+1^\alpha$ bisects angle $\alpha$.  Algebraically, notice that
    $1^\alpha||1+1^\alpha||^2 = 1^\alpha(1+1^{-\alpha})(1+1^\alpha) =
    (1+1^\alpha)^2$, so

    $$\begin{align*}
    1^{\alpha/2} &= (1+1^\alpha) / ||1 + 1^\alpha|| \\
    &= (1+\cos\alpha + i\sin\alpha) / \sqrt{2+2\cos\alpha},
    \end{align*}$$

    where $||z||$ means the modulus of $z$, and we have used the fact
    that $||1^\alpha|| = \cos^2\alpha + \sin^2\alpha = 1$ several
    times.</p>
  <p>Using the half-angle formula, we could compute the sine and
    cosine of $1/2^n$ revolutions for any $n$, and using the sum
    formulas we can recombine them to find the sine and cosine of any
    terminating binary fraction of a revolution.  However, if you are
    serious about building up a table of sines and cosines by hand (or
    at least by computing them using only ordinary addition,
    multiplication, division, and square root extraction), this isn't
    the best plan.  Instead, you should use the binomial expansion,
    that is, Pascal's triangle, to create equations for the sine and
    cosine of other multiples, which you can solve iteratively by
    Newton's method.</p>
  <p>We'll leave most of the work to the dedicated reader, but give a
    you a toolkit you could use to compute the sine and cosine of any
    number of degrees, or decimal fraction of a degree, or minutes or
    seconds of arc.  The basic idea is to develop algorithms to
    compute one third or one fifth of an angle.  To do this, we need
    to solve cubic and fifth degree polynomials; we'll show the
    polynomials and the iterative scheme devised by Newton for solving
    them:

    $$\begin{align*}
    1^{3\alpha} &= \cos 3\alpha + i\sin 3\alpha \\
      &= (\cos^3\alpha-3\sin^2\alpha\cos\alpha) +
      i(3\cos^2\alpha\sin\alpha-\sin^3\alpha)
    \end{align*}$$
    leads to the Newton iteration
    $$\sin\frac{\alpha}{3} = x
      \leftarrow \frac{\sin\alpha - (2x)^3}{3\left(1 - (2x)^2\right)}$$

    which solves the equation $\sin\alpha = 3(1-x^2)x - x^3$ for $x$.
    To use it, begin with a guess ($x=0$ works fine here), then plug
    this $x$ into the right hand side to get a much improved second
    guess ($x=(\sin\alpha)/3$ here), which you again plug into the right
    hand side, repeating until the result stops changing to whatever
    accuracy you want the final result.</p>
  <p>Newton iterations like this double the number of correct digits
    with each iteration, so just a few iterations gives a good enough
    answer for any practical purpose.  Here is the Newton iteration
    for finding the sine of one fifth of an angle $\alpha$ (again
    starting with $x=0$):

    $$\sin\frac{\alpha}{5} = x
    \leftarrow \frac{\sin\alpha - (2x)^3\left(5-2(2x)^2\right)}
    {5\left(1 - (2x)^2\left(3 - (2x)^2\right)\right)}$$
  </p>
  <p>Although we don't need an iterative scheme to compute the sine of
    $\alpha/2$ given the sine of $\alpha$, we do need to extract a
    square root.  The Newton iterations for computing the sine of
    $\alpha/3$ or $\alpha/5$ (or any other odd denominator), although
    recursive, only require ordinary addition, subtraction,
    multiplication, and divison.  (Though the most famous square root
    algorithm is also a Newton iteration.)  However, the
    textbook formula $\sin(\alpha/2)=\sqrt{(1-\cos\alpha)/2}$ is not
    very useful for small angles $\alpha$, because the cosine becomes
    very nearly $1$, which means you need to carry lots of significant
    figures.  Serious workers use the versine
    $\text{ver }\alpha=1-\cos\alpha$ (which isn't mentioned in most
    textbooks) instead of the cosine for calculations like this.  The
    half-angle formula for the versine is, when carefully written for
    accurate calculation of small angles:
    $$\text{ver }\frac{\alpha}{2} = \frac{\text{ver }\alpha}
    {2 + 2\sqrt{1-\tfrac{1}{2}\text{ver }\alpha}}$$
    To get back and forth between the sine and versine of an angle
    requires a square root operation.  Again, written with care:
    $$\begin{align*}
    \text{ver }\alpha&=1-\cos\alpha=
      \frac{\sin^2\alpha}{1+\sqrt{1-\sin^2\alpha}}\\
    \sin\alpha &= \sqrt{(2-\text{ver }\alpha)\text{ver }\alpha}
    \end{align*}$$
  </p>
  <p>Putting all this together gives us an outline for how we could
    build an accurate table of sines and cosines, or sines and versines
    for any angle:
    <ol>
      <li>Begin with $30$ degrees, for which $\sin 30^\circ=0.5$
        and (from the formula) $\text{ver }30^\circ=0.13397460$ to 8 places.
      </li>
      <li>Use the $\text{ver }(\alpha/2)$ formula to get $15^\circ$.</li>
      <li>Use the $\sin(\alpha/5)$ iteration on $30^\circ$; three
        iterations gets 8 places of $6^\circ$.</li>
      <li>Use the $\sin(\alpha/3)$ iteration on $6^\circ$ to get $2^\circ$;
        again three iterations gets 8 places.</li>
      <li>Use the $\text{ver }(\alpha/2)$ formula to get $1^\circ$.</li>
      <li>With the sines and cosines (from the versines) of
        $30^\circ$, $15^\circ$, $6^\circ$, $2^\circ$, and $1^\circ$,
        use the addition formula to compute all the integer numbers of
        degrees less than $30$.  Generally, the best strategy is to use
        the biggest angles first: $24=30-6$, $21=15+6$, $9=15-6$, followed
        by $28=30-2$, $26=24+2$, $23=21+2$, and so on.</li>
      <li>Similarly, use the addition formulas to extend your sines and
        cosines up to $45^\circ$.  You can use the known fact that
        $\sin 45^\circ=1/\sqrt{2}=0.70710678$ to check the accuracy of
        your table.</li>
      <li>Once you have completed all the angles up to $45^\circ$ or $1/8$
        revolution, you can fill in every other angle using the symmetry
        of the unit circle.</li>
    </ol>
  </p>

  <h2>Relation to Euler's formula</h2>
  <p>You probably won't see this definition of the complex valued
    function $1^\alpha$ anywhere else.  The standard way to express
    the same idea is Euler's formula:

    $$e^{i\theta} = \cos\theta + i\sin\theta.$$

    Here, $\theta$ is in units of radians, and the meaning of both the
    real number $e$ and the meaning of raising a number to an
    imaginary power require a long discussion which, though brilliant
    and important, has nothing to do with the connection between
    trigonometry and powers of complex numbers.  Since $\theta=2\pi$
    equals one revolution, Euler writes

    $$e^{i2\pi} = 1,$$

    which shows how to get back and forth between our notation and the
    standard notation introduced by Euler: Just substitute $e^{i2\pi}$
    for $1$ as the base for the exponential, and remember to convert
    angles elsewhere from units of revolutions to units of
    radians:

    $$1^\alpha = e^{i2\pi\alpha} = \cos\alpha + i\sin\alpha.$$

  </p>
  <p>Our definition of $1^\alpha$ shows how powers of complex numbers
    relate to sines and cosines without needing to explain imaginary
    exponents.</p>
</div>
<script>
  var tracking = null;

  function add_trackers(svg, targets, start, track, stop) {
    // svg = svg element
    // targets = array of elements in svg to listen for mouse down events
    // start(index, coords) --> tracking (or null to abort)
    //   index = index into targets
    //   coords = event coordinates in svg coordinate system
    // track(tracking, coords) --> tracking (or null to abort)
    //   tracking = returned by start
    //   coords = event coordinates in svg coordinate system
    // stop(tracking)
    //   tracking = returned by start

    function svgcoords(evt) {  // return event coordinates
      var CTM = svg.getScreenCTM();
      if (evt.touches) {
        evt = evt.touches[0];
      }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    function wrapstart(evt) {
      if (tracking !== null) {
        wrapstop(evt);
      }
      var t = evt.target;
      var index = targets.indexOf(t);
      if (index < 0) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = start(index, svgcoords(evt));
    }

    function wraptrack(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = track(tracking, svgcoords(evt));
    }

    function wrapstop(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      stop(tracking);
      tracking = null;
    }

    svg.addEventListener("mousedown", wrapstart);
    svg.addEventListener("mousemove", wraptrack);
    svg.addEventListener("mouseup", wrapstop);
    svg.addEventListener("mouseleave", wrapstop);
    svg.addEventListener("touchstart", wrapstart);
    svg.addEventListener("touchmove", wraptrack);
    svg.addEventListener("touchend", wrapstop);
    svg.addEventListener("touchcancel", wrapstop);
  }

  function get_element(id) {
    return document.getElementById(id);
  }

  var round = Math.round;
  var abs = Math.abs;
  var sqrt = Math.sqrt;

  function pow_interactions(evt) {
    var power = evt.target;
    var handle = ["ppt1"].map(get_element);
    var apts = get_element("parc").getAttributeNodeNS(null, "points");
    var pws = ["pow1","pow2","pow3","pow4","pow5","pow6"].map(get_element);
    var pts = ["ppt1","ppt2","ppt3","ppt4","ppt5","ppt6"].map(get_element);
    var pxy = pws.map(function(e)
                      {return e.getAttributeNodeNS(null, "points");});
    var cxy = pts.map(function(e) { return [
      e.getAttributeNodeNS(null, "cx"), e.getAttributeNodeNS(null, "cy")];});
    var xnow = 1.1;
    var ynow = -0.2;  // that is, 1.1+i0.2 since svg plots y downward

    function start(index, coords) {
      return [coords.x - xnow, coords.y - ynow];
    }

    function track(tracking, coords) {
      xnow = coords.x - tracking[0];
      ynow = coords.y - tracking[1];
      if (xnow*xnow + ynow*ynow > 4.0) {
        xnow = 1.1;
        ynow = -0.2;
      }
      var x = xnow;
      var y = ynow;
      var points = "1,0";
      var i, xq, yq, xyq, xx;
      for (i=0 ; i<6 ; i+=1) {
        xq = "" + x;  yq = "" + y;
        xyq = ", " + xq + "," + yq;
        points += xyq;
        pxy[i].value = "0,0" + xyq;
        cxy[i][0].value = xq;  cxy[i][1].value = yq;
        xx = x;
        x = x*xnow - y*ynow;  y = xx*ynow + y*xnow;  // (x, y) *= (xnow, ynow)
      }
      apts.value = points;
      return tracking;
    }
    
    function stop(tracking) {
      return;
    }

    add_trackers(power, handle, start, track, stop);
  }

  function classof(elem) {
    return elem.getAttributeNodeNS(null, "class");
  }

  function unit_interactions(evt) {
    var unit = evt.target;
    var handle = ["upt1"].map(get_element);
    var apts = get_element("uarc").getAttributeNodeNS(null, "points");
    var tks = ["utk1","utk2","utk3","utk4","utk5"].map(get_element);
    var pws = ["uow1","uow2","uow3","uow4","uow5","uow6"].map(get_element);
    var pts = ["upt1","upt2","upt3","upt4","upt5","upt6"].map(get_element);
    var pxy = pws.map(function(e){return e.getAttributeNodeNS(null,"points")});
    var cxy = pts.map(function(e) { return [
      e.getAttributeNodeNS(null, "cx"), e.getAttributeNodeNS(null, "cy")];});
    var xnow = 1.1;
    var ynow = -0.2;  // that is, 1.1+i0.2 since svg plots y downward

    var power = 6;
    var buts = ["ubut2", "ubut3", "ubut4", "ubut5", "ubut6"].map(get_element);
    var butcl = buts.map(classof);
    var pwcl = pws.map(classof);
    var ptcl = pts.map(classof);
    var tkd = tks.map(function(e){return e.getAttributeNodeNS(null,"display")});
    var tkp = tks.map(function(e){return e.getAttributeNodeNS(null,"points")});
    // table of cosines and sines of 2pi/p for p=2, 3, 4, 5, 6
    var ctk = [-1.0, -0.5, 0.0, 0.309017, 0.5];
    var stk = [0.0, 0.866025, 1.0, 0.951057, 0.866025];

    function power_select(evt) {
      var but = evt.currentTarget;
      var old_power = power;
      var n = buts.indexOf(but)
      var i;
      power = n + 2;
      if (power < 2 || power > 7) {
        power = 6;
        but = buts[4];
      }
      if (power != old_power) {
        butcl[old_power-2].value = "";
        n = power - 1;
        butcl[power-2].value = "bselected";
        for (i=1 ; i<n ; i+=1) {
          pwcl[i].value = "linenot";
          ptcl[i].value = "dotnot";
        }
        if (n) {
          pwcl[n].value = "linehot";
          ptcl[n].value = "dothot";
        }
        for (i=n+1 ; i<6 ; i+=1) {
          pwcl[i].value = ptcl[i].value = "dotoff";
        }
        var c = ctk[power-2];
        var s = stk[power-2];
        var x = 1.0;
        var y = 0.0;
        var xx;
        for (i=0 ; i<5 ; i+=1) {
          tkd[i].value = (i <= n)? "block" : "none";
          if (i > n) {
            continue;
          }
          xx = x;
          x = x*c - y*s;
          y = xx*s + y*c;
          tkp[i].value = x + "," + y + ", " + (1.1*x) + "," + (1.1*y);
        }
      }
    }
    buts.map(function(e) {e.addEventListener("click", power_select);});

    function start(index, coords) {
      return [coords.x - xnow, coords.y - ynow];
    }

    function track(tracking, coords) {
      xnow = coords.x - tracking[0];
      ynow = coords.y - tracking[1];
      var r = sqrt(xnow*xnow + ynow*ynow);
      if (r > 1.2 || r < 0.1) {
        xnow = 0.983870;
        ynow = -0.178885;
        r = 1.0;
      } else {
        xnow /= r;
        ynow /= r;
      }
      var x = xnow;
      var y = ynow;
      var points = "1,0";
      var i, xq, yq, xyq, xx;
      for (i=0 ; i<6 ; i+=1) {
        xq = "" + x;  yq = "" + y;
        xyq = ", " + xq + "," + yq;
        points += xyq;
        pxy[i].value = "0,0" + xyq;
        cxy[i][0].value = xq;  cxy[i][1].value = yq;
        xx = x;
        x = x*xnow - y*ynow;  y = xx*ynow + y*xnow;  // (x, y) *= (xnow, ynow)
      }
      apts.value = points;
      return tracking;
    }
    
    function stop(tracking) {
      return;
    }

    add_trackers(unit, handle, start, track, stop);
  }
</script>
</body>
</html>
