<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Rulers and Graph Paper</title>
  <meta name="description"
    content="Why are complex numbers interesting.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>MathJax = {tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
          id="MathJax-script">
  </script>
  <style>
    div {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .textcolumn {
      padding-left: 1em;
      padding-right: 1em;
      min-width: 22em;
      max-width: 52em;
      margin: 0 auto;
    }
    .halfwide {
      width: 60%;
      float: right;
    }
    .clickable {
      cursor: pointer;
    }
    .backlit {
      background-color: #d8d8d8;
    }
    svg {
      background-color: #ffffff;
      stroke-linecap: round;
      stroke-linejoin: round;
      width: 100%;
      height: 100%;
    }
    .belowsvg {
      font: italic bold large serif;
      padding-top: 0px;
      margin-top: 0px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    .svgtxt {
      font: bold 0.45px sans-serif;
    }
    @media only screen and (max-width: 620px) {
      .halfwide {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="textcolumn">
  <h1 style="text-align: center;">
    <a href="index.html">Rulers and Graph Paper</a></h1>

  <h2>Adding and multiplying with rulers</h2>
  <p>A number line is an idealized infinite ruler, a coordinate system
    for the points on the line.  The point associated with the number
    zero is called the origin, and the distance from the origin to the
    point associated with the number one is the unit of the ruler.
    Both origin and unit are arbitrary.  We draw a circle at the
    origin and draw a square at the point corresponding to the number
    one; the thick segment connecting them is one unit long.</p>
  <p>To add two numbers we use two rulers, here blue and orange, with the
    same units but different origins: Drag the origin of the orange
    ruler to the first addend on the blue scale, then drag the gray slider
    to the second addend on the orange scale.  Read the sum as the position
    of the slider on the blue scale.</p>
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-6 -0.5 12 1.0" onload="add1d_interactions(evt)"
       stroke-width="0.03">
    <path fill="none" stroke="#0080ff"
      d="M -5.8,0 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2"/>
    <path id="add1t" fill="none" stroke="#ff8000" transform="translate(0.00,0)"
      d="M -12.8,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2"/>
    <line stroke="black" stroke-width="0.04" x1="-6" y1="0" x2="6" y2="0" />
    <line stroke="#0080ff" stroke-width="0.08" x1="0" y1="0" x2="1" y2="0" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.1" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.2" height="0.2" />
    <g id="add1ug" transform="translate(0.00,0)">
      <line stroke="#ff8000" stroke-width="0.08" x1="0" y1="0" x2="1" y2="0" />
      <circle id="add1uc" fill="#ff8000" stroke="#ff8000"
              cx="0" cy="0" r="0.1" />
      <rect fill="#ff8000" stroke="#ff8000"
            x="0.9" y="-0.1" width="0.2" height="0.2" />
    </g>
    <polygon id="add1s" fill="black" stroke="black" opacity="0.5"
             transform="translate(1.8,0)"
             points="-0.14142,0, 0,-0.14142, 0.14142,0, 0,0.14142"/>
  </svg>
  <p class="belowsvg">
    <span id="add1x" class="" style="color: #0080ff;">0.00</span> +
    <span id="add1y" class="" style="color: #ff8000;">1.80</span> =
    <span id="add1z" class="" style="color: #0080ff;">1.80</span></p>
  <p>Similarly, to multiply two numbers we can use two rulers with the
    same origins but different units: Drag the square marker of the
    orange ruler to the first multiplicand on the blue scale (which is
    the new unit of the stretched orange ruler), then drag the gray
    slider to the second multiplicand on the orange scale.  Read the
    product as the position of the slider on the blue scale.  Be sure
    to notice what happens when you drag the orange square to the left
    of the common origin - a negative unit sometimes makes sense.</p>
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-6 -0.5 12 1.0" onload="mul1d_interactions(evt)"
       stroke-width="0.03">
    <path fill="none" stroke="#0080ff"
      d="M -5.8,0 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.2 v .4 m .2,-.4 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2"/>
    <path id="mul1t" fill="none" stroke="#ff8000" stroke-width="0.03"
      transform="scale(1.00,1)"
      d="M -32.8,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2
      m .2,-.4 v .4 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2 m .2,-.2 v .2"/>
    <line stroke="black" x1="-6" y1="0" x2="6" y2="0" />
    <line stroke="#0080ff" stroke-width="0.08" x1="0" y1="0" x2="1" y2="0" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.1" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.2" height="0.2" />
    <line id="mul1ul" stroke="#ff8000" stroke-width="0.08"
          x1="0" y1="0" x2="1.00" y2="0" />
    <circle fill="#ff8000" stroke="#ff8000"
            cx="0" cy="0" r="0.1" />
    <rect id="mul1ur" fill="#ff8000" stroke="#ff8000"
          x="0.90" y="-0.1" width="0.2" height="0.2" />
    <polygon id="mul1s" fill="black" stroke="black" opacity="0.5"
      transform="translate(1.8,0)"
      points="-0.14142,0, 0,-0.14142, 0.14142,0, 0,0.14142"/>
  </svg>
  <p class="belowsvg">
    <span id="mul1x" class="" style="color: #0080ff;">1.00</span> &times;
    <span id="mul1y" class="" style="color: #ff8000;">1.80</span> =
    <span id="mul1z" class="" style="color: #0080ff;">1.8000</span></p>
  <p>Addition of numbers corresponds to displacing the coordinate
    origin.  Multiplication of numbers corresponds to changing the
    coordinate unit.</p>

  <h2>Adding and multiplying with graph paper</h2>
  <p>Graph paper provides a coordinate system for the points in a
    plane.  Our unit on the plane is a square instead of a segment;
    one corner goes at an arbitrary origin point, then we tile the
    remainder of the plane into a grid of our unit squares.  Two
    coordinate numbers are associated with each point of the plane,
    the row and column numbers of the point in our grid.  By analogy
    with our definitions in one dimension, we will define two
    dimensional "addition" as changing the origin with a fixed unit
    square, and "multiplication" as changing the unit square with a
    fixed origin.</p>
  <p>Generally we write the coordinates as the pair $(x, y)$, the
    horizontal number followed by the vertical number.  However, here
    we write $x + iy$, although we have not yet defined either the $+$
    sign or the symbol $i$ that multiplies $y$.  This notation will
    turn out to be consistent with our upcoming definitions of
    "addition" and "multiplication"; until then you may regard $x +
    iy$ as simply an eccentric way to write $(x, y)$.</p>
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg" style="padding-left: 0.5em"
       viewBox="-4.1 -4.1 8.2 8.2" onload="add2d_interactions(evt)"
       stroke-width="0.03">
    <defs>
      <marker id="arrow-gray" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#808080" stroke="none" points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrow-blue" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#0080ff" stroke="none" points="0,-3, 6,0, 0,3"/>
      </marker>
      <marker id="arrow-orange" orient="auto" viewBox="0 -3 6 6"
              refX="6" markerWidth="6" markerHeight="6">
        <polygon fill="#ff8000" stroke="none" points="0,-3, 6,0, 0,3"/>
      </marker>
    </defs>
    <path fill="none" stroke="#0080ff" opacity="0.33"
      d="M -5,-6 v 12
      m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12
      m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12
      M -6,-5 h 12
      m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12
      m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12"/>
    <path id="add2t" fill="none" stroke="#ff8000" opacity="0.33"
      stroke-width="0.03" transform="translate(0.00,0.00)"
      d="M -12,-13 v 26
         m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26
         m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26
         m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26
         m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26
         m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26 m 1,-26 v 26
         M -13,-12 h 26
         m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26
         m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26
         m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26
         m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26
         m -26,1 h 26 m -26,1 h 26 m -26,1 h 26 m -26,1 h 26"/>
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon id="add2gg" fill="none" stroke="#808080"
              points="0.0,0.0, 1.8,0.0, 1.8,-0.8, 0.0,-0.8" />
    <polygon id="add2gb" fill="none" stroke="#0080ff"
              points="0.0,0.0, 0.0,0.0, 0.0,0.0, 0.0,0.0" />
    <polygon id="add2go" fill="none" stroke="#ff8000"
              points="0.0,0.0, 1.8,0.0, 1.8,-0.8, 0.0,-0.8" />
    <g id="add2ug" transform="translate(0.00,0)">
      <polygon stroke="#ff8000" fill="none" stroke-width="0.1"
               points="0,0, 1,0, 1,-1, 0,-1"/>
      <circle id="add2uc" fill="#ff8000" stroke="#ff8000"
              cx="0" cy="0" r="0.125" />
      <rect fill="#ff8000" stroke="#ff8000"
            x="0.90" y="-0.1" width="0.25" height="0.25" />
    </g>
    <line id="add2vb" fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          marker-end="none" x1="0" y1="0" x2="0" y2="0"/>
    <line id="add2vo" fill="#ff8000" stroke="#ff8000" stroke-width="0.05"
          marker-end="none" x1="0" y1="0" x2="0" y2="0"/>
    <line id="add2vg" fill="#808080" stroke="#808080" stroke-width="0.05"
          marker-end="url(#arrow-gray)" x1="0" y1="0" x2="1.8" y2="-0.8"/>
    <circle id="add2ucx" fill="#ff8000" stroke="#ff8000" opacity="0.0"
            transform="translate(0.00,0)" cx="0" cy="0" r="0.125" />
    <polygon id="add2s" fill="black" stroke="black" opacity="0.5"
      transform="translate(1.8,-0.8)"
      points="-0.1768,0, 0,-0.1768, 0.1768,0, 0,0.1768"/>
  </svg>
  <p class="belowsvg">
    (<span id="add2x" class="" style="color: #0080ff;">1.00 + i0.00</span>) +
    (<span id="add2y" class="" style="color: #ff8000;">1.80 + i0.80</span>) =
    <span id="add2z" class="" style="color: #808080;">1.80 + i0.80</span></p>
  </div>
  <p>To explore this idea, we need two overlapping sheets of graph
    paper which initially overlay each other.  We choose the lower left
    corner of our unit square to be the origin, drawn with a circular
    marker here.  We also need to specify which edge of our unit square
    corresponds to the $x$ axis (our first coordinate); here drawn with
    a square marker.</p>
  <p>To add two points in the plane, we drag the origin of the orange
    sheet to first addend on the blue plane, then drag the gray diamond
    marker to the second addend on the orange sheet.  Read the sum as the
    position of the gray diamond on the blue sheet.  We've drawn arrows
    corresponding to the first and second addends (blue and orange) and
    to their sum (gray).  Note that you are to read the gray coordinates
    on the blue plane, not on the orange plane.</p>
  <p>Please convince yourself that this definition of "addition"
    of planar coordinate pairs amounts to simply adding each of the
    two components separately:
    $$(a+ib) + (x+iy) = (a+x) + i(b+y).$$
  </p>
</div><div class="textcolumn" style="clear: right; margin-top: 0.3em;">
  <div class="halfwide">
  <svg xmlns="http://www.w3.org/2000/svg" style="padding-left: 0.5em"
       viewBox="-4.1 -4.1 8.2 8.2" onload="mul2d_interactions(evt)"
       stroke-width="0.03">
    <path fill="none" stroke="#0080ff" opacity="0.33"
      d="M -5,-6 v 12
      m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12
      m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12 m 1,-12 v 12
      M -6,-5 h 12
      m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12
      m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12 m -12,1 h 12"/>
    <path id="mul2t" fill="none" stroke="#ff8000" opacity="0.33"
      stroke-width="0.03" transform="scale(1.00,1.00)"
      d="M -32,-33 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66 m 1,-66 v 66
         M -33,-32 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66
         m -66,1 h 66 m -66,1 h 66 m -66,1 h 66 m -66,1 h 66"/>
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon id="mul2gg" fill="none" stroke="#808080"
             points="0.0,0.0, 1.8,0.0, 1.8,-0.8, 0.0,-0.8" />
    <polygon id="mul2gb" fill="none" stroke="#0080ff"
             points="0.0,0.0, 0.0,0.0, 0.0,0.0, 0.0,0.0" />
    <polygon id="mul2go" fill="none" stroke="#ff8000"
             points="0.0,0.0, 1.8,0.0, 1.8,-0.8, 0.0,-0.8" />
    <polygon id="mul2ul" stroke="#ff8000" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1"/>
    <circle fill="#ff8000" stroke="#ff8000" cx="0" cy="0" r="0.125" />
    <polygon id="mul2ur" fill="#ff8000" stroke="#ff8000"
             transform="matrix(1.0, 0.0, 0.0, 1.0, 1.0, 0.0)"
             points="-0.125,-0.125, 0.125,-0.125, 0.125,0.125, -0.125,0.125" />
    <line id="mul2vb" fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          marker-end="url(#arrow-blue)" x1="0" y1="0" x2="1.0" y2="0.0"/>
    <line id="mul2vec" fill="#808080" stroke="#808080" stroke-width="0.05"
          marker-end="url(#arrow-gray)" x1="0" y1="0" x2="1.8" y2="-0.8"/>
    <polygon id="mul2urx" fill="#ff8000" stroke="#ff8000" opacity="0.0"
             transform="matrix(1.0, 0.0, 0.0, 1.0, 1.0, 0.0)"
             points="-0.125,-0.125, 0.125,-0.125, 0.125,0.125, -0.125,0.125" />
    <polygon id="mul2s" fill="black" stroke="black" opacity="0.5"
      transform="translate(1.8,-0.8)"
      points="-0.1768,0, 0,-0.1768, 0.1768,0, 0,0.1768" />
  </svg>
  <p class="belowsvg">
    (<span id="mul2x" class="" style="color: #0080ff;">1.00 + i0.00</span>)
    &times;
    (<span id="mul2y" class="" style="color: #ff8000;">1.80 + i0.80</span>) =
    <span id="mul2z" class="" style="color: #808080;">1.8000 + i0.8000</span>
  </p>
  </div>
  <p>Multiplication is far more interesting.  We can scale our unit
    square by dragging its lower right corner, the one we marked with
    a square at the point $1+i0$.  Drag that orange square marker to
    first multiplicand on the blue plane, then drag the gray diamond
    marker to the second multiplicand on the orange sheet.  Read the
    product as the position of the gray diamond on the blue sheet.
    We've drawn arrows as for addition, but this time the orange arrow
    always coincides with the gray arrow.  But the orange arrow
    (hidden by the gray) has coordinates relative to the orange unit,
    indicated by the orange guideline rectangle, while the gray arrow
    has coordinates relative to the blue unit, indicated by the gray
    guideline rectangle.  (Again you are to read the gray coordinates
    on the blue plane, not on the orange plane.)</p>
  <p>As long as we drag the orange square marker directly to the left
    or right along the $x$-axis (the points $x+i0$ where $y=0$), this
    definition of multiplication exactly matches our one dimensional
    interpretation of multiplication with rulers.  However, we must
    now change the length of the vertical edge of our unit to keep it
    square.  Therefore the formula corresponding to our new two
    dimensional multiplication in this case is as simple as the
    addition formula:
    $$(a + i0)(x + iy) = ax + iay.$$
    But our orange unit square can be tilted as well as rescaled,
    and dragging the orange square marker off the $x$-axis does exactly
    that.  In other words, changing unit squares in two dimensions may
    rotate our coordinate system in addition to merely rescaling it
    -- we can orient our graph paper however we like.</p>
  <div style="width: 175px; float: left;">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-1.0 -3.4 3.5 4.0" stroke-width="0.03">
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon fill="none" stroke="#808080"
             points="0.0,0.0, 0.61,0.0, 0.61,-2.75, 0.0,-2.75" />
    <polygon fill="none" stroke="#0080ff"
             points="0.0,0.0, 0.0,0.0, 0.0,0.0, 0.0,0.0" />
    <polygon fill="none" stroke="#ff8000"
             points="0.0,0.0, 1.53,-0.68, 0.61,-2.75, -0.92,-2.07" />
    <polygon stroke="#ff8000" fill="none" stroke-width="0.1"
             points="0,0, 1.8,-0.8, 1,-2.6, -0.8,-1.8"/>
    <circle fill="#ff8000" stroke="#ff8000" cx="0" cy="0" r="0.125" />
    <polygon fill="#ff8000" stroke="#ff8000"
             transform="matrix(0.91381, -0.40614, 0.40614, 0.91381, 1.8, -0.8)"
             points="-0.125,-0.125, 0.125,-0.125, 0.125,0.125, -0.125,0.125" />
    <line fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          marker-end="url(#arrow-blue)" x1="0" y1="0" x2="1.8" y2="-0.8"/>
    <line fill="#808080" stroke="#808080" stroke-width="0.05"
          marker-end="url(#arrow-gray)" x1="0" y1="0" x2="0.61" y2="-2.75"/>
    <text class="svgtxt" x="0.0" y="0.5" style="text-anchor: end;">O</text>
    <text class="svgtxt" x="1.0" y="0.5">U</text>
    <text class="svgtxt" fill="#0080ff" x="1.8" y="-0.3">V</text>
    <text class="svgtxt" fill="#808080" x="0.61" y="-2.75">W</text>
  </svg></div>
  <p>Consider this labeled snapshot of the interactive picture: The
    the distance of point V from the origin O measured in blue units
    represents the ratio of the distance between any two points in
    blue units to the distance between the same two points in orange
    units, because OV has length one in orange units.  Hence, OW in
    blue units is OW in orange units times OV in blue units: The
    distance of the two dimensional product from O is the ordinary
    product of the distances of the multiplicands from O.
    Furthermore, the first multiplicand, OV, is at an angle UOV up
    from the blue $x$-axis (OU), while the second multiplicand, OW
    represented by orange coordinates, is at an angle VOW up from the
    orange $x$-axis (OV).  The product OW represented by blue
    coordinates is at an angle UOW up from the blue $x$-axis.  Since
    the sum of angles OUV and VOW equals angle UOW, the angle of a two
    dimensional product from the $x$-axis is the sum of the angles of
    the multiplicands.  To summarize, the two dimensional
    multiplication rule is that angles from the $x$-axis add and the
    distances from the origin multiply.</p>
  <p>Finally, we can justify our eccentric coordinate notation $x + iy$,
    by interpreting all the symbols as points and operations using our
    two dimensional definitions of addition and multiplication: First,
    interpreting $i$ as $0 + i1$ and $y$ as $y + i0$, we see that the
    orange unit square is just rotated ninety degrees, so the two
    dimensional product $iy = 0 + iy$.  And under two dimensional
    addition, interpreting $x$ as $x + i0$ means that the sum produces
    exactly $x + iy$.  The eccentric notation turns out to exactly
    match the behavior of our two dimensional arithmetic operations.</p>

  <h2>Complex numbers</h2>
  <p>Our two dimensional numbers $x + iy$, the coordinates of points
    in a plane in a slightly eccentric notation, are called complex
    numbers.  Addition corresponds to changing the coordinate origin
    with a fixed unit square, while multiplication corresponds to
    changing the unit square with a fixed origin.  This is a direct
    generalization of ordinary arithmetic, simply replacing the unit
    segment of a ruler with the unit square of a sheet of graph paper.
    You can verify these definitions of addition and multiplication
    satisfy the same three properties as ordinary arithmetic, namely
    both operations are commutative and associative, and the
    distributive law of multiplication over addition applies.  The
    ordinary numbers are embedded within the complex numbers as the
    line where $y = 0$, the $x$-axis.</p>
  <p>The complex number $i = 0 + i1$ is called the imaginary unit, a
    terrible name which came about because complex numbers were
    introduced into algebra before Descartes unified algebra
    and geometry.  The imaginary unit has the curious property that
    $i^2 = -1$, which is famously impossible for any ordinary number
    -- hence imaginary.  For us, $i$ is just the corner of the unit
    square diagonally opposite the corner we labeled $1$.</p>
  <div style="width: 160px; float: right;">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-1.5 -2.8 3.0 3.9" stroke-width="0.03">
    <g transform="translate(0,-1.5)">
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon stroke="#ff8000" fill="none" stroke-width="0.1"
             points="0,0, 0,-1, -1,-1, -1,0"/>
    <circle fill="#ff8000" stroke="#ff8000" cx="0" cy="0" r="0.125" />
    <rect fill="#ff8000" stroke="#ff8000"
          x="-0.1" y="-1.1" width="0.25" height="0.25" />
    <line fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          marker-end="url(#arrow-blue)" x1="0" y1="0" x2="0" y2="-1"/>
    </g>
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon stroke="#ff8000" fill="none" stroke-width="0.1"
             points="0,0, -1,0, -1,1, 0,1"/>
    <circle fill="#ff8000" stroke="#ff8000" cx="0" cy="0" r="0.125" />
    <rect fill="#ff8000" stroke="#ff8000"
          x="-1.1" y="-0.1" width="0.25" height="0.25" />
    <line fill="#0080ff" stroke="#0080ff" stroke-width="0.05"
          marker-end="url(#arrow-blue)" x1="0" y1="0" x2="-1" y2="0"/>
  </svg></div>
  <p>Two dimensional multiplication by $i$ represents a ninety degree
    rotation of the unit square (upper sketch), while multiplication
    by $-1$ represents a hundred eighty degree rotation of the unit
    square (lower sketch).  Since two ninety degree rotations produce
    a hundred eighty degree rotation, $i^2 = -1$ is perfectly natural
    in two dimensions, not imaginary at all.</p>
  <p>In one dimension, there isn't any way to smoothly change from
    multiplying by a positive number to multiplying by a negative
    number without going through multiplication by zero.  And a zero
    length unit, in either one or two dimensions, is worthless as a
    basis for a coordinate system.  But with a two dimensional unit
    square, we can smoothly change from multiplying by a positive
    number (with $y=0$) to multiplying by a negative number (with
    $y=0$), by rotating the unit square instead of rescaling it.  In
    exchange for this multiplicative smoothness, we are giving up an
    extremely important property of ordinary numbers: Complex numbers
    have no order.  Greater than and less than do not apply to
    complex numbers.</p>
  <div style="width: 96px; float: left;">
  <svg xmlns="http://www.w3.org/2000/svg"
       viewBox="-0.4 -1.3 1.8 2.6" stroke-width="0.03">
    <polygon stroke="#0080ff" fill="none" stroke-width="0.1"
             points="0,0, 1,0, 1,-1, 0,-1" />
    <circle fill="#0080ff" stroke="#0080ff"
            cx="0" cy="0" r="0.125" />
    <rect fill="#0080ff" stroke="#0080ff"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
    <polygon stroke="#ff8000" fill="none" stroke-width="0.1"
             points="0,0, 0,1, 1,1, 1,0"/>
    <circle fill="#ff8000" stroke="#ff8000" cx="0" cy="0" r="0.125" />
    <rect fill="#ff8000" stroke="#ff8000"
          x="0.9" y="-0.1" width="0.25" height="0.25" />
  </svg></div>
  <p>We have defined complex addition and multiplication to correspond
    to physical operations of translation, rotation, and scaling.  But
    that leaves out one important physical operation: reflection.
    Reflection does not correspond to any number of add or multiply
    operations in two dimensions.  (In one dimension, multiplying by
    -1 does correspond to reflection, but in two dimensions,
    multiplying by -1 is a hundred eighty degree rotation.)  Addition
    and multiplication can only produce the effects of sliding the
    graph paper around on the plane or of scaling its unit to a
    different size.  Reflection corresponds to flipping the graph
    paper over, for example by switching the order of the $x$ and $y$
    coordinates, or by multiplying just one of the coordinates by -1.
    In complex arithmetic, the operation of reflection through the
    $x$-axis, that is, of changing the sign of the $y$ coordinate, is
    called taking the complex conjugate.  In terms of our unit
    squares, complex conjugation flips the unit square vertically, as
    shown in the sketch to the left.</p>
  <p>Complex arithmetic, with its two dimensional add and multiply
    operations corresponding to translation, rotation, and scaling
    (with conjugation for reflection), turns out to be indispensible
    in both algebra and physics.  The behavior of functions of a
    complex variable remains a driving force in modern mathematics.
    The Riemann hypothesis, for example, is a problem in complex
    analysis that has remained at the forefront of mathematical
    research for a hundred and sixty years (so far).  In physics,
    complex arithmetic is central to quantum theory.</p>

  <h2>What happens in three dimensions?</h2>
  <p>We can tile space with unit cubes to make a three dimensional
    coordinate system.  Once again, we can define addition to
    correspond to translating the coordinate origin with a fixed unit
    cube.  Now multiplication should correspond to scaling and
    rotating the unit cube with the origin fixed.  But in three
    dimensions, rotation alone has three degrees of freedom (the
    rotation axis can be any point on a two dimensional spherical
    surface around the origin, and the angle of rotation is a third
    parameter), so it takes four numbers to describe rotation plus
    scaling.  There can be no correspondance between the three
    coordinates of a point in three dimensions and the natural scaling
    and rotating operations on the unit cube, which require four
    numbers to specify.  This problem becomes even more acute in four
    or more dimensions -- there are too many ways to rotate a cube or
    hypercube.</p>
  <p>Quarternions are an example of the problem, not a solution:
    Although they are designed to multiply like three dimensional
    rotation and scaling operations (and reflection), they have four
    coordinates, hence do not also serve as coordinates nor capture
    three dimensional translation operations.  For practical purposes,
    you probably will want to use the more general formalism of
    matrices and linear algebra instead of quarternions.</p>
  <p>These problems illustrate a subtle but crucial feature of complex
    numbers: A complex number can have many possible meanings: it at
    once represents the position of a point in a plane, a translation
    operation when used as an addend, and a rotation and scaling
    operation when used as a multiplicand.  This interchangability means
    we can chain together these physical operations in two dimensions
    in a way that is not possible in higher dimensions.  That feature
    keeps things from becoming incomprehensibly complicated for much
    longer in two dimensions than in three or more.</p>
  <p>Complex numbers and their arithmetic occupy a sweet spot in
    mathematics.  Plane geometry is the basis for the visual arts;
    what we see is a two dimensional projection of the world.
    Furthermore, even what we call "three dimensional" really consists
    of two dimensional surfaces - we can't really make sense out of
    truly three dimensional things like fog, and cutting into a solid
    object to discover its interior consists precisely of cleaving it
    to expose two dimensional sections.  We may live in a three
    dimensional world, but we really only experience two dimensional
    patterns.</p>
</div>
<!--
colors: orangered #ff4500   gold #ffd700
        dodgerblue #1e90ff
        blue: #0080ff  orange: #ff8000
  -->
<script>
  var tracking = null;

  function add_trackers(svg, targets, start, track, stop) {
    // svg = svg element
    // targets = array of elements in svg to listen for mouse down events
    // start(index, coords) --> tracking (or null to abort)
    //   index = index into targets
    //   coords = event coordinates in svg coordinate system
    // track(tracking, coords) --> tracking (or null to abort)
    //   tracking = returned by start
    //   coords = event coordinates in svg coordinate system
    // stop(tracking)
    //   tracking = returned by start

    function svgcoords(evt) {  // return event coordinates
      var CTM = svg.getScreenCTM();
      if (evt.touches) {
        evt = evt.touches[0];
      }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    function wrapstart(evt) {
      if (tracking !== null) {
        wrapstop(evt);
      }
      var t = evt.target;
      var index = targets.indexOf(t);
      if (index < 0) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = start(index, svgcoords(evt));
    }

    function wraptrack(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      tracking = track(tracking, svgcoords(evt));
    }

    function wrapstop(evt) {
      if (tracking === null) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();  // make usable for touch events
      stop(tracking);
      tracking = null;
    }

    svg.addEventListener("mousedown", wrapstart);
    svg.addEventListener("mousemove", wraptrack);
    svg.addEventListener("mouseup", wrapstop);
    svg.addEventListener("mouseleave", wrapstop);
    svg.addEventListener("touchstart", wrapstart);
    svg.addEventListener("touchmove", wraptrack);
    svg.addEventListener("touchend", wrapstop);
    svg.addEventListener("touchcancel", wrapstop);
  }

  function get_element(id) {
    return document.getElementById(id);
  }

  var round = Math.round;
  var abs = Math.abs;
  var sqrt = Math.sqrt;

  function add1d_interactions(evt) {
    var add1d = evt.target;
    var a1handle = ["add1uc", "add1s"].map(get_element);
    var xyz = ["add1x", "add1y", "add1z"].map(get_element);
    var cl_xyz = xyz.map(function(e)
                         {return e.getAttributeNodeNS(null, "class");});
    // xyz[0].textContent = value; (old way xyz[0].innerHTML = value;)
    // textContent not supported by IE8 and lower, but neither is SVG
    var xnow = 0.0;
    var ynow = 1.8;
    var xf_tick = get_element("add1t").getAttributeNodeNS(null, "transform");
    var xf_unit = get_element("add1ug").getAttributeNodeNS(null, "transform");
    var xf_slid = get_element("add1s").getAttributeNodeNS(null, "transform");

    function start(index, coords) {
      cl_xyz[index].value = "backlit";
      return [index, coords.x - (index? ynow : xnow)];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var x = round(20.*(coords.x - tracking[1])) * 0.05;
      if (x > 5.8 || x < -5.8) {
        x = index? 1.8 : 0.0;
        cl_xyz[index].value = "";
        tracking = null;
      }
      var xform = "translate(" + x + ",0.0)";
      if (index === 0) {
        xf_tick.value = xform;
        xf_unit.value = xform;
        xnow = x;
        xyz[0].textContent = xnow.toFixed(2);
        xyz[1].textContent = (ynow - xnow).toFixed(2);
      } else {
        xf_slid.value = xform;
        ynow = x;
        xyz[1].textContent = (ynow - xnow).toFixed(2);
      }
      xyz[2].textContent = ynow.toFixed(2);
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        cl_xyz[tracking[0]].value = "";
      }
      return;
    }

    add_trackers(add1d, a1handle, start, track, stop);
  }

  function mul1d_interactions(evt) {
    var mul1d = evt.target;
    var m1handle = ["mul1ur", "mul1s"].map(get_element);
    var xyz = ["mul1x", "mul1y", "mul1z"].map(get_element);
    var cl_xyz = xyz.map(function(e)
                         {return e.getAttributeNodeNS(null, "class");});
    var xf_tick = get_element("mul1t").getAttributeNodeNS(null, "transform");
    var xf_slid = get_element("mul1s").getAttributeNodeNS(null, "transform");
    var xnow = 1.0;
    var ynow = 1.8;
    var xul = get_element("mul1ul").getAttributeNodeNS(null, "x2");
    var xur = get_element("mul1ur").getAttributeNodeNS(null, "x");
    var twidth = get_element("mul1t").getAttributeNodeNS(null, "stroke-width");

    function start(index, coords) {
      cl_xyz[index].value = "backlit";
      var z = xnow * ynow;
      return [index, coords.x - (index? z : xnow), z];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var x = coords.x - tracking[1];
      var z = tracking[2];
      if (x > 5.8 || x < -5.8) {
        x = index? 1.8 : 1.0;
        cl_xyz[index].value = "";
        tracking = null;
      }
      if (index === 0) {
        if (abs(x) > 0.05) {
          x = round(20.*x) * 0.05;
        } else {
          x = 0.05;
        }
        xf_tick.value = "scale(" + x + ",1.0)";
        twidth.value = "" + (0.03 / abs(x));
        ynow = round(20.*(z / x)) * 0.05;  // in orange coordinates
        xnow = x;
        xul.value = "" + xnow;
        xur.value = "" + (xnow - 0.1);
        xyz[0].textContent = xnow.toFixed(2);
      } else {
        ynow = round(20.*(x / xnow)) * 0.05;  // in orange coordinates
      }
      xf_slid.value = "translate(" + (xnow * ynow) + ",0.0)";
      xyz[1].textContent = ynow.toFixed(2);
      xyz[2].textContent = (xnow * ynow).toFixed(4);
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        cl_xyz[tracking[0]].value = "";
      }
      return;
    }

    add_trackers(mul1d, m1handle, start, track, stop);
  }

  function str_complex(spanel, ndig, xy, xy0) {
    var x = xy[0];
    var y = xy[1];
    if (xy0 !== null) {
      x -= xy0[0];
      y -= xy0[1];
    }
    y = -y;
    var sgn = " + i";
    if (y < 0) {
      y = -y;
      sgn = " &minus; i";
    }
    spanel.innerHTML = x.toFixed(ndig) + sgn + y.toFixed(ndig);
  }

  function setvector(vecs, i, xy, color, xy0) {
    var x = xy[0];
    var y = xy[1];
    vecs[0][i].value = "" + x;
    vecs[1][i].value = "" + y;
    if (xy0 !== null) {
      x -= xy0[0];
      y -= xy0[1];
    }
    if (abs(x) + abs(y) < 0.3) {
      vecs[2][i].value = "none";
    } else {
      vecs[2][i].value = "url(#arrow-" + color + ")";
    }
  }

  function add2d_interactions(evt) {
    var add2d = evt.target;
    var a2handle = ["add2ucx", "add2s"].map(get_element);
    var xyz = ["add2x", "add2y", "add2z"].map(get_element);
    var cl_xyz = xyz.map(function(e)
                         {return e.getAttributeNodeNS(null, "class");});
    // xyz[0].textContent = value; (old way xyz[0].innerHTML = value;)
    // textContent not supported by IE8 and lower, but neither is SVG
    var xnow = [0.0, 0.0];
    var ynow = [1.8, -0.8];
    var xf_tick = get_element("add2t").getAttributeNodeNS(null, "transform");
    var xf_unit = get_element("add2ug").getAttributeNodeNS(null, "transform");
    var xfux = a2handle[0].getAttributeNodeNS(null, "transform");
    var xf_slid = get_element("add2s").getAttributeNodeNS(null, "transform");
    var add2gg = get_element("add2gg").getAttributeNodeNS(null, "points");
    var add2gb = get_element("add2gb").getAttributeNodeNS(null, "points");
    var add2go = get_element("add2go").getAttributeNodeNS(null, "points");
    var v = ["add2vb", "add2vo", "add2vg"].map(get_element);
    vecs = [v.map(function(e) {return e.getAttributeNodeNS(null, "x2");}),
            v.map(function(e) {return e.getAttributeNodeNS(null, "y2");}),
            v.map(function(e)
                  {return e.getAttributeNodeNS(null, "marker-end");})];
    var vox1 = v[1].getAttributeNodeNS(null, "x1");
    var voy1 = v[1].getAttributeNodeNS(null, "y1");

    function start(index, coords) {
      cl_xyz[index].value = "backlit";
      var dx = coords.x - (index? ynow[0] : xnow[0]);
      var dy = coords.y - (index? ynow[1] : xnow[1]);
      return [index, [dx, dy]];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var dxy = tracking[1];
      var x = round(20.*(coords.x - dxy[0])) * 0.05;
      var y = round(20.*(coords.y - dxy[1])) * 0.05;
      if (x > 3.8 || x < -3.8) {
        cl_xyz[index].value = "";
        index = 0;
        xnow = [0.0, 0.0];
        ynow = [1.8, -0.8];
        x = y = 0.0;
        tracking = null;
      }
      if (y > 3.8 || y < -3.8) {
        cl_xyz[index].value = "";
        index = 0;
        xnow = [0.0, 0.0];
        ynow = [1.8, -0.8];
        x = y = 0.0;
        tracking = null;
      }
      var xform = "translate(" + x + "," + y + ")";
      if (index === 0) {
        xf_tick.value = xform;
        xf_unit.value = xfux.value = xform;
        var p = ynow[0];
        var q = ynow[1];
        add2gb.value = "0,0, " + x + ",0, " + x + "," + y + ", 0," + y;
        add2go.value = x+","+y+", "+p+","+y+", "+p+","+q+", "+x+","+q;
        xnow = [x, y];
        str_complex(xyz[0], 2, xnow, null);
        str_complex(xyz[1], 2, ynow, xnow);
        setvector(vecs, 0, xnow, "blue", null);
        setvector(vecs, 1, ynow, "orange", xnow);
        vox1.value = xnow[0];
        voy1.value = xnow[1];
      }
      if (tracking === null) {
        index = 1;
        x = 1.8;
        y = -0.8;
        xform = "translate(" + x + "," + y + ")";
      }
      if (index !== 0) {
        xf_slid.value = xform;
        var p = xnow[0];
        var q = xnow[1];
        add2gg.value = "0,0, " + x + ",0, " + x + "," + y + ", 0," + y;
        if (tracking === null) {
          add2gb.value = "0,0, " + p + ",0, " + p + "," + q + ", 0," + q;
          add2go.value = p+","+q+", "+x+","+q+", "+x+","+y+", "+p+","+y;
        }
        ynow = [x, y];
        str_complex(xyz[1], 2, ynow, xnow);
        setvector(vecs, 1, ynow, "orange", xnow);
        vox1.value = xnow[0];
        voy1.value = xnow[1];
      }
      str_complex(xyz[2], 2, ynow, null);
      setvector(vecs, 2, ynow, "gray", null);
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        cl_xyz[tracking[0]].value = "";
      }
      return;
    }

    add_trackers(add2d, a2handle, start, track, stop);
  }

  function mul2d_interactions(evt) {
    var mul2d = evt.target;
    var m2handle = ["mul2urx", "mul2s"].map(get_element);
    var xyz = ["mul2x", "mul2y", "mul2z"].map(get_element);
    var cl_xyz = xyz.map(function(e)
                         {return e.getAttributeNodeNS(null, "class");});
    var xf_tick = get_element("mul2t").getAttributeNodeNS(null, "transform");
    var xf_slid = m2handle[1].getAttributeNodeNS(null, "transform");
    var xnow = [1.0, 0.0];
    var ynow = [1.8, -0.8];
    var xyul = get_element("mul2ul").getAttributeNodeNS(null, "points");
    var xfur = get_element("mul2ur").getAttributeNodeNS(null, "transform");
    var xfurx = m2handle[0].getAttributeNodeNS(null, "transform");
    var twidth = get_element("mul2t").getAttributeNodeNS(null, "stroke-width");
    var mul2gg = get_element("mul2gg").getAttributeNodeNS(null, "points");
    var mul2gb = get_element("mul2gb").getAttributeNodeNS(null, "points");
    var mul2go = get_element("mul2go").getAttributeNodeNS(null, "points");
    var vec = get_element("mul2vec");
    vec = [[vec.getAttributeNodeNS(null, "x2")],
           [vec.getAttributeNodeNS(null, "y2")],
           [vec.getAttributeNodeNS(null, "marker-end")]];
    var vbx2 = get_element("mul2vb");
    var vby2 = vbx2.getAttributeNodeNS(null, "y2");
    vbx2 = vbx2.getAttributeNodeNS(null, "x2");

    function start(index, coords) {
      cl_xyz[index].value = "backlit";
      var znow = [xnow[0]*ynow[0] - xnow[1]*ynow[1],
                  xnow[0]*ynow[1] + xnow[1]*ynow[0]];
      var dx = coords.x - (index? znow[0] : xnow[0]);
      var dy = coords.y - (index? znow[1] : xnow[1]);
      return [index, [dx, dy], znow];
    }

    function track(tracking, coords) {
      var index = tracking[0];
      var xy = tracking[1];
      var x = coords.x - xy[0];
      var y = coords.y - xy[1];
      var z = tracking[2];
      if (x > 3.8 || x < -3.8) {
        cl_xyz[index].value = "";
        index = 0;
        xnow = [1.0, 0.0];
        ynow = [1.8, -0.8];
        z = ynow;
        x = 1.0;
        y = 0.0;
        tracking = null;
      }
      if (y > 3.8 || y < -3.8) {
        cl_xyz[index].value = "";
        index = 0;
        xnow = [1.0, 0.0];
        ynow = [1.8, -0.8];
        z = ynow;
        x = 1.0;
        y = 0.0;
        tracking = null;
      }
      if (index === 0) {
        if (x*x + y*y < 0.05) {
          x = 0.05;
          y = 0.0;
        } else {
          x = round(20.*x) * 0.05;
          y = round(20.*y) * 0.05;
        }
        var r = x*x + y*y;
        var rx = x / r;
        var ry = -y / r;  // rx + i*ry = 1 / (x + i*y)
        r = sqrt(r);
        xf_tick.value = "matrix("+x+","+y+","+(-y)+","+x+",0.0,0.0)";
        twidth.value = "" + (0.03 / r);
        var zox = [rx*z[0] - ry*z[1], rx*z[1] + ry*z[0]];
        ynow = [round(20.*zox[0]) * 0.05, round(20.*zox[1]) * 0.05];
        xnow = [x, y];
        // orange unit square is (0,0), xnow, xnow+perp, perp
        var perp = [xnow[1], -xnow[0]];  // remember +y is downward
        xyul.value = ("0.0,0.0, " + xnow[0] + "," + xnow[1] + ", " +
                      (xnow[0]+perp[0]) + "," + (xnow[1]+perp[1]) + ", " +
                      perp[0] + "," + perp[1]);
        mul2gb.value = "0,0, " + x+",0, " + x+","+y + ", 0,"+y;
        x /= r;
        y /= r;
        xfur.value = xfurx.value = (
          "matrix(" + x + "," + y + "," + (-y) + "," + x + "," +
            xnow[0] + "," + xnow[1] + ")");
        vbx2.value = xnow[0];
        vby2.value = xnow[1];
        str_complex(xyz[0], 2, xnow, null);
      } else {
        // in mul1d:   ynow = round(20.*(x / xnow)) * 0.05;
        var rr2 = 20. / (xnow[0]*xnow[0] + xnow[1]*xnow[1]);
        ynow = [round(rr2*(x*xnow[0]+y*xnow[1])) * 0.05,
                round(rr2*(y*xnow[0]-x*xnow[1])) * 0.05];
      }
      var znow = [xnow[0]*ynow[0] - xnow[1]*ynow[1],
                  xnow[0]*ynow[1] + xnow[1]*ynow[0]];
      xf_slid.value = "translate(" + znow[0] + "," + znow[1] + ")";
      mul2gg.value = ("0,0, " + znow[0]+",0, " + znow[0]+","+znow[1] +
                      ", 0,"+znow[1]);
      mul2go.value = ("0,0, " + (xnow[0]*ynow[0])+","+(xnow[1]*ynow[0]) +
                      ", " + znow[0]+","+znow[1]+", " +
                      (-xnow[1]*ynow[1])+","+(xnow[0]*ynow[1]));
      setvector(vec, 0, znow, "gray", null);
      str_complex(xyz[1], 2, ynow, null);
      str_complex(xyz[2], 4, znow, null);
      return tracking;
    }

    function stop(tracking) {
      if (tracking !== null) {
        cl_xyz[tracking[0]].value = "";
      }
      return;
    }

    add_trackers(mul2d, m2handle, start, track, stop);
  }
</script>
</body>
</html>
